{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Modern C++: Snippets","text":"<p>Modern C++ Snippets</p> <p></p> <p></p> <ul> <li>We often need to copy and paste some snippets to code more productively.</li> <li>Snippets can help us when it's not easy to remember all high levels features Modern C++ has to offer.</li> <li>This repository contains lots of organized, reusable, and safe snippets for Modern C++.</li> <li>All snippets are available in GitHub pages in a convenient way for   copying and pasting.</li> </ul> <p></p> <p></p> <p> </p> <p></p>"},{"location":"contributors/","title":"Contributors","text":"<sub>Vishal-deriv</sub> <sub>Alan De Freitas</sub> <sub>Jo\u00e3o Vitor Vieira</sub>"},{"location":"contributors/#discussions","title":"Discussions","text":"<p>Discussions are concentrated on our GitHub discussions page. Don't refrain from asking questions and proposing ideas.</p> <p>If you are a programmer with good ideas, please share these ideas with us.</p> <p>Academic collaboration is more than welcome.</p>"},{"location":"contributors/#contributing","title":"Contributing","text":"<p>Feel free to contribute with new snippets to this repository. For complex features and changes, consider getting feedback from the community first.</p> <p>There are many ways in which you can contribute to this library:</p> <ul> <li>Testing the library in new environments</li> <li>Contributing with interesting snippets</li> <li>Finding problems in the documentation</li> <li>Finding bugs in general</li> <li>Whatever idea seems interesting to you</li> </ul> <p>The only thing we ask you is to make sure your contribution is not destructive. Some contributions in which we are not interested are:</p> <ul> <li>\"I don't like this optional feature so I removed/deprecated it\"</li> <li>\"I removed this feature to support older versions of C++\" but have not provided an equivalent alternative. This   repository is focused on Modern C++.</li> <li>\"I removed this feature, so I don't have to install/update ______\" but have not provided an equivalent alternative</li> <li>\"I'm creating this high-cost promise that we'll support __ forever\" but I'm not sticking around to keep that   promise</li> </ul> <p>In doubt, please open a discussion first.</p> <p></p>"},{"location":"contributors/#guidelines","title":"Guidelines","text":"<p>If contributing with code, please leave the pedantic warnings ON. You can use the helper CMake options <code>-DBUILD_WITH_PEDANTIC_WARNINGS=ON</code>:</p> <p></p>"},{"location":"quickstart/","title":"Quickstart","text":""},{"location":"quickstart/#why-c","title":"Why C++","text":"<p>C++ has always been a great language for Scientific Computing, High-Performance Computing, and Data Analysis:</p> <ul> <li>Most programmers are familiar with its basic syntax;</li> <li>It's been among the most popular languages over last 40 years;</li> <li>Access to hundreds of thousands of high-performance libraries;</li> <li>Performance   level almost no other language can   achieve;</li> <li>Complex abstractions with zero-overhead;</li> <li>Easy access to parallelism;</li> <li>Numerous compilers with   great optimization options available;</li> <li>Innumerable target platforms, from microcontrollers,   to GPUs,   to mobile, to webassembly;</li> <li>Does not rely on any virtual machine;</li> <li>Easy bindings from/to virtually any other programming language (Python   , Javascript, PHP, R   , Java, Matlab   , Rust   , Swift   , Julia, C, ... you name   it);</li> <li>Great tools for static analysis to   avoid bugs;</li> <li>Avoids the two-languages problem in scientific   computing: one for prototyping and one to reimplement all the work once the experiments are successful;</li> <li>No need for special licenses to distribute your compiled code, like it is common in technical languages that rely on   virtual machines;</li> <li>Allows saving tons of money and extra-security for applications to be run in the cloud or dedicated servers.</li> </ul> <p></p>"},{"location":"quickstart/#why-modern-c","title":"Why Modern C++","text":"<p>Many people have move from C++ over the last decade and might not be aware that the Modern C++ ecosystem has evolved to cover almost all use cases that made C++ inconvenient for certain tasks in the past:</p> <ul> <li>Efficient interpreters with beautiful IDEs;</li> <li>Cross-platform build systems, including microcontrollers   , GPUs   , mobile and webassembly;</li> <li>Package managers;</li> <li>Type deduction;</li> <li>Variant types;</li> <li>Types for optional data;</li> <li>Cheap automatic memory management via smart pointers;</li> <li>Numerous data structures out of the box;</li> <li>Modules;</li> <li>Concepts;</li> <li>Functional programming;</li> <li>Convenient meta programming;</li> <li>Structured bindings   and tuples;</li> <li>Ranges;</li> <li>Move semantics.</li> </ul> <p>By incentivizing and highlighting modern C++ features in instructional content , it's also possible to combine the familiar syntax of C and old C++ to achieve high levels of abstraction with a gentle learning curve.</p>"},{"location":"quickstart/#how-this-repository-works","title":"How this repository works","text":""},{"location":"quickstart/#snippets","title":"Snippets","text":"<ul> <li>The <code>snippets</code> directory has lots of   short programs with useful C++ snippets</li> <li>GitHub actions ensures all snippets are   working on GCC, MSVC, and Clang.</li> <li>We generate GitHub pages with all snippets by groups of tasks</li> </ul>"},{"location":"quickstart/#libraries","title":"Libraries","text":"<p>We give preference to libraries in this order:</p> <ol> <li>Libraries supported by most C++ compilers</li> <li>Libraries accepted into the C++ standard</li> <li>Libraries likely to be accepted into the next C++ standard</li> <li>Libraries representative of existing practice</li> </ol>"},{"location":"quickstart/#external-libraries","title":"External Libraries","text":"<p>For external libraries, we also include a short CMake snippet in the build script with:</p> <ul> <li><code>find_package</code> to find, setup, and link the large   external libraries</li> <li><code>FetchContents</code> to download, build, and link the   external library</li> </ul>"},{"location":"quickstart/#snippets-and-examples","title":"Snippets and Examples","text":"<p>Examples are often long and don't represent independent tasks you can copy and paste. Snippets represent independent tasks you can copy and paste.</p> <p>Why not get my snippets directly from <code>cppreference</code> or <code>cplusplus.com</code>?</p> <p><code>cppreference</code> is not meant for snippets and this repository is not meant to be a reference for the C++ standard. Some implications are:</p> <ul> <li>The snippets:<ul> <li>Meant to list the commands you most often need in a library.</li> <li>Lots of independent tasks for copying and pasting</li> <li>Include corresponding build scripts when something more complex is required</li> <li>Include external libraries when it's existing practice</li> <li>Organized roughly in the order someone learning C++ might need them</li> </ul> </li> <li>The examples in cppreference or cplusplus.com:<ul> <li>Meant to make points about the internals of the libraries.</li> <li>A single task meant to prove a point</li> <li>Has nothing to do with build scripts</li> <li>Has nothing to do with external libraries</li> <li>Might mix simple and complex concepts to make a point</li> </ul> </li> </ul>"},{"location":"quickstart/#github-pages","title":"GitHub Pages","text":"<p>We generate GitHub pages with all snippets:</p> <ul> <li>The GitHub pages are generated with mkdocs material</li> <li>Snippets are categorized by groups of tasks</li> <li>Sections are easy to explore, copy, and paste</li> </ul>"},{"location":"algorithms-data-structures/algorithm/basic-algorithms/","title":"Basic Algorithms","text":"Create number generator <pre><code>std::random_device rd;\nstd::mt19937 generator{rd()};\nstd::uniform_int_distribution&lt;int&gt; distribution(1, 30);\n</code></pre> Generating values <pre><code>std::vector&lt;int&gt; v(100);\nstd::generate(v.begin(), v.end(),\n              [&amp;] { return distribution(generator); });\nstd::for_each(v.begin(), v.end(),\n              [](const int c) { std::cout &lt;&lt; c &lt;&lt; \" \"; });\nstd::cout &lt;&lt; '\\n';\n</code></pre> Counting <pre><code>std::cout &lt;&lt; \"There are \" &lt;&lt; std::count(v.begin(), v.end(), 10)\n          &lt;&lt; \" tens\" &lt;&lt; '\\n';\n</code></pre> Comparing sequences <pre><code>auto v2 = v;\nif (std::equal(v.begin(), v.end(), v2.begin())) {\n    std::cout &lt;&lt; \"v and v2 are the same\" &lt;&lt; '\\n';\n}\n</code></pre> Finding elements <pre><code>auto position = std::find(v.begin(), v.end(), 10);\nif (position != v.end()) {\n    std::cout &lt;&lt; \"A ten was found in position \" &lt;&lt; position - v.begin()\n              &lt;&lt; '\\n';\n} else {\n    std::cout &lt;&lt; \"A ten was not found in any position\" &lt;&lt; '\\n';\n}\n</code></pre> Finding elements from a set <pre><code>std::vector&lt;int&gt; set = {16, 15, 14};\nauto position2 =\n    std::find_first_of(v.begin(), v.end(), set.begin(), set.end());\nif (position2 != v.end()) {\n    std::cout &lt;&lt; \"An element from the set was found in position \"\n              &lt;&lt; position2 - v.begin() &lt;&lt; '\\n';\n} else {\n    std::cout &lt;&lt; \"An element from the set was not found in any position\"\n              &lt;&lt; '\\n';\n}\n</code></pre> Finding mismatches <pre><code>v2[v2.size() / 3]++;\nauto mpair = std::mismatch(v.begin(), v.end(), v2.begin());\nstd::cout &lt;&lt; \"Elements \" &lt;&lt; *mpair.first &lt;&lt; \" and \" &lt;&lt; *mpair.second\n          &lt;&lt; \" mismatched at position \" &lt;&lt; mpair.first - v.begin()\n          &lt;&lt; '\\n';\n</code></pre> Adjacent elements <pre><code>auto i1 = std::adjacent_find(v.begin(), v.end());\nif (i1 == v.end()) {\n    std::cout &lt;&lt; \"No matching adjacent elements\" &lt;&lt; '\\n';\n} else {\n    std::cout &lt;&lt; \"The first adjacent pair of equal elements at: \"\n              &lt;&lt; std::distance(v.begin(), i1) &lt;&lt; '\\n';\n}\n</code></pre> Find subsequence <pre><code>std::vector&lt;int&gt; target = {v[30], v[31], v[32]};\nauto result =\n    std::search(v.begin(), v.end(), target.begin(), target.end());\nif (result == v.end()) {\n    std::cout &lt;&lt; \"Subsequence not found\" &lt;&lt; '\\n';\n} else {\n    std::cout &lt;&lt; \"First subsequence is at: \"\n              &lt;&lt; std::distance(v.begin(), result) &lt;&lt; '\\n';\n}\n</code></pre> Find last subsequence <pre><code>std::vector&lt;int&gt; v3 = {v[30], v[31], v[32]};\nauto result2 = std::find_end(v.begin(), v.end(), v3.begin(), v3.end());\nif (result2 == v.end()) {\n    std::cout &lt;&lt; \"Subsequence not found\" &lt;&lt; '\\n';\n} else {\n    std::cout &lt;&lt; \"Last subsequence is at: \"\n              &lt;&lt; std::distance(v.begin(), result2) &lt;&lt; '\\n';\n}\n</code></pre> Copying <pre><code>std::copy(v.begin(), v.end(), v2.begin());\nstd::for_each(v2.begin(), v2.end(),\n              [](const int c) { std::cout &lt;&lt; c &lt;&lt; \" \"; });\nstd::cout &lt;&lt; '\\n';\n</code></pre> Filling <pre><code>std::fill(v2.begin(), v2.end(), 0);\nstd::for_each(v2.begin(), v2.end(),\n              [](const int c) { std::cout &lt;&lt; c &lt;&lt; \" \"; });\nstd::cout &lt;&lt; '\\n';\n</code></pre> Removing elements <pre><code>v2 = v;\nauto last_removed = std::remove(v2.begin(), v2.end(), 10);\nstd::for_each(v2.begin(), v2.end(),\n              [](const int c) { std::cout &lt;&lt; c &lt;&lt; \" \"; });\n</code></pre> Erasing elements <pre><code>v2.erase(last_removed, v2.end());\nstd::for_each(v2.begin(), v2.end(),\n              [](const int c) { std::cout &lt;&lt; c &lt;&lt; \" \"; });\n</code></pre> Replacing elements <pre><code>std::replace(v2.begin(), v2.end(), 0, 100);\nstd::for_each(v2.begin(), v2.end(),\n              [](const int c) { std::cout &lt;&lt; c &lt;&lt; \" \"; });\n</code></pre> Swapping elements <pre><code>std::swap(v, v2);\nstd::for_each(v2.begin(), v2.end(),\n              [](const int c) { std::cout &lt;&lt; c &lt;&lt; \" \"; });\n</code></pre> Swapping ranges <pre><code>std::swap_ranges(v.begin(), v.end(), v2.begin());\nstd::for_each(v2.begin(), v2.end(),\n              [](const int c) { std::cout &lt;&lt; c &lt;&lt; \" \"; });\n</code></pre> Reverse <pre><code>std::reverse(v2.begin(), v2.end());\nstd::for_each(v2.begin(), v2.end(),\n              [](const int c) { std::cout &lt;&lt; c &lt;&lt; \" \"; });\n</code></pre> Rotate left <pre><code>std::rotate(v2.begin(), v2.begin() + 5, v2.end());\nstd::for_each(v2.begin(), v2.end(),\n              [](const int c) { std::cout &lt;&lt; c &lt;&lt; \" \"; });\n</code></pre> Rotate right <pre><code>std::rotate(v2.rbegin(), v2.rbegin() + 5, v2.rend());\nstd::for_each(v2.begin(), v2.end(),\n              [](const int c) { std::cout &lt;&lt; c &lt;&lt; \" \"; });\n</code></pre> Shuffle <pre><code>std::shuffle(v2.begin(), v2.end(), generator);\nstd::for_each(v2.begin(), v2.end(),\n              [](const int c) { std::cout &lt;&lt; c &lt;&lt; \" \"; });\n</code></pre> Sample <pre><code>std::sample(v.begin(), v.end(), v2.begin(), v.size(), generator);\nstd::for_each(v2.begin(), v2.end(),\n              [](const int c) { std::cout &lt;&lt; c &lt;&lt; \" \"; });\n</code></pre> Remove duplicates <pre><code>std::sort(v2.begin(), v2.end());\nstd::for_each(v2.begin(), v2.end(),\n              [](const int c) { std::cout &lt;&lt; c &lt;&lt; \" \"; });\nstd::cout &lt;&lt; \"(\" &lt;&lt; v2.size() &lt;&lt; \")\" &lt;&lt; '\\n';\n\nauto last_unique = std::unique(v2.begin(), v2.end());\nv2.erase(last_unique, v2.end());\nstd::for_each(v2.begin(), v2.end(),\n              [](const int c) { std::cout &lt;&lt; c &lt;&lt; \" \"; });\nstd::cout &lt;&lt; \"(\" &lt;&lt; v2.size() &lt;&lt; \")\" &lt;&lt; '\\n';\n</code></pre> Sorting (Usually Introsort = Quicksort + Heapsort) <pre><code>std::sort(v2.begin(), v2.end());\nstd::for_each(v2.begin(), v2.end(),\n              [](const int c) { std::cout &lt;&lt; c &lt;&lt; \" \"; });\n</code></pre> Checking if sorted <pre><code>if (std::is_sorted(v2.begin(), v2.end())) {\n    std::cout &lt;&lt; \"The vector is sorted\" &lt;&lt; '\\n';\n}\n</code></pre> Sorting partially <pre><code>v2 = v;\nstd::partial_sort(v2.begin(), v2.begin() + 15, v2.end());\nstd::for_each(v2.begin(), v2.end(),\n              [](const int c) { std::cout &lt;&lt; c &lt;&lt; \" \"; });\n</code></pre> Stable Sorting <pre><code>std::stable_sort(v2.begin(), v2.end());\nstd::for_each(v2.begin(), v2.end(),\n              [](const int c) { std::cout &lt;&lt; c &lt;&lt; \" \"; });\n</code></pre> Median and percentiles <pre><code>v2 = v;\nstd::nth_element(v2.begin(), v2.begin() + v2.size() / 2, v2.end());\nstd::cout &lt;&lt; \"The median is \" &lt;&lt; v[v.size() / 2] &lt;&lt; '\\n';\n\nstd::nth_element(v2.begin(), v2.begin() + 1, v2.end());\nstd::cout &lt;&lt; \"The second smallest element is \" &lt;&lt; v2[1] &lt;&lt; '\\n';\n</code></pre> Binary search <pre><code>std::sort(v.begin(), v.end()); // prepare\nif (std::binary_search(v.begin(), v.end(), 15)) {\n    std::cout &lt;&lt; \"Element 15 found\" &lt;&lt; '\\n';\n} else {\n    std::cout &lt;&lt; \"Element 15 not found\" &lt;&lt; '\\n';\n}\n</code></pre> Binary Search Lower bound <pre><code>auto lower = std::lower_bound(v.begin(), v.end(), 15);\nif (lower != v.end()) {\n    std::cout &lt;&lt; \"First 15 at position \" &lt;&lt; lower - v.begin()\n              &lt;&lt; '\\n';\n} else {\n    std::cout &lt;&lt; \"15 not found\" &lt;&lt; '\\n';\n}\n</code></pre> Binary Search Upper bound <pre><code>auto upper = std::upper_bound(v.begin(), v.end(), 15);\nif (upper != v.end()) {\n    std::cout &lt;&lt; \"Last 15 at position \" &lt;&lt; upper - v.begin()\n              &lt;&lt; '\\n';\n} else {\n    std::cout &lt;&lt; \"Last 15 not found\" &lt;&lt; '\\n';\n}\n</code></pre> Binary Search Equal Range (From lower to upper bound) <pre><code>auto range = std::equal_range(v.begin(), v.end(), 15);\nif (range.first != v.end()) {\n    std::cout &lt;&lt; \"15 from positions \" &lt;&lt; range.first - v.begin()\n              &lt;&lt; \" to \" &lt;&lt; range.second - v.begin() &lt;&lt; '\\n';\n}\n</code></pre> Creating heaps <pre><code>std::make_heap(v.begin(), v.end());\nstd::for_each(v.begin(), v.end(),\n              [](const int c) { std::cout &lt;&lt; c &lt;&lt; \" \"; });\nstd::cout &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"The largest element is \" &lt;&lt; v.front() &lt;&lt; '\\n';\n</code></pre> Pushing elements to heap <pre><code>v.push_back(31);\nstd::push_heap(v.begin(), v.end());\nstd::for_each(v.begin(), v.end(),\n              [](const int c) { std::cout &lt;&lt; c &lt;&lt; \" \"; });\nstd::cout &lt;&lt; '\\n';\n</code></pre> Popping elements from heap <pre><code>std::pop_heap(v.begin(), v.end());\nv.pop_back();\nstd::for_each(v.begin(), v.end(),\n              [](const int c) { std::cout &lt;&lt; c &lt;&lt; \" \"; });\nstd::cout &lt;&lt; '\\n';\n</code></pre> Sorting heap <pre><code>std::sort_heap(v.begin(), v.end());\nstd::for_each(v.begin(), v.end(),\n              [](const int c) { std::cout &lt;&lt; c &lt;&lt; \" \"; });\nstd::cout &lt;&lt; '\\n';\n</code></pre> Min/Max Values <pre><code>std::cout &lt;&lt; \"min: \" &lt;&lt; std::min(9, 3) &lt;&lt; \", max = \" &lt;&lt; std::max(9, 3)\n          &lt;&lt; '\\n';\n</code></pre> Min/Max Bounds <pre><code>std::pair&lt;int, int&gt; bounds =\n    std::minmax(std::rand() % v.size(), std::rand() % v.size());\nstd::cout &lt;&lt; \"v[\" &lt;&lt; bounds.first &lt;&lt; \",\" &lt;&lt; bounds.second &lt;&lt; \"]: \";\nfor (int i = bounds.first; i &lt; bounds.second; ++i) {\n    std::cout &lt;&lt; v[i] &lt;&lt; ' ';\n}\nstd::cout &lt;&lt; '\\n';\n</code></pre> Max element <pre><code>auto max_i = std::max_element(v.begin(), v.end());\nstd::cout &lt;&lt; \"Max element at: \" &lt;&lt; std::distance(v.begin(), max_i)\n          &lt;&lt; '\\n';\n</code></pre> Min element <pre><code>auto min_i = std::min_element(v.begin(), v.end());\nstd::cout &lt;&lt; \"Min element at: \" &lt;&lt; std::distance(v.begin(), min_i)\n          &lt;&lt; '\\n';\n</code></pre> Min/max elements <pre><code>auto result = std::minmax_element(v.begin(), v.end());\nstd::cout &lt;&lt; \"min element at: \" &lt;&lt; (result.first - v.begin()) &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"max element at: \" &lt;&lt; (result.second - v.begin()) &lt;&lt; '\\n';\n</code></pre> Check permutation <pre><code>std::vector&lt;int&gt; v1{1, 2, 3, 4, 5};\nstd::vector&lt;int&gt; v2{3, 5, 4, 1, 2};\nstd::cout &lt;&lt; \"3,5,4,1,2 is a permutation of 1,2,3,4,5? \"\n          &lt;&lt; std::boolalpha\n          &lt;&lt; std::is_permutation(v1.begin(), v1.end(), v2.begin())\n          &lt;&lt; '\\n';\n</code></pre> Get permutations <pre><code>std::vector&lt;int&gt; v3{1, 2, 3};\ndo {\n    std::for_each(v3.begin(), v3.end(),\n                  [](const int c) { std::cout &lt;&lt; c &lt;&lt; \" \"; });\n    std::cout &lt;&lt; '\\n';\n} while (std::next_permutation(v3.begin(), v3.end()));\n</code></pre> Sequentially increasing values <pre><code>std::iota(v.begin(), v.end(), 0);\nstd::for_each(v.begin(), v.end(),\n              [](const int c) { std::cout &lt;&lt; c &lt;&lt; \" \"; });\nstd::cout &lt;&lt; '\\n';\n</code></pre> Accumulating <pre><code>std::cout &lt;&lt; \"Total \" &lt;&lt; std::accumulate(v.begin(), v.end(), 0)\n          &lt;&lt; '\\n';\n</code></pre> Inner product <pre><code>std::vector&lt;int&gt; a{0, 1, 2, 3, 4};\nstd::vector&lt;int&gt; b{5, 4, 2, 3, 1};\nint r1 = std::inner_product(a.begin(), a.end(), b.begin(), 0);\nstd::cout &lt;&lt; \"Inner product of a and b: \" &lt;&lt; r1 &lt;&lt; '\\n';\n</code></pre> Adjacent difference <pre><code>std::vector&lt;int&gt; x{1, 4, 7, 8, 11, 11, 14, 15, 19, 22};\nstd::adjacent_difference(x.begin(), x.end(), x.begin());\nstd::for_each(x.begin(), x.end(),\n              [](const int c) { std::cout &lt;&lt; c &lt;&lt; \" \"; });\nstd::cout &lt;&lt; '\\n';\n</code></pre> Partial sum <pre><code>std::partial_sum(x.begin(), x.end(),\n                 std::ostream_iterator&lt;int&gt;(std::cout, \" \"));\nstd::cout &lt;&lt; '\\n';\n</code></pre> <p>  Share Snippets </p>"},{"location":"algorithms-data-structures/algorithm/ranges/","title":"Ranges","text":"<p>Ranges</p> <p>The ranges library is an extension and generalization of the algorithms and iterator libraries that makes them more powerful by making them composable and less error-prone.</p> <p>All algorithms that take iterator pairs have overloads that accept ranges (e.g ranges::sort).</p> <p>The library creates and manipulates range views, lightweight objects that indirectly represent iterable sequences (ranges). Ranges are an abstraction on top of [begin, end) iterator pairs, e.g. ranges made by implicit conversion  from containers. </p> <p>The ranges library was originally developed as the range-v3 library, and was finally merged to ISO C++ as of C++20. The range-v3 implementation is currently available on more compilers and platforms than the C++20 library.</p> CMakeLists.txt <pre><code># Ranges in C++20: https://en.cppreference.com/w/cpp/ranges\n# Use range-v3 for now: https://github.com/ericniebler/range-v3\nfind_package(range-v3 QUIET)\nif (NOT range-v3_FOUND)\n    FetchContent_Declare(range-v3 URL https://github.com/ericniebler/range-v3/archive/0.11.0.zip)\n    FetchContent_GetProperties(range-v3)\n    if (NOT range-v3_POPULATED)\n        FetchContent_Populate(range-v3)\n        add_library(range-v3 INTERFACE IMPORTED)\n        target_include_directories(range-v3 INTERFACE \"${range-v3_SOURCE_DIR}/include\")\n    endif ()\nendif()\nadd_executable(ranges ranges.cpp)\ntarget_link_libraries(ranges PUBLIC range-v3)\n</code></pre> Headers <pre><code>#include &lt;range/v3/all.hpp&gt;\n</code></pre> Sequentially increasing range <pre><code>std::vector&lt;double&gt; v(30);\nranges::iota(v, 1);\n</code></pre> Counting <pre><code>std::cout &lt;&lt; ranges::count(v, 0) &lt;&lt; '\\n';\n</code></pre> Accumulating <pre><code>std::cout &lt;&lt; ranges::accumulate(v, 0) &lt;&lt; '\\n';\n</code></pre> Sorting <pre><code>ranges::sort(v);\n</code></pre> Binary Search <pre><code>std::cout &lt;&lt; ranges::binary_search(v, 15) &lt;&lt; '\\n';\n</code></pre> Check if sorted <pre><code>std::cout &lt;&lt; ranges::is_sorted(v) &lt;&lt; '\\n';\n</code></pre> For each <pre><code>ranges::for_each(v, [](const int c) { std::cout &lt;&lt; c &lt;&lt; \" \"; });\nstd::cout &lt;&lt; '\\n';\n</code></pre> Filter views <pre><code>std::array&lt;int, 6&gt; a{{0, 5, 2, 1, 3, 4}};\nauto filtered_range = ranges::views::filter(a, [](int i) { return i &gt; 2; });\nstd::vector&lt;int&gt; v2(filtered_range.begin(), filtered_range.end());\n</code></pre> Reversed view <pre><code>auto reversed_range = ranges::views::reverse(a);\nfor (int x : reversed_range) {\n    std::cout &lt;&lt; x &lt;&lt; ' ';\n}\n</code></pre> Unique view <pre><code>ranges::sort(a);\nauto unique_range = ranges::views::unique(a);\nfor (int x : unique_range) {\n    std::cout &lt;&lt; x &lt;&lt; ' ';\n}\n</code></pre> Keys view <pre><code>std::map&lt;std::string, int&gt; m;\nm[\"a\"] = 0;\nm[\"b\"] = 1;\nm[\"c\"] = 2;\nauto map_keys = ranges::views::keys(m);\nfor (const std::string &amp;k : map_keys) {\n    std::cout &lt;&lt; k &lt;&lt; \",\";\n}\n</code></pre> Tokenize view <pre><code>std::string s = \"The range v3 library\";\nstd::regex expr{\"[\\\\w+]+\"};\nauto tokenizer = ranges::views::tokenize(\n    s, expr, 0, std::regex_constants::match_default);\nfor (auto &amp;x : tokenizer) {\n    std::cout &lt;&lt; x &lt;&lt; \",\";\n}\n</code></pre> Integer views <pre><code>auto ir = ranges::views::ints(0, 3);\nfor (auto x : ir) {\n    std::cout &lt;&lt; x &lt;&lt; \",\";\n}\n</code></pre> <p>  Share Snippets </p>"},{"location":"algorithms-data-structures/algorithm/searching/","title":"Searching","text":"Create vector for searching <pre><code>std::vector v = {5, 4, 9, 8, 6, 3};\n</code></pre> Sequential search from the standard library <pre><code>// - std::find is what you would use daily\n// - don't implement your own version unless you're studying the algorithms\nauto i1 = std::find(v.begin(), v.end(), 6);\nif (i1 != v.end()) {\n    std::cout &lt;&lt; \"*i1: \" &lt;&lt; *i1 &lt;&lt; '\\n';\n}\nstd::cout &lt;&lt; \"position: \" &lt;&lt; i1 - v.begin() &lt;&lt; '\\n';\n</code></pre> Prepare vector for binary search <pre><code>sort(v.begin(), v.end());\n</code></pre> Binary search from the standard library <pre><code>// - std::lower_bound is what you would use daily\n// - don't implement your own version unless you're studying the algorithms\nauto i2 = lower_bound(v.begin(), v.end(), 6);\nif (i2 != v.end()) {\n    std::cout &lt;&lt; \"*i2: \" &lt;&lt; *i2 &lt;&lt; '\\n';\n}\nstd::cout &lt;&lt; \"position: \" &lt;&lt; i2 - v.begin() &lt;&lt; '\\n';\n</code></pre> Textbook sequential search based on subscripts <pre><code>// This is what you would probably learn in college\n// Example only. Use std::find instead.\nsize_t sequential_find(const std::vector&lt;int&gt; &amp;v, const int key) {\n    for (size_t i = 0; i &lt; v.size(); ++i) {\n        if (v[i] == key) {\n            return i;\n        }\n    }\n    // return a sentinel\n    return v.size();\n}\n</code></pre> C++ sequential search based on iterators <pre><code>// This is what works in C++ for most container types.\n// Example only. Use std::find instead.\ntemplate &lt;class It, class T&gt;\nconstexpr It sequential_find(It first, It last, const T &amp;value) {\n    for (; first != last; ++first) {\n        // Best: O(1)\n        // Worst: O(n)\n        // Average: O(n)\n        if (*first == value) {\n            return first;\n        }\n    }\n    // return a sentinel\n    return last;\n}\n</code></pre> Call sequential search (vector + the textbook convention) <pre><code>size_t pos1 = sequential_find(v, 6);\nif (pos1 != v.size()) {\n    std::cout &lt;&lt; \"value: \" &lt;&lt; v[pos1] &lt;&lt; '\\n';\n}\nstd::cout &lt;&lt; \"position: \" &lt;&lt; pos1 &lt;&lt; '\\n';\n</code></pre> Sequential search (iterators + the C++ convention) <pre><code>auto it1 = sequential_find(v.begin(), v.end(), 6);\nif (it1 != v.end()) {\n    std::cout &lt;&lt; \"*it1: \" &lt;&lt; *it1 &lt;&lt; '\\n';\n}\nstd::cout &lt;&lt; \"position: \" &lt;&lt; it1 - v.begin() &lt;&lt; '\\n';\n</code></pre> Textbook binary search based on subscripts <pre><code>// This is what you would probably learn in college\n// Example only. Use std::lower_bound instead.\nsize_t binary_find(const std::vector&lt;int&gt; &amp;v, const int key) {\n    size_t left_idx = 0;\n    size_t right_idx = v.size() - 1;\n    size_t i;\n    do {\n        i = (left_idx + right_idx) / 2;\n        if (v[i] &lt; key) {\n            left_idx = i + 1;\n        } else {\n            right_idx = i - 1;\n        }\n    } while (v[i] != key &amp;&amp; left_idx &lt;= right_idx);\n    return v[i] == key ? i : v.size();\n}\n</code></pre> C++ binary search based on iterators <pre><code>// This is what works in C++ for most container types.\n// Example only. Use std::lower_bound instead.\ntemplate &lt;class It, class T&gt;\nIt binary_find(It first, It last, const T &amp;value) {\n    typename std::iterator_traits&lt;It&gt;::difference_type count, step;\n    It it;\n    count = std::distance(first, last);\n    while (count &gt; 0) {\n        it = first;\n        step = count / 2;\n        std::advance(it, step);\n        if (*it &lt; value) {\n            first = ++it;\n            count -= step + 1;\n        } else {\n            count = step;\n        }\n    }\n    return first;\n}\n</code></pre> Binary search (vector + the textbook convention) <pre><code>size_t pos2 = binary_find(v, 6);\nif (pos2 != v.size()) {\n    std::cout &lt;&lt; \"value: \" &lt;&lt; v[pos2] &lt;&lt; '\\n';\n}\nstd::cout &lt;&lt; \"position: \" &lt;&lt; pos2 &lt;&lt; '\\n';\n</code></pre> Binary search (iterators + the C++ convention) <pre><code>auto it2 = binary_find(v.begin(), v.end(), 6);\nif (it2 != v.end()) {\n    std::cout &lt;&lt; \"*it2: \" &lt;&lt; *it2 &lt;&lt; '\\n';\n}\nstd::cout &lt;&lt; \"position: \" &lt;&lt; it2 - v.begin() &lt;&lt; '\\n';\n</code></pre> <p>  Share Snippets </p>"},{"location":"algorithms-data-structures/algorithm/sorting/","title":"Sorting","text":"<p>Hint</p> <p>The standard algorithms for sorting containers are <code>std::sort</code> and <code>std::stable_sort</code>.</p> <p>These snippets include extra functions describing how these tasks can be implemented with many other classic  sorting algorithms. They are mostly relevant for people studying sorting algorithms for the first time.</p> Create vector for sorting <pre><code>std::vector&lt;int&gt; v = {5, 4, 9, 8, 6, 3};\n</code></pre> Sorting <pre><code>// - std::sort is what you would use daily\n// - don't implement your own version unless you're studying the algorithms\nstd::sort(v.begin(), v.end());\nstd::copy(v.begin(), v.end(), std::ostream_iterator&lt;int&gt;{std::cout, \" \"});\nstd::cout &lt;&lt; '\\n';\n</code></pre> Stable sorting <pre><code>// Elements that compare equal don't change their relative positions\nstd::stable_sort(v.begin(), v.end());\ncopy(v.begin(), v.end(), std::ostream_iterator&lt;int&gt;{std::cout, \" \"});\nstd::cout &lt;&lt; '\\n';\n</code></pre> Stable sorting <pre><code>// Elements that compare equal don't change their relative positions\nstd::stable_sort(v.begin(), v.end());\ncopy(v.begin(), v.end(), std::ostream_iterator&lt;int&gt;{std::cout, \" \"});\nstd::cout &lt;&lt; '\\n';\n</code></pre> Selection sort: O(n^2) <pre><code>template &lt;class It, class C&gt; void selection_sort(It first, It last, C comp) {\n    // For each position\n    for (auto it = first; it != std::prev(last); ++it) {\n        // Swap the current with the min_element\n        std::iter_swap(it, std::min_element(it, last, comp));\n    }\n}\n\ntemplate &lt;class It&gt; void selection_sort(It first, It last) {\n    // If no comparison function is provided, use `std::less`\n    selection_sort(first, last, std::less&lt;std::decay_t&lt;decltype(*first)&gt;&gt;());\n}\n</code></pre> Insertion sort: O(n^2) <pre><code>template &lt;class It, class C&gt; void insertion_sort(It first, It last, C comp) {\n    // For each position\n    for (auto i = std::next(first); i != last; ++i) {\n        // Push the element to the sorted subarray to the left\n        rotate(upper_bound(first, i, *i, comp), i, i + 1);\n    }\n}\n\ntemplate &lt;class It&gt; void insertion_sort(It first, It last) {\n    // If no comparison function is provided, use `std::less`\n    insertion_sort(first, last, std::less&lt;std::decay_t&lt;decltype(*first)&gt;&gt;());\n}\n</code></pre> Mergesort: O(n log n) <pre><code>template &lt;class It, class C&gt; void merge_sort(It first, It last, C comp) {\n    // While more than 1 element\n    if (last - first &gt; 1) {\n        It middle = first + (last - first) / 2;\n        // Sort left-hand side\n        merge_sort(first, middle, comp);\n        // Sort right-hand side\n        merge_sort(middle, last, comp);\n        // Merge left and right-hand sides\n        inplace_merge(first, middle, last, comp);\n    }\n}\n\ntemplate &lt;class It&gt; void merge_sort(It first, It last) {\n    // If no comparison function is provided, use `std::less`\n    merge_sort(first, last, std::less&lt;std::decay_t&lt;decltype(*first)&gt;&gt;());\n}\n</code></pre> Helper function for median of three values <pre><code>template &lt;typename T, class C&gt; constexpr T median(T t1, T t2, T t3, C comp) {\n    return (comp(t1, t2)) ? ((comp(t2, t3)) ? t2 : ((comp(t1, t3)) ? t3 : t1))\n                          : ((comp(t1, t3)) ? t1 : ((comp(t2, t3)) ? t3 : t2));\n}\n\ntemplate &lt;class It&gt; void median(It first, It last) {\n    // If no comparison function is provided, use `std::less`\n    median(first, last, std::less&lt;std::decay_t&lt;decltype(*first)&gt;&gt;());\n}\n</code></pre> Quicksort: O(n log n) <pre><code>template &lt;class It, class C&gt; void quick_sort(It first, It last, C comp) {\n    // If there is more than 1 element to sort\n    if (first != last &amp;&amp; std::next(first) != last) {\n        It middle = first + (last - first) / 2;\n        // Choose a pivot based on the median element\n        auto pivot = median(*first, *middle, *std::prev(last), comp);\n        // Partition the vector based on the pivot\n        It split1 =\n            partition(first, last, [&amp;](auto x) { return comp(x, pivot); });\n        It split2 =\n            partition(split1, last, [&amp;](auto x) { return !comp(pivot, x); });\n        // Sort left-hand side\n        quick_sort(first, split1, comp);\n        // Sort right-hand side\n        quick_sort(split2, last, comp);\n    }\n}\n\ntemplate &lt;class It&gt; void quick_sort(It first, It last) {\n    // If no comparison function is provided, use `std::less`\n    quick_sort(first, last, std::less&lt;std::decay_t&lt;decltype(*first)&gt;&gt;());\n}\n</code></pre> Call selection sort <pre><code>selection_sort(v.begin(), v.end());\ncopy(v.begin(), v.end(), std::ostream_iterator&lt;int&gt;{std::cout, \" \"});\nstd::cout &lt;&lt; '\\n';\n</code></pre> Call insertion sort <pre><code>insertion_sort(v.begin(), v.end());\ncopy(v.begin(), v.end(), std::ostream_iterator&lt;int&gt;{std::cout, \" \"});\nstd::cout &lt;&lt; '\\n';\n</code></pre> Call mergesort <pre><code>merge_sort(v.begin(), v.end());\ncopy(v.begin(), v.end(), std::ostream_iterator&lt;int&gt;{std::cout, \" \"});\nstd::cout &lt;&lt; '\\n';\n</code></pre> Call quicksort <pre><code>quick_sort(v.begin(), v.end());\ncopy(v.begin(), v.end(), std::ostream_iterator&lt;int&gt;{std::cout, \" \"});\nstd::cout &lt;&lt; '\\n';\n</code></pre> <p>  Share Snippets </p>"},{"location":"algorithms-data-structures/data-structures/associative-containers/","title":"Associative Containers","text":"<p>Associative Containers</p> <p>Associative containers implement sorted data structures that can be quickly searched (O(log n) complexity. They are usually implemented as binary trees.</p> <ul> <li>set: collection of unique keys, sorted by keys</li> <li>map: collection of key-value pairs, sorted by keys, keys are unique</li> <li>multiset: collection of keys, sorted by keys</li> <li>multimap: collection of key-value pairs, sorted by keys</li> </ul> <p>Unordered associative containers implement unsorted (hashed) data  structures that can be quickly searched (O(1) amortized, O(n) worst-case complexity). They are usually implemented as hash tables.</p> <ul> <li>unordered_set (C++11): collection of unique keys, hashed by keys</li> <li>unordered_map (C++11): collection of key-value pairs, hashed by keys, keys are unique</li> <li>unordered_multiset (C++11): collection of keys, hashed by keys</li> <li>unordered_multimap (C++11): collection of key-value pairs, hashed by keys</li> </ul> Headers <pre><code>#include &lt;map&gt;\n#include &lt;set&gt;\n#include &lt;unordered_map&gt;\n#include &lt;unordered_set&gt;\n</code></pre> Construct associative containers <pre><code>std::set&lt;int&gt; a = {2, 3, 1, 5, 4};\nstd::unordered_set&lt;int&gt; a2 = {1, 2, 3, 4, 5};\n</code></pre> Subscript Operator (Ordered maps) <pre><code>std::map&lt;std::string, double&gt; m;\nm[\"PI\"] = 3.14;\nm[\"ZERO\"] = 0.0;\nm[\"IRPF\"] = 0.15;\n</code></pre> Subscript Operator (Ordered maps) <pre><code>std::map&lt;std::string, double&gt; m;\nm[\"PI\"] = 3.14;\nm[\"ZERO\"] = 0.0;\nm[\"IRPF\"] = 0.15;\n</code></pre> Container size <pre><code>std::cout &lt;&lt; a.size() &lt;&lt; '\\n';\nstd::cout &lt;&lt; a2.size() &lt;&lt; '\\n';\nstd::cout &lt;&lt; m.size() &lt;&lt; '\\n';\nstd::cout &lt;&lt; m2.size() &lt;&lt; '\\n';\n</code></pre> Insert values in sets <pre><code>a.insert(8);\na2.insert(8);\n</code></pre> Insert values in maps with subscript operator <pre><code>m[\"hundred\"] = 100.0;\nm2[\"hundred\"] = 100.0;\n</code></pre> Insert values in maps with subscript operator <pre><code>m[\"hundred\"] = 100.0;\nm2[\"hundred\"] = 100.0;\n</code></pre> Erase elements <pre><code>a.erase(2);\na2.erase(2);\nm.erase(\"thousand\");\nm2.erase(\"thousand\");\n</code></pre> <p>  Share Snippets </p>"},{"location":"algorithms-data-structures/data-structures/bitset/","title":"Bitset","text":"<p>Bitset</p> <p>The class template bitset represents a fixed-size sequence of  N bits. Bitsets can be manipulated by standard logic operators and converted to and from strings and integers.</p> CMakeLists.txt <pre><code>add_executable(bitset bitset.cpp)\n</code></pre> Headers <pre><code>#include &lt;bitset&gt;\n</code></pre> Get type size <pre><code>std::cout &lt;&lt; \"sizeof(char) = \" &lt;&lt; sizeof(char) &lt;&lt; \" bytes\" &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"sizeof(unsigned char) = \" &lt;&lt; sizeof(unsigned char) &lt;&lt; \" bytes\"\n     &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"sizeof(short) = \" &lt;&lt; sizeof(short) &lt;&lt; \" bytes\" &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"sizeof(int) = \" &lt;&lt; sizeof(int) &lt;&lt; \" bytes\" &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"sizeof(long) = \" &lt;&lt; sizeof(long) &lt;&lt; \" bytes\" &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"sizeof(size_t) = \" &lt;&lt; sizeof(size_t) &lt;&lt; \" bytes\" &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"sizeof(double) = \" &lt;&lt; sizeof(double) &lt;&lt; \" bytes\" &lt;&lt; '\\n' &lt;&lt; '\\n';\n</code></pre> Binary literals <pre><code>uint32_t r = 0b111111110100010001100110;\nstd::cout &lt;&lt; r &lt;&lt; '\\n';\n</code></pre> Bitsets <pre><code>std::cout &lt;&lt; \"r = \" &lt;&lt; std::bitset&lt;32&gt;(r) &lt;&lt; '\\n' &lt;&lt; '\\n';\n</code></pre> Operators <pre><code>const uint32_t unit = 0x01;\nstd::cout &lt;&lt; \"unit &lt;&lt; 0 = \" &lt;&lt; std::bitset&lt;32&gt;(unit &lt;&lt; 0) &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"~(unit &lt;&lt; 0) = \" &lt;&lt; std::bitset&lt;32&gt;(~(unit &lt;&lt; 0)) &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"r &amp; (~(unit &lt;&lt; 0)) = \" &lt;&lt; std::bitset&lt;32&gt;(r &amp; (~(unit &lt;&lt; 0))) &lt;&lt; '\\n'\n     &lt;&lt; '\\n';\n\nstd::cout &lt;&lt; \"unit &lt;&lt; 1 = \" &lt;&lt; std::bitset&lt;32&gt;(unit &lt;&lt; 1) &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"~(unit &lt;&lt; 1) = \" &lt;&lt; std::bitset&lt;32&gt;(~(unit &lt;&lt; 1)) &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"r &amp; (~(unit &lt;&lt; 1)) = \" &lt;&lt; std::bitset&lt;32&gt;(r &amp; (~(unit &lt;&lt; 1))) &lt;&lt; '\\n'\n     &lt;&lt; '\\n';\n\nstd::cout &lt;&lt; \"unit &lt;&lt; 2 = \" &lt;&lt; std::bitset&lt;32&gt;(unit &lt;&lt; 2) &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"~(unit &lt;&lt; 2) = \" &lt;&lt; std::bitset&lt;32&gt;(~(unit &lt;&lt; 2)) &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"r &amp; (~(unit &lt;&lt; 2)) = \" &lt;&lt; std::bitset&lt;32&gt;(r &amp; (~(unit &lt;&lt; 2))) &lt;&lt; '\\n'\n     &lt;&lt; '\\n';\n\nstd::cout &lt;&lt; \"unit &lt;&lt; 3 = \" &lt;&lt; std::bitset&lt;32&gt;(unit &lt;&lt; 3) &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"~(unit &lt;&lt; 3) = \" &lt;&lt; std::bitset&lt;32&gt;(~(unit &lt;&lt; 3)) &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"r &amp; (~(unit &lt;&lt; 3)) = \" &lt;&lt; std::bitset&lt;32&gt;(r &amp; (~(unit &lt;&lt; 3))) &lt;&lt; '\\n'\n     &lt;&lt; '\\n';\n\nstd::cout &lt;&lt; \"unit &lt;&lt; 4 = \" &lt;&lt; std::bitset&lt;32&gt;(unit &lt;&lt; 4) &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"~(unit &lt;&lt; 4) = \" &lt;&lt; std::bitset&lt;32&gt;(~(unit &lt;&lt; 4)) &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"r &amp; (~(unit &lt;&lt; 4)) = \" &lt;&lt; std::bitset&lt;32&gt;(r &amp; (~(unit &lt;&lt; 4))) &lt;&lt; '\\n'\n     &lt;&lt; '\\n';\n\nstd::cout &lt;&lt; \"unit &lt;&lt; 5 = \" &lt;&lt; std::bitset&lt;32&gt;(unit &lt;&lt; 5) &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"~(unit &lt;&lt; 5) = \" &lt;&lt; std::bitset&lt;32&gt;(~(unit &lt;&lt; 5)) &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"r &amp; (~(unit &lt;&lt; 5)) = \" &lt;&lt; std::bitset&lt;32&gt;(r &amp; (~(unit &lt;&lt; 5))) &lt;&lt; '\\n'\n     &lt;&lt; '\\n';\n\nstd::cout &lt;&lt; \"unit &lt;&lt; 6 = \" &lt;&lt; std::bitset&lt;32&gt;(unit &lt;&lt; 6) &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"~(unit &lt;&lt; 6) = \" &lt;&lt; std::bitset&lt;32&gt;(~(unit &lt;&lt; 6)) &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"r &amp; (~(unit &lt;&lt; 6)) = \" &lt;&lt; std::bitset&lt;32&gt;(r &amp; (~(unit &lt;&lt; 6))) &lt;&lt; '\\n'\n     &lt;&lt; '\\n';\n\nstd::cout &lt;&lt; \"unit &lt;&lt; 7 = \" &lt;&lt; std::bitset&lt;32&gt;(unit &lt;&lt; 7) &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"~(unit &lt;&lt; 7) = \" &lt;&lt; std::bitset&lt;32&gt;(~(unit &lt;&lt; 7)) &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"r &amp; (~(unit &lt;&lt; 7)) = \" &lt;&lt; std::bitset&lt;32&gt;(r &amp; (~(unit &lt;&lt; 7))) &lt;&lt; '\\n'\n     &lt;&lt; '\\n';\n\nstd::cout &lt;&lt; \"unit &lt;&lt; 8 = \" &lt;&lt; std::bitset&lt;32&gt;(unit &lt;&lt; 8) &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"~(unit &lt;&lt; 8) = \" &lt;&lt; std::bitset&lt;32&gt;(~(unit &lt;&lt; 8)) &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"r &amp; (~(unit &lt;&lt; 8)) = \" &lt;&lt; std::bitset&lt;32&gt;(r &amp; (~(unit &lt;&lt; 8))) &lt;&lt; '\\n'\n     &lt;&lt; '\\n';\n</code></pre> Create bitset with 8 bits <pre><code>std::bitset&lt;8&gt; b(20);\n</code></pre> Convert bitset <pre><code>std::cout &lt;&lt; \"b: \" &lt;&lt; b &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"b: \" &lt;&lt; b.to_ulong() &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"b: \" &lt;&lt; b.to_string() &lt;&lt; '\\n';\nfor (size_t i = 0; i &lt; b.size(); ++i) {\n    std::cout &lt;&lt; \"b[i] : \" &lt;&lt; b[i] &lt;&lt; '\\n';\n}\n</code></pre> Create byte <pre><code>std::byte a{20};\nstd::cout &lt;&lt; \"a: \" &lt;&lt; std::to_integer&lt;int&gt;(a) &lt;&lt; '\\n';\n</code></pre> <p>  Share Snippets </p>"},{"location":"algorithms-data-structures/data-structures/build-script/","title":"Build script","text":"<pre><code># Data structures\nadd_executable(sequence_containers sequence_containers.cpp)\n\nadd_executable(associative_containers associative_containers.cpp)\n\nadd_executable(container_adapters container_adapters.cpp)\n\n#[pmr CMakeLists.txt\nfind_package(PMR)\nif (PMR_FOUND)\n    add_executable(memory_resource memory_resources.cpp)\nelse ()\n    message(\"Your compiler does not support *PMR* yet\")\nendif ()\n#]\n\n#[span CMakeLists.txt\nadd_executable(span span.cpp)\ntarget_compile_features(span PRIVATE cxx_std_20)\n#]\n\n#[bitset CMakeLists.txt\nadd_executable(bitset bitset.cpp)\n#]\n\n#[pareto CMakeLists.txt\n# Set options to not build pareto examples\n# - Cache our own BUILD_EXAMPLES var so that pareto\n#   doesn't mess with it\nset(BUILD_MATPLOT_TARGETS OFF CACHE BOOL \"\" FORCE)\nset(BUILD_EXAMPLES_PREV ${BUILD_EXAMPLES})\nset(BUILD_EXAMPLES OFF CACHE BOOL \"\" FORCE)\nFetchContent_Declare(pareto GIT_REPOSITORY https://github.com/alandefreitas/pareto.git GIT_TAG v1.2.0)\nFetchContent_MakeAvailable(pareto)\nset(BUILD_EXAMPLES ${BUILD_EXAMPLES_PREV} CACHE BOOL \"\" FORCE)\nadd_executable(spatial_containers spatial_containers.cpp)\ntarget_link_libraries(spatial_containers PUBLIC pareto)\n#]\n</code></pre>"},{"location":"algorithms-data-structures/data-structures/memory-resources/","title":"Memory resources","text":"<p>Memory resources</p> <p>The class std::pmr::memory_resource is an abstract interface to an unbounded set of classes encapsulating memory  resources. The class template std::pmr::polymorphic_allocator is an <code>Allocator</code> which exhibits different allocation behavior depending upon the std::pmr::memory_resource from  which it is constructed. This allows us to control how a given container allocates memory. </p> <p>Since memory_resource uses runtime polymorphism to manage allocations, different container instances  with polymorphic_allocator as their static allocator type are interoperable, but can behave as if they had  different allocator types.</p> <p>Not all compilers implement PMR yet, even though it's a C++17 feature. We need a CMake script such as  <code>FindPMR.cmake</code> to identify if your  compiler implements it. Another option is using <code>__has_include</code> to identify if the appropriate headers are available.</p> CMakeLists.txt <pre><code>find_package(PMR)\nif (PMR_FOUND)\n    add_executable(memory_resource memory_resources.cpp)\nelse ()\n    message(\"Your compiler does not support *PMR* yet\")\nendif ()\n</code></pre> Headers <pre><code>#include &lt;memory_resource&gt;\n</code></pre> Construct a buffer where to allocate memory <pre><code>char buffer[64] = {}; // a small buffer on the stack\nstd::fill_n(std::begin(buffer), std::size(buffer) - 1, '_');\nstd::cout &lt;&lt; buffer &lt;&lt; '\\n';\n</code></pre> Create a memory resource with the buffer <pre><code>std::pmr::monotonic_buffer_resource pool{std::data(buffer),\n                                         std::size(buffer)};\n</code></pre> Create a vector that allocates memory from the pool <pre><code>std::pmr::vector&lt;char&gt; vec{&amp;pool};\nfor (char ch = 'a'; ch &lt;= 'z'; ++ch) {\n    vec.push_back(ch);\n}\nstd::cout &lt;&lt; buffer &lt;&lt; '\\n';\n</code></pre> Create a pool for memory allocations and a vector using the pool <pre><code>std::pmr::unsynchronized_pool_resource pool2;\nstd::pmr::vector&lt;char&gt; vec2{&amp;pool2};\nfor (char ch = 'a'; ch &lt;= 'z'; ++ch) {\n    vec2.push_back(ch);\n}\n</code></pre> <p>  Share Snippets </p>"},{"location":"algorithms-data-structures/data-structures/sequence-containers/","title":"Sequence Containers","text":"<p>Sequence Containers</p> <p>Sequence containers implement data structures which can be accessed sequentially.</p> <ul> <li>array (C++11): static contiguous array</li> <li>vector: dynamic contiguous array</li> <li>deque: double-ended queue</li> <li>forward_list (C++11): singly-linked list</li> <li>list: doubly-linked list</li> </ul> Headers <pre><code>#include &lt;array&gt;\n#include &lt;deque&gt;\n#include &lt;list&gt;\n#include &lt;vector&gt;\n</code></pre> Construct sequence containers <pre><code>std::array&lt;int, 5&gt; a = {1, 2, 3, 4, 5}; // from values\nstd::vector&lt;int&gt; v(8, 9); // from size and value\nstd::deque&lt;int&gt; d(a.begin(), a.end()); // from iterators\nstd::list&lt;int&gt; l; // empty\n</code></pre> Container size <pre><code>std::cout &lt;&lt; \"a.size(): \" &lt;&lt; a.size() &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"v.size(): \" &lt;&lt; v.size() &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"d.size(): \" &lt;&lt; d.size() &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"l.size(): \" &lt;&lt; l.size() &lt;&lt; '\\n';\n</code></pre> Push back / Append <pre><code>// a.push_back(6); &lt;- not possible - array is fixed size\nv.push_back(6);\nd.push_back(6);\nl.push_back(6);\n</code></pre> Push front <pre><code>// a.push_front(6); &lt;- not possible - array is fixed size\nv.insert(v.begin(), 6); // &lt;- not possible in constant time\nd.push_front(6);\nl.push_front(6);\n</code></pre> Subscripts <pre><code>for (size_t i = 0; i &lt; a.size(); ++i) {\n    std::cout &lt;&lt; a[i] &lt;&lt; \" \";\n}\nstd::cout &lt;&lt; '\\n';\n\nfor (size_t i = 0; i &lt; v.size(); ++i) {\n    std::cout &lt;&lt; v[i] &lt;&lt; \" \";\n}\nstd::cout &lt;&lt; '\\n';\n\nfor (size_t i = 0; i &lt; d.size(); ++i) {\n    std::cout &lt;&lt; d[i] &lt;&lt; \" \";\n}\nstd::cout &lt;&lt; '\\n';\n\n// Impossible: list is not random access\n//    for (size_t i = 0; i &lt; l.size(); ++i) {\n//        std::cout &lt;&lt; l[i] &lt;&lt; \" \";\n//    }\n//    std::cout &lt;&lt; '\\n';\n</code></pre> Iterators <pre><code>for (auto it = a.begin(); it != a.end(); ++it) {\n    std::cout &lt;&lt; *it &lt;&lt; \" \";\n}\nstd::cout &lt;&lt; '\\n';\n\nfor (auto it = v.begin(); it != v.end(); ++it) {\n    std::cout &lt;&lt; *it &lt;&lt; \" \";\n}\nstd::cout &lt;&lt; '\\n';\n\nfor (auto it = d.begin(); it != d.end(); ++it) {\n    std::cout &lt;&lt; *it &lt;&lt; \" \";\n}\nstd::cout &lt;&lt; '\\n';\n\nfor (auto it = l.begin(); it != l.end(); ++it) {\n    std::cout &lt;&lt; *it &lt;&lt; \" \";\n}\nstd::cout &lt;&lt; '\\n';\n</code></pre> Range-based for loop <pre><code>for (int x: a) {\n    std::cout &lt;&lt; x &lt;&lt; \" \";\n}\nstd::cout &lt;&lt; '\\n';\n\nfor (int x: v) {\n    std::cout &lt;&lt; x &lt;&lt; \" \";\n}\nstd::cout &lt;&lt; '\\n';\n\nfor (int x: d) {\n    std::cout &lt;&lt; x &lt;&lt; \" \";\n}\nstd::cout &lt;&lt; '\\n';\n\nfor (int x: l) {\n    std::cout &lt;&lt; x &lt;&lt; \" \";\n}\nstd::cout &lt;&lt; '\\n';\n</code></pre> <p>  Share Snippets </p>"},{"location":"algorithms-data-structures/data-structures/span/","title":"Span","text":"<p>Span</p> <p>The class template <code>span</code> describes an object that can refer  to a contiguous sequence of objects with the first element of the sequence at position zero. </p> <p>A span can either have a static extent, in which case the number of elements in the sequence is known at  compile-time and encoded in the type, or a dynamic extent.</p> CMakeLists.txt <pre><code>add_executable(span span.cpp)\ntarget_compile_features(span PRIVATE cxx_std_20)\n</code></pre> Headers <pre><code>#include &lt;span&gt;\n</code></pre> Slide a span <pre><code>template&lt;class T, std::size_t N&gt;\n[[nodiscard]]\nconstexpr auto slide(std::span&lt;T, N&gt; s, std::size_t offset, std::size_t width) {\n    return s.subspan(offset, offset + width &lt;= s.size() ? width : 0U);\n}\n</code></pre> Check if span starts_with the specified prefix <pre><code>template&lt;class T, std::size_t N, std::size_t M&gt;\n[[nodiscard]]\nconstexpr bool starts_with(std::span&lt;T, N&gt; data, std::span&lt;T, M&gt; prefix) {\n    return data.size() &gt;= prefix.size()\n           &amp;&amp; std::equal(prefix.begin(), prefix.end(), data.begin());\n}\n</code></pre> Check if span ends_with the specified suffix <pre><code>template&lt;class T, std::size_t N, std::size_t M&gt;\n[[nodiscard]]\nconstexpr bool ends_with(std::span&lt;T, N&gt; data, std::span&lt;T, M&gt; suffix) {\n    return data.size() &gt;= suffix.size()\n           &amp;&amp; std::equal(data.end() - suffix.size(), data.end(),\n                         suffix.end() - suffix.size());\n}\n</code></pre> Check if span contains the specified element <pre><code>template&lt;class T, std::size_t N, std::size_t M&gt;\n[[nodiscard]]\nconstexpr bool contains(std::span&lt;T, N&gt; span, std::span&lt;T, M&gt; sub) {\n    return std::search(span.begin(), span.end(), sub.begin(), sub.end())\n           != span.end();\n}\n</code></pre> Construct two arrays <pre><code>constexpr int a[]{0, 1, 2, 3, 4, 5, 6, 7, 8};\nconstexpr int b[]{8, 7, 6};\n</code></pre> Slide spans <pre><code>for (std::size_t offset{};; ++offset) {\n    constexpr std::size_t width{6};\n    auto s = slide(std::span{a}, offset, width);\n    if (s.empty())\n        break;\n    print(s);\n}\n</code></pre> Check span properties at compile time <pre><code>static_assert(starts_with(std::span{a}, std::span{a, 4})\n              &amp;&amp; starts_with(std::span{a + 1, 4}, std::span{a + 1, 3})\n              &amp;&amp; !starts_with(std::span{a}, std::span{b})\n              &amp;&amp; !starts_with(std::span{a, 8}, std::span{a + 1, 3})\n              &amp;&amp; ends_with(std::span{a}, std::span{a + 6, 3})\n              &amp;&amp; !ends_with(std::span{a}, std::span{a + 6, 2})\n              &amp;&amp; contains(std::span{a}, std::span{a + 1, 4})\n              &amp;&amp; !contains(std::span{a, 8}, std::span{a, 9}));\n</code></pre> <p>  Share Snippets </p>"},{"location":"algorithms-data-structures/data-structures/spatial-containers/","title":"Spatial Containers","text":"<p>Spatial Containers</p> <p>Spatial container are an extension of sets and maps that allow us to order data according to multiple dimensions. This is particularly useful in games and graphical interfaces, where objects need to be mapped in space. The standard library does not include spatial containers so an external library needs to be used.</p> CMakeLists.txt <pre><code># Set options to not build pareto examples\n# - Cache our own BUILD_EXAMPLES var so that pareto\n#   doesn't mess with it\nset(BUILD_MATPLOT_TARGETS OFF CACHE BOOL \"\" FORCE)\nset(BUILD_EXAMPLES_PREV ${BUILD_EXAMPLES})\nset(BUILD_EXAMPLES OFF CACHE BOOL \"\" FORCE)\nFetchContent_Declare(pareto GIT_REPOSITORY https://github.com/alandefreitas/pareto.git GIT_TAG v1.2.0)\nFetchContent_MakeAvailable(pareto)\nset(BUILD_EXAMPLES ${BUILD_EXAMPLES_PREV} CACHE BOOL \"\" FORCE)\nadd_executable(spatial_containers spatial_containers.cpp)\ntarget_link_libraries(spatial_containers PUBLIC pareto)\n</code></pre> Headers <pre><code>#include &lt;pareto/spatial_map.h&gt;\n</code></pre> Construct map <pre><code>// Unlike a map&lt;map&lt;...&gt;&gt;, which represents a disjunction of indexes,\n// a spatial map represents a conjunction of indexes.\npareto::spatial_map&lt;double, 2, unsigned&gt; m;\n</code></pre> Inserting <pre><code>m(-2.5, -1.5) = 17;\nm(-2.1, -0.5) = 32;\nm(-1.6, 0.9) = 36;\nm(-0.6, 0.9) = 13;\nm(-0.5, 0.8) = 32;\n</code></pre> Querying nearest <pre><code>std::cout &lt;&lt; \"Closest elements to [0, 0]:\" &lt;&lt; std::endl;\nfor (auto it = m.find_nearest({0.,0.}, 2); it != m.end(); ++it) {\n    std::cout &lt;&lt; it-&gt;first &lt;&lt; \": \" &lt;&lt; it-&gt;second &lt;&lt; std::endl;\n}\n</code></pre> Querying intersection <pre><code>std::cout &lt;&lt; \"Elements between [-1, -1] and [+1, +1]:\" &lt;&lt; std::endl;\nfor (auto it = m.find_intersection({-1.,-1.}, {+1, +1}); it != m.end(); ++it) {\n    std::cout &lt;&lt; it-&gt;first &lt;&lt; \": \" &lt;&lt; it-&gt;second &lt;&lt; std::endl;\n}\n</code></pre> <p>  Share Snippets </p>"},{"location":"algorithms-data-structures/date-and-time/clock/","title":"Clock","text":"<p>Clock</p> <p>A clock consists of a starting point (or epoch) and a tick rate. For example, a clock may have an epoch of  January 1, 1970 and tick every second. C++ defines several clock types:</p> <ul> <li><code>system_clock</code> (C++11): wall clock time from the system-wide realtime clock</li> <li><code>steady_clock</code> (C++11): monotonic clock that will never be adjusted</li> <li><code>high_resolution_clock</code> (C++11): the clock with the shortest tick period available</li> <li><code>utc_clock</code> (C++20): Clock for Coordinated Universal Time (UTC)</li> <li><code>tai_clock</code> (C++20): Clock for International Atomic Time (TAI)</li> <li><code>gps_clock</code> (C++20): Clock for GPS time</li> <li><code>file_clock</code> (C++20): Clock used for file time</li> <li><code>local_t</code> (C++20): pseudo-clock representing local time</li> </ul> <p>C++ also inherits the C <code>clock</code> function, which returns the approximate processor time used by the process  since the beginning of an implementation-defined era related to the program's execution.  To convert result value to seconds divide it by CLOCKS_PER_SEC. The <code>clock</code> function:</p> <ul> <li>The only method specified in the standard to measure CPU time</li> <li>It's up to the user to keep track of the duration unit</li> <li>It doesn't work well with threads</li> <li>Ignores the time spent on <code>this_thread::sleep_for</code></li> </ul> std::clock function <pre><code>clock_t start, end;\ndouble cpu_time_used;\nstart = clock();\nvery_expensive_function();\nend = clock();\ncpu_time_used = static_cast&lt;float&gt;(end - start) / CLOCKS_PER_SEC;\nstd::cout &lt;&lt; \"cpu_time_used: \" &lt;&lt; cpu_time_used &lt;&lt; \" seconds\" &lt;&lt; '\\n';\n</code></pre> Modern C++ System Clock <pre><code>auto start2 = std::chrono::system_clock::now();\nvery_expensive_function();\nauto end2 = std::chrono::system_clock::now();\n</code></pre> Duration represented with the default duration type <pre><code>auto auto_duration = end2 - start2;\nstd::cout &lt;&lt; \"auto_duration.count() : \" &lt;&lt; auto_duration.count() &lt;&lt; \" ticks\"\n          &lt;&lt; '\\n'; // usually nanoseconds\n</code></pre> Duration represented with double, ratio in seconds <pre><code>std::chrono::duration&lt;double&gt; seconds_as_double = end2 - start2;\nstd::cout &lt;&lt; \"seconds_as_double.count() : \" &lt;&lt; seconds_as_double.count()\n          &lt;&lt; \" seconds\" &lt;&lt; '\\n';\n</code></pre> Duration represented with int, ratio in milliseconds <pre><code>std::chrono::duration&lt;int, std::milli&gt; milliseconds_as_int_;\n</code></pre> Cast duration (double, seconds) to duration (int, milliseconds) <pre><code>milliseconds_as_int_ =\n    std::chrono::duration_cast&lt;std::chrono::duration&lt;int, std::milli&gt;&gt;(\n        seconds_as_double);\nstd::cout &lt;&lt; \"milliseconds_as_int_.count() : \"\n          &lt;&lt; milliseconds_as_int_.count() &lt;&lt; \" milliseconds\" &lt;&lt; '\\n';\n</code></pre> Using ratio directly <pre><code>// Same as using hours\nconstexpr int seconds_per_hour = 60 * 60;\nstd::chrono::duration&lt;int, std::ratio&lt;seconds_per_hour&gt;&gt; hours_as_int;\nhours_as_int =\n    std::chrono::duration_cast&lt;std::chrono::duration&lt;int, std::ratio&lt;60 * 60&gt;&gt;&gt;(\n        seconds_as_double);\nstd::cout &lt;&lt; \"hours_as_int.count() : \" &lt;&lt; hours_as_int.count() &lt;&lt; \" hours\"\n          &lt;&lt; '\\n';\n</code></pre> Modern C++ Steady Clock <pre><code>auto start3 = std::chrono::steady_clock::now();\nvery_expensive_function();\nauto end3 = std::chrono::steady_clock::now();\n</code></pre> Duration represented with the default duration type <pre><code>auto d3 = end2 - start2;\nstd::cout &lt;&lt; \"auto_duration_3.count() : \" &lt;&lt; d3.count()\n          &lt;&lt; \" ticks\" &lt;&lt; '\\n'; // usually nanoseconds\n</code></pre> Time in seconds as double <pre><code>std::chrono::duration&lt;double&gt; seconds_as_double_3 = end3 - start3;\nstd::cout &lt;&lt; \"seconds_as_double_3.count() : \" &lt;&lt; seconds_as_double_3.count()\n          &lt;&lt; \" seconds\" &lt;&lt; '\\n';\n</code></pre> Time in milliseconds as int <pre><code>std::chrono::duration&lt;int, std::milli&gt; milliseconds_as_int_3;\nmilliseconds_as_int_3 =\n    std::chrono::duration_cast&lt;std::chrono::duration&lt;int, std::milli&gt;&gt;(\n        seconds_as_double_3);\nstd::cout &lt;&lt; \"milliseconds_as_int_3.count() : \"\n          &lt;&lt; milliseconds_as_int_3.count() &lt;&lt; \" milliseconds\" &lt;&lt; '\\n';\n</code></pre> Time in hours as int <pre><code>std::chrono::duration&lt;int, std::ratio&lt;seconds_per_hour&gt;&gt;\n    hours_as_int3; // same as using std::hours\nhours_as_int3 = std::chrono::duration_cast&lt;\n    std::chrono::duration&lt;int, std::ratio&lt;seconds_per_hour&gt;&gt;&gt;(\n    seconds_as_double_3);\nstd::cout &lt;&lt; \"hours_as_int3.count() : \" &lt;&lt; hours_as_int3.count() &lt;&lt; \" hours\"\n          &lt;&lt; '\\n';\n</code></pre> \"Parsing\" time <pre><code>// While std::std::chrono::parse is not available in all main compilers\nauto hours =\n    std::chrono::duration_cast&lt;std::chrono::hours&gt;(d3);\nif (hours.count() &gt; 0) {\n    std::cout &lt;&lt; hours.count() &lt;&lt; \" hours\";\n}\nd3 -= hours;\nauto seconds =\n    std::chrono::duration_cast&lt;std::chrono::seconds&gt;(d3);\nif (seconds.count() &gt; 0) {\n    std::cout &lt;&lt; seconds.count() &lt;&lt; \" seconds\";\n}\nd3 -= seconds;\nauto milliseconds =\n    std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(d3);\nif (milliseconds.count() &gt; 0) {\n    std::cout &lt;&lt; milliseconds.count() &lt;&lt; \" milliseconds\";\n}\nd3 -= milliseconds;\nauto nanoseconds =\n    std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(d3);\nif (nanoseconds.count() &gt; 0) {\n    std::cout &lt;&lt; nanoseconds.count() &lt;&lt; \" nanoseconds\";\n}\n</code></pre> <p>  Share Snippets </p>"},{"location":"algorithms-data-structures/date-and-time/datetime/","title":"Datetime","text":"<p>Datetime</p> <p>C++20 includes date and time utilities in the chrono library.</p> <p>These utilities were originally developed as the date library, and were finally merged to ISO C++ as of C++20. </p> <p>date.h contains chrono extensions to deal with dates: - https://howardhinnant.github.io/date/date.html - https://howardhinnant.github.io/date/tz.html</p> <p>The date library implementation is currently available on more compilers and platforms than the C++20 library.</p> Find datetime library <pre><code>find_package(Date QUIET)\nif (NOT Date_FOUND)\n    # Find Threads library\n    find_package(Threads)\n\n    # Find Curl (to download timezone database)\n    find_package(CURL QUIET)\n    if (NOT CURL_FOUND)\n        set(USE_SYSTEM_TZ_DB ON CACHE BOOL \"Build tz library\" FORCE)\n    else ()\n        set(USE_SYSTEM_TZ_DB OFF CACHE BOOL \"Build tz library\" FORCE)\n    endif ()\n    message(\"USE_SYSTEM_TZ_DB=${USE_SYSTEM_TZ_DB}\")\n    set(BUILD_TZ_LIB ON CACHE BOOL \"Build tz library\" FORCE)\n\n    # Fetch date library\n    FetchContent_Declare(date GIT_REPOSITORY https://github.com/HowardHinnant/date.git GIT_TAG v3.0.1)\n    FetchContent_MakeAvailable(date)\nendif ()\n\n# Link library\nadd_executable(datetime datetime.cpp)\ntarget_link_libraries(datetime date::date date::date-tz)\n</code></pre> Headers <pre><code>#include &lt;date/date.h&gt;\n#include &lt;date/tz.h&gt;\n</code></pre> Enable operator&lt;&lt; for time points <pre><code>    // Ensure operator&lt;&lt; it's not ambiguous with C++20 datetime\n#if !defined(__cpp_lib_chrono) || __cpp_lib_chrono &lt; 201907L\n    using date::operator&lt;&lt;;\n#endif\n</code></pre> Printing time points <pre><code>// - UTC time zone and microsecond precision\nconst std::chrono::time_point now = std::chrono::system_clock::now();\nstd::cout &lt;&lt; \"Now: \" &lt;&lt; now &lt;&lt; '\\n';\n</code></pre> Print formatted time points <pre><code>std::cout &lt;&lt; \"Formatted: \"\n          &lt;&lt; date::format(\"%a, %b %d, %Y at %I:%M %p %Z\", now) &lt;&lt; '\\n';\n</code></pre> Print formatted time points in time zone <pre><code>{\n    using date::operator&lt;&lt;;\n    std::cout &lt;&lt; date::format(std::locale(\"de_DE\"),\n                              \"%a, %b %d, %Y at %T %Z\", now)\n              &lt;&lt; '\\n';\n}\n</code></pre> Print Epoch <pre><code>std::cout &lt;&lt; \"Epoch: \"\n          &lt;&lt; std::chrono::time_point&lt;std::chrono::system_clock&gt;(\n                 std::chrono::seconds(0))\n          &lt;&lt; '\\n';\n</code></pre> Days since 1970 represented as a single integer <pre><code>// - This is a serial-based time-point\n// - Good for day oriented arithmetic\ndate::sys_days today = date::floor&lt;date::days&gt;(now);\nstd::cout &lt;&lt; \"today: \" &lt;&lt; today.time_since_epoch().count()\n          &lt;&lt; \" days since epoch\" &lt;&lt; '\\n';\n</code></pre> Days since 1970 represented as 3 integers: year / month / day <pre><code>// - This is a field-based time-point\n// - Good for returning field values\n// - Good for month/year arithmetic\n// Last day of March / 2015\nusing namespace date::literals;\ndate::year_month_day t_ymd = 2015_y / date::March / 22;\nstd::cout &lt;&lt; \"t_ymd: \" &lt;&lt; t_ymd &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"t_ymd since epoch: \"\n          &lt;&lt; date::sys_days(t_ymd).time_since_epoch().count() &lt;&lt; '\\n';\n</code></pre> Days since 1970 represented as 4 integers: year / month / week / <pre><code>// weekday\n// This is a field-based time-point\ndate::year_month_weekday t_ymw =\n    date::year{2015} / date::month{3} / date::Monday[2];\nstd::cout &lt;&lt; \"t_ymw: \" &lt;&lt; t_ymw &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"t_ymw since epoch: \"\n          &lt;&lt; date::sys_days(t_ymw).time_since_epoch().count() &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"year_month_day(t3): \"\n          &lt;&lt; date::sys_days(date::year_month_day(t_ymw))\n                 .time_since_epoch()\n                 .count()\n          &lt;&lt; '\\n';\n</code></pre> Converting to/from year/month/date <pre><code>auto today_ymd = date::year_month_day{today};\nstd::cout &lt;&lt; \"Today is \" &lt;&lt; today_ymd &lt;&lt; '\\n';\n</code></pre> Durations <pre><code>// - Time since midnight (serial-based)\nauto time_since_midnight = now - today;\nstd::cout &lt;&lt; \"Serial time since midnight \"\n          &lt;&lt; duration_cast&lt;std::chrono::seconds&gt;(time_since_midnight)\n          &lt;&lt; '\\n';\n</code></pre> Time since midnight (field-based) <pre><code>date::hh_mm_ss time_since_midnight_hms(time_since_midnight);\nstd::cout &lt;&lt; \"Field-based time since midnight: \" &lt;&lt; today_ymd &lt;&lt; \" - \"\n          &lt;&lt; time_since_midnight_hms &lt;&lt; '\\n';\n</code></pre> Time since midnight (field-based) <pre><code>auto time_since_midnight_tod = date::make_time(time_since_midnight);\nstd::cout &lt;&lt; \"Field-based time since midnight: \" &lt;&lt; today_ymd &lt;&lt; \" - \"\n          &lt;&lt; time_since_midnight_tod &lt;&lt; '\\n';\n</code></pre> Checking invalid field based dates <pre><code>// They are possible, and they might be even useful\nstd::cout &lt;&lt; \"All odd fridays this year: \";\ndate::year this_year = today_ymd.year();\nfor (auto m = 1; m &lt;= 12; ++m) {\n    auto first_friday =\n        date::year_month_day(this_year / m / date::Friday[1]);\n    std::cout &lt;&lt; first_friday &lt;&lt; ' ';\n    auto third_friday = first_friday.year() / first_friday.month() /\n                        (first_friday.day() + date::weeks{2});\n    std::cout &lt;&lt; third_friday &lt;&lt; ' ';\n    auto fifth_friday = third_friday.year() / third_friday.month() /\n                        (third_friday.day() + date::weeks{2});\n    if (fifth_friday.ok()) {\n        std::cout &lt;&lt; fifth_friday &lt;&lt; ' ';\n    }\n}\nstd::cout &lt;&lt; '\\n';\n</code></pre> Dealing with time zones <pre><code>// Zoned time is a wrapper that also keeps track of the shift from UTC\ndate::zoned_time local_tp = date::make_zoned(date::current_zone(), now);\n</code></pre> Zone pointers <pre><code>// Little more efficient. Less convenient unless reusing the zone ptr.\nauto berlin_zone = date::locate_zone(\"Europe/Berlin\");\nauto berlin_time = date::make_zoned(\n    berlin_zone,\n    floor&lt;std::chrono::seconds&gt;(std::chrono::system_clock::now()));\nstd::cout &lt;&lt; \"berlin time: \"\n          &lt;&lt; date::format(std::locale(\"de_DE\"), \"%a, %b %d, %Y at %T %Z\",\n                          berlin_time)\n          &lt;&lt; '\\n';\n</code></pre> Make zoned time <pre><code>// Little less efficient. More convenient.\nauto sp_time = date::make_zoned(\n    \"America/Sao_Paulo\",\n    floor&lt;std::chrono::seconds&gt;(std::chrono::system_clock::now()));\nstd::cout &lt;&lt; \"sao paulo time: \"\n          &lt;&lt; date::format(std::locale(\"de_DE\"), \"%a, %b %d, %Y at %T %Z\",\n                          sp_time)\n          &lt;&lt; '\\n';\n</code></pre> Time zone details <pre><code>std::cout &lt;&lt; \"local_tp: \" &lt;&lt; local_tp &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"abbrev: \" &lt;&lt; local_tp.get_info().abbrev &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"Sys time: \" &lt;&lt; local_tp.get_sys_time() &lt;&lt; '\\n';\n</code></pre> Convert zoned time point <pre><code>std::cout &lt;&lt; \"offset: \" &lt;&lt; local_tp.get_info().offset &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"save: \" &lt;&lt; local_tp.get_info().save &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"Local time: \" &lt;&lt; local_tp.get_local_time() &lt;&lt; '\\n';\n</code></pre> Format zoned time point <pre><code>std::cout &lt;&lt; \"Formatted: \"\n          &lt;&lt; date::format(\"%a, %b %d, %Y at %I:%M %p %Z\", local_tp)\n          &lt;&lt; '\\n';\nstd::cout &lt;&lt; date::format(std::locale(\"de_DE\"),\n                          \"%a, %b %d, %Y at %T %Z\", local_tp)\n          &lt;&lt; '\\n';\n</code></pre> Change precision <pre><code>auto now_nanoseconds = date::floor&lt;std::chrono::nanoseconds&gt;(now);\nauto local_tp_nanoseconds =\n    date::make_zoned(date::current_zone(), now_nanoseconds);\nstd::cout &lt;&lt; \"In millisecs: \" &lt;&lt; local_tp_nanoseconds &lt;&lt; '\\n';\n</code></pre> Change precision to milliseconds <pre><code>auto now_milliseconds = date::floor&lt;std::chrono::milliseconds&gt;(now);\nauto local_tp_milliseconds =\n    date::make_zoned(date::current_zone(), now_milliseconds);\nstd::cout &lt;&lt; \"In millisecs: \" &lt;&lt; local_tp_milliseconds &lt;&lt; '\\n';\n</code></pre> Change precision to milliseconds <pre><code>auto now_milliseconds = date::floor&lt;std::chrono::milliseconds&gt;(now);\nauto local_tp_milliseconds =\n    date::make_zoned(date::current_zone(), now_milliseconds);\nstd::cout &lt;&lt; \"In millisecs: \" &lt;&lt; local_tp_milliseconds &lt;&lt; '\\n';\n</code></pre> Change precision to milliseconds <pre><code>auto now_milliseconds = date::floor&lt;std::chrono::milliseconds&gt;(now);\nauto local_tp_milliseconds =\n    date::make_zoned(date::current_zone(), now_milliseconds);\nstd::cout &lt;&lt; \"In millisecs: \" &lt;&lt; local_tp_milliseconds &lt;&lt; '\\n';\n</code></pre> Change precision to milliseconds <pre><code>auto now_milliseconds = date::floor&lt;std::chrono::milliseconds&gt;(now);\nauto local_tp_milliseconds =\n    date::make_zoned(date::current_zone(), now_milliseconds);\nstd::cout &lt;&lt; \"In millisecs: \" &lt;&lt; local_tp_milliseconds &lt;&lt; '\\n';\n</code></pre> Convert time between zones <pre><code>auto tokyo_tp = date::make_zoned(\"Asia/Tokyo\", sp_time);\nstd::cout &lt;&lt; sp_time &lt;&lt; \" in sao paulo is \" &lt;&lt; tokyo_tp &lt;&lt; \" in tokyo\"\n          &lt;&lt; '\\n';\n</code></pre> <p>  Share Snippets </p>"},{"location":"algorithms-data-structures/heterogeneous-types/any/","title":"Any","text":"<p>Any</p> <p>The class <code>std::any</code> describes a type-safe container for single values of any copy constructible type.</p> <p>1) An object of class <code>any</code> stores an instance of any type that satisfies the constructor requirements or is empty,     and this is referred to as the state of the class any object. The stored instance is called the contained object.     Two states are equivalent if they are either both empty or if both are not empty and if the contained objects     are equivalent. 2) The non-member any_cast functions provide type-safe access to the contained object. Implementations are      encouraged to avoid dynamic allocations for small objects, but such an optimization may only be applied to      types for which <code>std::is_nothrow_move_constructible</code> returns <code>true</code>.</p> <code>std::any</code> is a container for single values of any type <pre><code>// Be careful when using it\nstd::any a = 1;\n</code></pre> Accessing values (int) <pre><code>std::cout &lt;&lt; a.type().name() &lt;&lt; \": \" &lt;&lt; std::any_cast&lt;int&gt;(a) &lt;&lt; '\\n';\n</code></pre> Accessing values (double) <pre><code>a = 3.14;\nstd::cout &lt;&lt; a.type().name() &lt;&lt; \": \" &lt;&lt; std::any_cast&lt;double&gt;(a) &lt;&lt; '\\n';\n</code></pre> Accessing values (bool) <pre><code>a = true;\nstd::cout &lt;&lt; a.type().name() &lt;&lt; \": \" &lt;&lt; std::any_cast&lt;bool&gt;(a) &lt;&lt; '\\n';\n</code></pre> Accessing values (string) <pre><code>a = std::string(\"Any string\");\nstd::cout &lt;&lt; a.type().name() &lt;&lt; \": \" &lt;&lt; std::any_cast&lt;std::string&gt;(a) &lt;&lt; '\\n';\n</code></pre> Attempting to access values <pre><code>try {\n    std::any v = 1;\n    std::cout &lt;&lt; std::any_cast&lt;float&gt;(v) &lt;&lt; '\\n';\n} catch (std::bad_any_cast &amp;e) {\n    std::cout &lt;&lt; e.what() &lt;&lt; '\\n';\n}\n</code></pre> Checking if variable is empty <pre><code>std::any s2 = 1;\nif (!s2.has_value()) {\n    const std::type_info &amp;ti = s2.type();\n    std::cout &lt;&lt; ti.name() &lt;&lt; '\\n';\n}\n</code></pre> Access pointer to value <pre><code>std::any a3 = 1;\nint *i = std::any_cast&lt;int&gt;(&amp;a3);\nstd::cout &lt;&lt; *i &lt;&lt; '\\n';\n</code></pre> <p>  Share Snippets </p>"},{"location":"algorithms-data-structures/heterogeneous-types/optional/","title":"Optional","text":"<p>Optional</p> <p>The class template <code>std::optional</code> manages an optional  contained value, i.e. a value that may or may not be present.</p> <p>A common use case for optional is the return value of a function that may fail. As opposed to other approaches,  such as std::pair, optional handles expensive-to-construct objects well and is more readable, as the intent is expressed explicitly. <p>Any instance of <code>optional&lt;T&gt;</code> at any given point in time either contains a value or does not contain a value.</p> Function that returns a value only if it's even <pre><code>std::optional&lt;int&gt; get_even_random_number() {\n    int i = std::rand();\n    if (i % 2 == 0) {\n        return i;\n    } else {\n        return std::nullopt;\n    }\n}\n</code></pre> Function that always returns a non-empty optional value <pre><code>std::optional&lt;int&gt; get_even_random_number2() {\n    int i = std::rand();\n    return std::make_optional(int(i % 2 == 0));\n}\n</code></pre> Call function that returns optional value <pre><code>std::optional&lt;int&gt; i = get_even_random_number();\nif (i) {\n    std::cout &lt;&lt; std::sqrt(static_cast&lt;float&gt;(*i)) &lt;&lt; '\\n';\n} else {\n    std::cout &lt;&lt; \"No value was returned\" &lt;&lt; '\\n';\n}\n</code></pre> Call function that returns non-empty optional value <pre><code>i = get_even_random_number2();\ndouble d = i.value_or(0);\nstd::cout &lt;&lt; std::sqrt(d) &lt;&lt; '\\n';\nstd::cout &lt;&lt; i.value_or(0) &lt;&lt; std::endl;\n</code></pre> <p>  Share Snippets </p>"},{"location":"algorithms-data-structures/heterogeneous-types/tuples/","title":"Tuples","text":"<p>Tuples</p> <p>Class template <code>std::tuple</code> is a fixed-size collection of  heterogeneous values. It is a generalization of std::pair for more than 2 values.</p> Headers <pre><code>#include &lt;tuple&gt;\n</code></pre> Returning values by reference <pre><code>void reference_minmax(int a, int b, int &amp;min, int &amp;max) {\n    if (a &lt; b) {\n        min = a;\n        max = b;\n    } else {\n        min = b;\n        max = a;\n    }\n}\n</code></pre> Returning values with std::tuple <pre><code>std::tuple&lt;int, int&gt; tuple_minmax(int a, int b) {\n    if (a &lt; b) {\n        return std::make_tuple(a, b);\n    } else {\n        return std::make_tuple(b, a);\n    }\n}\n</code></pre> Call function \"returning\" by reference <pre><code>int min;\nint max;\nreference_minmax(3, 2, min, max);\nstd::cout &lt;&lt; \"min : \" &lt;&lt; min &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"max : \" &lt;&lt; max &lt;&lt; '\\n';\n</code></pre> Call function returning a tuple <pre><code>auto t4 = tuple_minmax(3, 2);\nstd::cout &lt;&lt; \"min : \" &lt;&lt; std::get&lt;0&gt;(t4) &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"max : \" &lt;&lt; std::get&lt;1&gt;(t4) &lt;&lt; '\\n';\n</code></pre> Custom pair structure for results <pre><code>struct my_pair {\n    char first;\n    int second;\n};\n// ...\nmy_pair s{'c', 15};\nstd::cout &lt;&lt; \"s.first: \" &lt;&lt; s.first &lt;&lt; \", s.second: \" &lt;&lt; s.second &lt;&lt; '\\n';\n</code></pre> std::pair for results <pre><code>std::pair&lt;char, int&gt; p{'c', 15};\nstd::cout &lt;&lt; \"p.first: \" &lt;&lt; p.first &lt;&lt; \", p.second: \" &lt;&lt; p.second &lt;&lt; '\\n';\n</code></pre> std::tuple for results <pre><code>std::pair&lt;char, int&gt; t('c', 15);\nstd::cout &lt;&lt; \"t.first: \" &lt;&lt; t.first &lt;&lt; \", t.second: \" &lt;&lt; t.second &lt;&lt; '\\n';\n</code></pre> Using type deduction <pre><code>auto t2 = std::make_pair&lt;char, int&gt;('c', 15);\nstd::cout &lt;&lt; \"t2.first: \" &lt;&lt; t2.first &lt;&lt; \", t2.second: \" &lt;&lt; t2.second\n          &lt;&lt; '\\n';\n</code></pre> Larger tuples <pre><code>auto t3 = std::make_tuple(6.3, \"text\", 2, 'o');\nchar x = std::get&lt;3&gt;(t3);\nstd::cout &lt;&lt; \"x: \" &lt;&lt; x &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"std::get&lt;0&gt;(t3): \" &lt;&lt; std::get&lt;0&gt;(t3)\n          &lt;&lt; \", std::get&lt;1&gt;(t3): \" &lt;&lt; std::get&lt;1&gt;(t3) &lt;&lt; '\\n';\n</code></pre> std::tie <pre><code>int a;\nchar b;\nstd::tie(std::ignore, std::ignore, a, b) = t3;\nstd::cout &lt;&lt; \"a: \" &lt;&lt; a &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"b: \" &lt;&lt; b &lt;&lt; '\\n';\n</code></pre> Unpacking a tuple <pre><code>int min2;\nint max2;\nstd::tie(min2, max2) = tuple_minmax(3, 2);\nstd::cout &lt;&lt; \"min : \" &lt;&lt; min2 &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"max : \" &lt;&lt; max2 &lt;&lt; '\\n';\n</code></pre> Structured binding <pre><code>auto [min3, max3] = tuple_minmax(3, 2);\nstd::cout &lt;&lt; \"min : \" &lt;&lt; min3 &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"max : \" &lt;&lt; max3 &lt;&lt; '\\n';\n</code></pre> <p>  Share Snippets </p>"},{"location":"algorithms-data-structures/heterogeneous-types/variant/","title":"Variant","text":"<p>Variant</p> <p>The class template <code>std::variant</code> (C++17) represents a  type-safe union. An instance of <code>std::variant</code> at any given time either holds a value of one of its alternative  types, or in the case of error - no value.</p> <p>If we define a variant <code>v</code> including lots of types, including booleans and lists, this would be somewhat similar to:</p> <ul> <li>PHP:         <code>$v = 3.14;</code>    // see https://bit.ly/3cVuJvb</li> <li>Python:      <code>v = 3.14;</code></li> <li>Javascript:  <code>var v = 3.14;</code></li> </ul> <p>As with unions, if a variant holds a value of some object type <code>T</code>, the object representation of <code>T</code> is allocated  directly within the object representation of the variant itself. Variant is not allowed to allocate additional (dynamic) memory.</p> <p>A variant is not permitted to hold references, arrays, or the type <code>void</code>. Empty variants are also ill-formed  (std::variant can be used instead). <p>A variant is permitted to hold the same type more than once, and to hold differently cv-qualified versions of the same type.</p> <p>Consistent with the behavior of unions during aggregate initialization, a default-constructed variant holds a value of its first alternative, unless that alternative is not default-constructible (in which case the variant is not default-constructible either). The helper class <code>std::monostate</code> can be used  to make such variants default-constructible.</p> Declare an C union <pre><code>union my_union {\n    double a;\n    char b;\n    int c;\n};\n</code></pre> Using unions <pre><code>// - It only works with fundamental data type\n// - It doesn't have convenience functions\nmy_union u = {3.14};\nu = {'A'};\nu = {15};\n</code></pre> Union size <pre><code>// A union is as large as the largest type in the union\nstd::cout &lt;&lt; \"sizeof(double): \" &lt;&lt; sizeof(double) &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"sizeof(char): \" &lt;&lt; sizeof(char) &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"sizeof(int): \" &lt;&lt; sizeof(int) &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"sizeof(my_union): \" &lt;&lt; sizeof(my_union) &lt;&lt; '\\n';\n</code></pre> Declaring a variant type <pre><code>std::variant&lt;double, char, std::string&gt; v;\n</code></pre> Setting variant values <pre><code>v = 3.14;               // becomes double\nv = 'A';                // becomes char\nv = \"Some longer text\"; // becomes std::string\n</code></pre> Variant size <pre><code>// A variant is larger than the largest type in the variant\n// This happens because variants need a flag to indicate the current type\nstd::cout &lt;&lt; \"sizeof(double): \" &lt;&lt; sizeof(double) &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"sizeof(char): \" &lt;&lt; sizeof(char) &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"sizeof(string): \" &lt;&lt; sizeof(std::string) &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"sizeof(variant&lt;double, char, std::string&gt;): \"\n          &lt;&lt; sizeof(std::variant&lt;double, char, std::string&gt;) &lt;&lt; '\\n';\n</code></pre> Accessing values <pre><code>v = 3.14;\nstd::cout &lt;&lt; get&lt;double&gt;(v) &lt;&lt; '\\n';\nv = 'A';\nstd::cout &lt;&lt; get&lt;char&gt;(v) &lt;&lt; '\\n';\nv = \"Some longer text\";\nstd::cout &lt;&lt; get&lt;std::string&gt;(v) &lt;&lt; '\\n';\n</code></pre> Visiting variant <pre><code>// Applying function to whatever value type it holds\nstd::visit([](auto x) { std::cout &lt;&lt; x &lt;&lt; '\\n'; }, v);\n</code></pre> Checking current alternative index <pre><code>switch (v.index()) {\ncase 0:\n    std::cout &lt;&lt; \"This is a double\\n\";\n    break;\ncase 1:\n    std::cout &lt;&lt; \"This is a char\\n\";\n    break;\ncase 2:\n    std::cout &lt;&lt; \"This is a string\\n\";\n    break;\n}\n</code></pre> Checking current alternative type <pre><code>if (std::holds_alternative&lt;double&gt;(v)) {\n    std::cout &lt;&lt; \"This is a double\\n\";\n} else if (std::holds_alternative&lt;char&gt;(v)) {\n    std::cout &lt;&lt; \"This is a char\\n\";\n} else if (std::holds_alternative&lt;std::string&gt;(v)) {\n    std::cout &lt;&lt; \"This is a string\\n\";\n}\n</code></pre> <p>  Share Snippets </p>"},{"location":"algorithms-data-structures/random/pcg/","title":"PCG","text":"<p>PCG</p> <p>The PCG library provides a number of better random number generators.</p> <p>The library has a interface that resembles standard C++ number generators with generators that:</p> <ul> <li>Do not fail statistical tests for randomness </li> <li>Ensure unpredictability and safety </li> <li>Are fast and don't require large amounts of memory </li> <li>Provide useful features such as \"jump ahead\" </li> </ul> Find PCG <pre><code>find_package(pcg-cpp QUIET)\nif (NOT pcg-cpp_FOUND)\n    FetchContent_Declare(pcg-cpp GIT_REPOSITORY https://github.com/imneme/pcg-cpp.git GIT_TAG v0.98.1)\n    FetchContent_GetProperties(pcg-cpp)\n    if (NOT pcg-cpp_POPULATED)\n        FetchContent_Populate(pcg-cpp)\n        # Create header-only library with pcg-cpp include files\n        add_library(pcg-cpp INTERFACE)\n        target_include_directories(pcg-cpp INTERFACE ${pcg-cpp_SOURCE_DIR}/include)\n    endif ()\nendif()\nadd_executable(pcg pcg.cpp)\ntarget_link_libraries(pcg pcg-cpp)\n</code></pre> Initialize generator with two fixed seeds <pre><code>pcg32 rng(42u, 54u);\n</code></pre> Seed generator with external entropy <pre><code>rng.seed(pcg_extras::seed_seq_from&lt;std::random_device&gt;());\n</code></pre> Random numbers <pre><code>std::cout &lt;&lt; \"Random number: \" &lt;&lt; rng() &lt;&lt; '\\n';\n</code></pre> Flip coins <pre><code>std::cout &lt;&lt; \"Flip coin: \" &lt;&lt; rng(2) &lt;&lt; '\\n';\n</code></pre> Roll dice <pre><code>std::cout &lt;&lt; \"Roll dice: \" &lt;&lt; rng(6) &lt;&lt; '\\n';\n</code></pre> Print generator state <pre><code>std::cout &lt;&lt; \"Generator state: \" &lt;&lt; rng &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"Result size: \" &lt;&lt; sizeof(pcg32::result_type) * 8 &lt;&lt; \"bits\" &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"Period: 2^\" &lt;&lt; pcg32::period_pow2() &lt;&lt; '\\n';\n</code></pre> Use with C++ distributions <pre><code>std::uniform_real_distribution&lt;double&gt; distribution(1.0, 10.0);\nstd::cout &lt;&lt; distribution(rng) &lt;&lt; '\\n';\n</code></pre> <p>  Share Snippets </p>"},{"location":"algorithms-data-structures/random/random/","title":"Random","text":"<p>Random</p> <p>The random number library provides classes that generate random and pseudo-random numbers. These classes include:</p> <ul> <li>Uniform random bit generators (URBGs), which include both random number engines, which are pseudo-random number   generators that generate integer sequences with a uniform distribution, and true random number generators if    available;</li> <li>Random number distributions (e.g. uniform, normal, or poisson distributions) which convert the output of URBGs    into various statistical distributions</li> </ul> <p>URBGs and distributions are designed to be used together to produce random values. All of the random number engines  may be specifically seeded, serialized, and deserialized for use with repeatable simulators.</p> Headers <pre><code>#include &lt;random&gt;\n</code></pre> Operating system number generator <pre><code>// Usually a high-cost generator\nstd::random_device rd;\n</code></pre> Generate seed for a low-cost generator <pre><code>unsigned int seed = rd();\n</code></pre> Mix the seed with other sources of entropy <pre><code>// We recur to a user-defined function to mix other sources\n// of entropy in the seed\nseed = mix_seed(seed);\n</code></pre> Use seed for a lower-cost number generator <pre><code>// This is the generator we will ultimately use\nstd::default_random_engine g(seed);\n</code></pre> Create a number distribution (cheap) <pre><code>std::uniform_real_distribution&lt;double&gt; distribution(1.0, 10.0);\n</code></pre> Using the generator with that distribution <pre><code>std::cout &lt;&lt; distribution(g) &lt;&lt; '\\n';\n</code></pre> Explicitly create a mt19937 generator <pre><code>std::mt19937 g2{seed};\n</code></pre> Creating a normal distribution (cheap) <pre><code>std::normal_distribution&lt;double&gt; d2(0.0, 1.0);\n</code></pre> Using the generator with that distribution <pre><code>std::cout &lt;&lt; d2(g2) &lt;&lt; '\\n';\n</code></pre> Generate a histogram from the generator <pre><code>std::vector&lt;int&gt; hist(10, 0);\nfor (int i = 0; i &lt; 300; ++i) {\n    auto bin = d2(g2) + static_cast&lt;double&gt;(hist.size()) / 2;\n    if (bin &gt;= 0. &amp;&amp; static_cast&lt;size_t&gt;(bin) &lt; hist.size()) {\n        ++hist[static_cast&lt;size_t&gt;(bin)];\n    }\n}\n</code></pre> Print the histogram <pre><code>for (int n : hist) {\n    std::cout &lt;&lt; '-';\n    for (int j = 0; j &lt; n; ++j) {\n        std::cout &lt;&lt; '*';\n    }\n    std::cout &lt;&lt; '\\n';\n}\n</code></pre> User-defined function to mix the seed <pre><code>constexpr uint32_t fnv(uint32_t hash, const char *pos) {\n    return *pos == '\\0' ? hash : fnv((hash * 16777619U) ^ *pos, pos + 1);\n}\n\nunsigned int mix_seed(unsigned int seed) {\n    // Mix seed with some cross-platform entropy sources\n    // - Mix the current time\n    seed ^= static_cast&lt;unsigned int&gt;(\n        std::chrono::system_clock::now().time_since_epoch().count());\n\n    // - Mix an arbitrary compile-time stamp\n    constexpr uint32_t compile_stamp =\n        fnv(2166136261U, __DATE__ __TIME__ __FILE__);\n    seed ^= static_cast&lt;unsigned int&gt;(compile_stamp);\n\n    // - Mix an arbitrary heap address\n    auto heap_addr = std::make_unique&lt;int&gt;(0);\n    seed ^=\n        static_cast&lt;unsigned int&gt;(reinterpret_cast&lt;uintptr_t&gt;(heap_addr.get()));\n\n    // - Mix an arbitrary stack address\n    seed ^= static_cast&lt;unsigned int&gt;(reinterpret_cast&lt;uintptr_t&gt;(&amp;heap_addr));\n\n    // - Mix an arbitrary fixed number / counter\n    seed ^= static_cast&lt;unsigned int&gt;(45);\n\n    // - Mix an arbitrary function address (the clock function `now`)\n    seed ^= static_cast&lt;unsigned int&gt;(\n        reinterpret_cast&lt;uintptr_t&gt;(&amp;std::chrono::system_clock::now));\n\n    // - Mix the exit function address\n    seed ^=\n        static_cast&lt;unsigned int&gt;(reinterpret_cast&lt;uintptr_t&gt;((void *)&amp;_Exit));\n\n    // - Mix the random_device generator type hash code\n    seed ^= static_cast&lt;unsigned int&gt;(typeid(std::random_device).hash_code());\n\n    return seed;\n}\n</code></pre> <p>  Share Snippets </p>"},{"location":"algorithms-data-structures/templates/concepts/","title":"Concepts","text":"<p>Concepts</p> <p>Concepts (C++20) define named sets of template requirements. </p> <p>Class templates, function templates, and non-template functions (typically members of class templates) may be  associated with a template constraint, which specifies the requirements on template arguments, which can be used  to select the most appropriate function overloads and template specializations. </p> <p>Each concept is a predicate, evaluated at compile time, and becomes a part of the interface of a template where  it is used as a constraint:</p> Find concepts <pre><code>add_executable(concepts concepts.cpp)\ntarget_compile_features(concepts PRIVATE cxx_std_20)\n</code></pre> Headers <pre><code>#include &lt;concepts&gt;\n</code></pre> Define concept from a compile-time boolean predicate <pre><code>template &lt;typename T&gt; concept Number = std::is_arithmetic_v&lt;T&gt;;\n\n// is_arithmetic_v might be misleading since it also includes bool\n// is_arithmetic_v might be misleading since it doesn't include std::complex\n</code></pre> Define concept from a another concepts as a boolean predicate <pre><code>template&lt;typename T&gt; concept NotNumber = !Number&lt;T&gt;;\n</code></pre> Define concept from a conjunction of constraints <pre><code>template&lt;typename T&gt; concept SignedNumber = Number&lt;T&gt; &amp;&amp; std::is_signed_v&lt;T&gt;;\n</code></pre> Define alternative mutually exclusive Number concept <pre><code>template&lt;typename T&gt;\nconcept UnsignedNumber = Number&lt;T&gt; &amp;&amp; !std::is_signed_v&lt;T&gt;;\n</code></pre> Define concept from disjunction of constraints <pre><code>template&lt;typename T1, typename T2&gt;\nconcept Equivalent = std::is_convertible_v&lt;T1, T2&gt; || std::is_same_v&lt;T1, T2&gt;;\n</code></pre> Define concept from requires-expression <pre><code>// These expressions must be something that will compile\ntemplate&lt;typename T&gt; concept Range = requires(T r) {\n    *r.begin();\n    *r.end();\n};\n</code></pre> Define concept from typename requirement <pre><code>// These expressions must something that will compile\ntemplate&lt;typename T&gt; concept HasValueType = requires(T r) {\n    typename T::value_type; // required nested name\n};\n</code></pre> Compound requirement <pre><code>// Two requirements at the same time\ntemplate&lt;typename T&gt; concept Pair = requires(T p) {\n    { p.first };\n    { p.second };\n};\n</code></pre> Typename requirement from expression type constraint <pre><code>// The expression should not only compile, but it should also have\n// a type that passes the concept after -&gt;\ntemplate&lt;typename T&gt; concept IntPair = requires(T p) {\n    { p.first } -&gt; std::same_as&lt;int&gt;;\n    { p.second } -&gt; std::same_as&lt;int&gt;;\n};\n</code></pre> Requirement with two parameters <pre><code>template&lt;typename T&gt;\nconcept EqualityComparable = requires(T a, T b) {\n    { a == b };\n    { a != b };\n};\n</code></pre> Nested requirements <pre><code>// Additional constraint to existing constraints\n// Functions can use Range or RangeSameType now without ambiguity\ntemplate&lt;typename T&gt; concept PairSameType = Pair&lt;T&gt; &amp;&amp; requires(T p) {\n    { p.first } -&gt; std::same_as&lt;decltype(p.second)&gt;;\n};\n</code></pre> Nested requirements without requires <pre><code>template&lt;typename T&gt; concept RangeWithValueType = Range&lt;T&gt; &amp;&amp; HasValueType&lt;T&gt;;\ntemplate&lt;typename T&gt; concept RangeWithoutValueType = Range&lt;T&gt; &amp;&amp; !HasValueType&lt;T&gt;;\n</code></pre> Constrain function to numbers <pre><code>// Number, but nor SignedNumber neither UnsignedNumber\ntemplate&lt;Number T&gt;\nvoid max_value(T a, T b) {\n    if (a &gt; b) {\n        std::cout &lt;&lt; \"max_value: \" &lt;&lt; a &lt;&lt; '\\n';\n    } else {\n        std::cout &lt;&lt; \"max_value: \" &lt;&lt; b &lt;&lt; '\\n';\n    }\n}\n</code></pre> Constrain function to signed numbers <pre><code>// This function is used when Number is SignedNumber\ntemplate &lt;SignedNumber T&gt;\nvoid max_value(T a, T b) {\n    if (a &gt; b) {\n        if (a &gt; 0) {\n            std::cout &lt;&lt; \"max_value: positive \" &lt;&lt; a &lt;&lt; '\\n';\n        } else {\n            std::cout &lt;&lt; \"max_value: negative \" &lt;&lt; -a &lt;&lt; '\\n';\n        }\n    } else {\n        if (b &gt; 0) {\n            std::cout &lt;&lt; \"max_value: positive \" &lt;&lt; b &lt;&lt; '\\n';\n        } else {\n            std::cout &lt;&lt; \"max_value: negative \" &lt;&lt; -b &lt;&lt; '\\n';\n        }\n    }\n}\n</code></pre> Constrain function to unsigned numbers <pre><code>// This function is used when Number is UnsignedNumber\ntemplate&lt;UnsignedNumber T&gt;\nvoid max_value(T a, T b) {\n    if (a &gt; b) {\n        std::cout &lt;&lt; \"max_value: +\" &lt;&lt; a &lt;&lt; '\\n';\n    } else {\n        std::cout &lt;&lt; \"max_value: +\" &lt;&lt; b &lt;&lt; '\\n';\n    }\n}\n</code></pre> Constrain function to non-numbers <pre><code>// NotNumber == !Number&lt;T&gt;\ntemplate&lt;NotNumber T&gt;\nvoid max_value(T a, T b) {\n    std::cout &lt;&lt; \"a: \" &lt;&lt; a &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"b: \" &lt;&lt; b &lt;&lt; '\\n';\n}\n</code></pre> Unconstrained function <pre><code>template &lt;class T&gt;\nvoid print_element(const T &amp;c) {\n    std::cout &lt;&lt; c &lt;&lt; '\\n';\n}\n</code></pre> Constrain function to Ranges <pre><code>// - The most constrained concept is always used\ntemplate&lt;Range T&gt;\nvoid print_element(const T &amp;c) {\n    for (const auto &amp;item : c) {\n        std::cout &lt;&lt; item &lt;&lt; ' ';\n    }\n    std::cout &lt;&lt; '\\n';\n}\n</code></pre> Constrain function to ranges with value type member <pre><code>// The most constrained concept is used in nested constraints\ntemplate&lt;RangeWithValueType T&gt;\nvoid print_element(const T &amp;c) {\n    std::cout &lt;&lt; typeid(typename T::value_type).name() &lt;&lt; \": \";\n    for (const auto &amp;item : c) {\n        std::cout &lt;&lt; item &lt;&lt; ' ';\n    }\n    std::cout &lt;&lt; '\\n';\n}\n</code></pre> Constrain with require-clause directly in function declaration <pre><code>template&lt;typename T&gt;\nrequires EqualityComparable&lt;T&gt;\nvoid compare(const T &amp;a, const T &amp;b) {\n    if (a == b) {\n        std::cout &lt;&lt; a &lt;&lt; \" == \" &lt;&lt; b &lt;&lt; \" is \" &lt;&lt; (a == b ? \"true\" : \"false\") &lt;&lt; '\\n';\n    } else {\n        std::cout &lt;&lt; a &lt;&lt; \" != \" &lt;&lt; b &lt;&lt; \" is \" &lt;&lt; (a != b ? \"true\" : \"false\") &lt;&lt; '\\n';\n    }\n}\n</code></pre> Unconstrained function <pre><code>template&lt;typename T&gt;\nvoid compare(const T &amp;a, const T &amp;b) {\n    std::cout &lt;&lt; typeid(T).name() &lt;&lt; \": \" &lt;&lt; a.c &lt;&lt; \" == \" &lt;&lt; b.c &lt;&lt; \"?\" &lt;&lt; '\\n';\n}\n</code></pre> Constrain function to pairs <pre><code>template&lt;Pair T&gt;\nvoid print_pair(const T &amp;p) {\n    std::cout &lt;&lt; typeid(p.first).name() &lt;&lt; \": \" &lt;&lt; p.first &lt;&lt; \", \" &lt;&lt; typeid(p.second).name() &lt;&lt; \": \" &lt;&lt; p.second\n              &lt;&lt; '\\n';\n}\n</code></pre> Constrain function to pairs of same type <pre><code>template&lt;PairSameType T&gt;\nvoid print_pair(const T &amp;p) {\n    std::cout &lt;&lt; typeid(p.first).name() &lt;&lt; \": \" &lt;&lt; p.first &lt;&lt; \", \" &lt;&lt; p.second &lt;&lt; '\\n';\n}\n</code></pre> <p>  Share Snippets </p>"},{"location":"algorithms-data-structures/templates/metaprogramming/","title":"Metaprogramming","text":"<p>Metaprogramming</p> <p>Template metaprogramming is a family of techniques to create new types and compute values at compile time. C++ templates are Turing complete if there are no limits to the amount of recursive instantiations and the number of allowed state variables. </p> <p>Erwin Unruh was the first to demonstrate template metaprogramming at a committee meeting by instructing the  compiler to print out prime numbers in error messages. The standard recommends an implementation support at least 1024 levels of recursive instantiation, and infinite recursion in template instantiations is undefined behavior.</p> Factorial value computed as constant class value <pre><code>template &lt;unsigned n&gt; struct factorial {\n    enum { value = n * factorial&lt;n - 1&gt;::value };\n};\n\ntemplate &lt;&gt; struct factorial&lt;0&gt; {\n    enum { value = 1 };\n};\n</code></pre> Accessing factorial value calculated at compile-time <pre><code>std::cout &lt;&lt; \"factorial&lt;7&gt;::value : \" &lt;&lt; factorial&lt;7&gt;::value &lt;&lt; '\\n';\n</code></pre> Computing at compile time with constexpr <pre><code>constexpr int factorial2(int n) { return n &lt;= 1 ? 1 : (n * factorial2(n - 1)); }\n</code></pre> Accessing factorial value calculated at compile-time <pre><code>std::cout &lt;&lt; \"factorial&lt;7&gt;::value : \" &lt;&lt; factorial&lt;7&gt;::value &lt;&lt; '\\n';\n</code></pre> Count number of elements <pre><code>struct MyClass {\n    template &lt;typename... Tail&gt; static int count() { return 0; }\n\n    template &lt;char Head, char... Tail&gt; static int count() {\n        return 1 + count&lt;Tail...&gt;();\n    }\n};\n</code></pre> Access number of elements <pre><code>std::cout &lt;&lt; \"MyClass::count&lt;'f','o','o'&gt;(): \"\n          &lt;&lt; MyClass::count&lt;'f', 'o', 'o'&gt;() &lt;&lt; '\\n'; // 3\n</code></pre> <p>  Share Snippets </p>"},{"location":"algorithms-data-structures/templates/sfinae/","title":"Substitution Failure Is Not An Error","text":"<p>Substitution Failure Is Not An Error</p> <p>This rule applies during overload resolution of function  templates: When substituting the explicitly specified or deduced type for the template parameter fails, the  specialization is discarded from the overload set instead of causing a compile error.</p> <p>Because the attempted substitution is not an error, SFINAE is used as alternative to concepts in compilers that do not support C++20. The technique specifies the template parameters is such a way that only the intended template types are instanciated.</p> Headers <pre><code>#include &lt;type_traits&gt;\n</code></pre> Constrain parameter type to arithmetic types <pre><code>// The overload fails if the first parameter is not arithmetic\ntemplate &lt;class T&gt;\nvoid max(std::enable_if_t&lt;std::is_arithmetic_v&lt;T&gt;, T&gt; a, T b) {\n    if (a &gt; b) {\n        std::cout &lt;&lt; \"max: \" &lt;&lt; a &lt;&lt; '\\n';\n    } else {\n        std::cout &lt;&lt; \"max: \" &lt;&lt; b &lt;&lt; '\\n';\n    }\n}\n</code></pre> Constrain parameter type to not arithmetic <pre><code>// The overload fails if the first parameter is arithmetic\ntemplate &lt;class T&gt;\nvoid max(std::enable_if_t&lt;!std::is_arithmetic_v&lt;T&gt;, T&gt; a, T b) {\n    std::cout &lt;&lt; \"a: \" &lt;&lt; a &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"b: \" &lt;&lt; b &lt;&lt; '\\n';\n}\n</code></pre> SFINAE: Substitution Failure is Not An Error <pre><code>max(5, 7);         // call overload for arithmetic types\nmax(\"foo\", \"bar\"); // call overload for non-arithmetic types\n</code></pre> Constrain on the return type <pre><code>// The return type (bool) is only valid if T is an integral type:\ntemplate &lt;class T&gt; std::enable_if_t&lt;std::is_integral_v&lt;T&gt;, bool&gt; is_odd(T i) {\n    return bool(i % 2);\n}\n</code></pre> Constrain on the parameter list <pre><code>// The second template argument is only valid if T is an integral type\ntemplate &lt;class T, class = std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;&gt;\nbool is_even(T i) {\n    return !bool(i % 2);\n}\n</code></pre> SFINAE on functions <pre><code>std::cout &lt;&lt; \"i is odd: \" &lt;&lt; is_odd(1) &lt;&lt; '\\n'; // is_odd(1.2) wouldn't work\nstd::cout &lt;&lt; \"i is even: \" &lt;&lt; is_even(1)\n          &lt;&lt; '\\n'; // is_even(1.2) wouldn't work\n</code></pre> Floating point traits <pre><code>std::cout &lt;&lt; \"int: \" &lt;&lt; std::is_floating_point&lt;int&gt;::value &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"float: \" &lt;&lt; std::is_floating_point&lt;float&gt;::value &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"const double: \" &lt;&lt; std::is_floating_point&lt;const double&gt;::value\n          &lt;&lt; '\\n';\n</code></pre> Array traits <pre><code>std::cout &lt;&lt; \"int: \" &lt;&lt; std::is_array&lt;int&gt;::value &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"int[3]: \" &lt;&lt; std::is_array&lt;int[3]&gt;::value &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"array&lt;int,3&gt;: \" &lt;&lt; std::is_array&lt;std::array&lt;int, 3&gt;&gt;::value\n          &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"string: \" &lt;&lt; std::is_array&lt;std::string&gt;::value &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"string[3]: \" &lt;&lt; std::is_array&lt;std::string[3]&gt;::value &lt;&lt; '\\n';\n</code></pre> Class traits <pre><code>std::cout &lt;&lt; \"A: \" &lt;&lt; std::is_class&lt;A&gt;::value &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"B: \" &lt;&lt; std::is_class&lt;B&gt;::value &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"C: \" &lt;&lt; std::is_class&lt;C&gt;::value &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"D: \" &lt;&lt; std::is_class&lt;D&gt;::value &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"A: \" &lt;&lt; std::is_enum&lt;A&gt;::value &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"B: \" &lt;&lt; std::is_enum&lt;B&gt;::value &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"C: \" &lt;&lt; std::is_enum&lt;C&gt;::value &lt;&lt; '\\n';\n</code></pre> Function traits <pre><code>std::cout &lt;&lt; \"is_odd: \" &lt;&lt; std::is_function&lt;decltype(is_odd&lt;int&gt;)&gt;::value\n          &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"id_even: \" &lt;&lt; std::is_function&lt;decltype(is_even&lt;int&gt;)&gt;::value\n          &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"decltype(c): \" &lt;&lt; std::is_function&lt;C&gt;::value &lt;&lt; '\\n';\n</code></pre> Integral traits <pre><code>std::cout &lt;&lt; \"char: \" &lt;&lt; std::is_integral&lt;char&gt;::value &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"int: \" &lt;&lt; std::is_integral&lt;int&gt;::value &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"float: \" &lt;&lt; std::is_integral&lt;float&gt;::value &lt;&lt; '\\n';\n</code></pre> Pointer traits <pre><code>std::cout &lt;&lt; \"int: \" &lt;&lt; std::is_pointer&lt;int&gt;::value &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"int*: \" &lt;&lt; std::is_pointer&lt;int *&gt;::value &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"int**: \" &lt;&lt; std::is_pointer&lt;int **&gt;::value &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"int(*)(int): \" &lt;&lt; std::is_pointer&lt;int (*)(int)&gt;::value\n          &lt;&lt; '\\n';\n</code></pre> Scalar traits <pre><code>std::cout &lt;&lt; \"int: \" &lt;&lt; std::is_scalar&lt;int&gt;::value &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"A: \" &lt;&lt; std::is_scalar&lt;A&gt;::value &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"A&amp;: \" &lt;&lt; std::is_scalar&lt;A &amp;&gt;::value &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"A*: \" &lt;&lt; std::is_scalar&lt;A *&gt;::value &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"int(int): \" &lt;&lt; std::is_scalar&lt;int(int)&gt;::value &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"int(*)(int): \" &lt;&lt; std::is_scalar&lt;int (*)(int)&gt;::value &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"char: \" &lt;&lt; std::is_arithmetic&lt;char&gt;::value &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"float: \" &lt;&lt; std::is_arithmetic&lt;float&gt;::value &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"float*: \" &lt;&lt; std::is_arithmetic&lt;float *&gt;::value &lt;&lt; '\\n';\n</code></pre> <p>  Share Snippets </p>"},{"location":"algorithms-data-structures/templates/template-aliases/","title":"Template Aliases","text":"<p>Template Aliases</p> <p>A type alias is a name that refers to a previously defined type. Alias template is a name that refers to a family  of types.</p> Template alias for two-dimensional arrays <pre><code>template &lt;class T, size_t N_ROWS, size_t N_COLUMNS&gt;\nusing matrix = std::array&lt;std::array&lt;T, N_COLUMNS&gt;, N_ROWS&gt;;\n</code></pre> Using a template alias <pre><code>matrix&lt;double, 10, 3&gt; m;\ndouble i = 5.6;\nfor (auto &amp;row : m) {\n    for (auto &amp;xij : row) {\n        xij = i++;\n    }\n}\n</code></pre> Iterating the matrix <pre><code>for (auto &amp;row : m) {\n    for (auto &amp;xij : row) {\n        std::cout &lt;&lt; \"xij: \" &lt;&lt; xij &lt;&lt; '\\n';\n    }\n}\n</code></pre> <p>  Share Snippets </p>"},{"location":"algorithms-data-structures/templates/template-parameters/","title":"Template Parameters","text":"<p>Template Parameters</p> <p>A template defines a family of functions and classes. A template by itself is not a type, or a function, or  any other entity. No code is generated from a source file that contains only template definitions. </p> <p>In order for any code to appear, a template must be instantiated: the template arguments must be determined so  that the compiler can generate an actual function (or class, from a class template).</p> <p>Templates allow us to reuse the logic of algorithms for different data types. Without templates, our alternative for generic algorithms would be type erasing types.</p> Function with int parameters <pre><code>int max(int n1, int n2) { return (n1 &gt; n2) ? n1 : n2; }\n</code></pre> Function for any type T <pre><code>template &lt;class T&gt; T max(T n1, T n2) { return (n1 &gt; n2) ? n1 : n2; }\n</code></pre> Function for any types T1 and T2 <pre><code>template &lt;class T1, class T2&gt; T2 max(T1 n1, T2 n2) {\n    return (n1 &gt; n2) ? n1 : n2;\n}\n</code></pre> Calling template function for any data type <pre><code>std::cout &lt;&lt; \"max: \" &lt;&lt; max(3, 9) &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"max: \" &lt;&lt; max(3.5, 9.3) &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"max: \" &lt;&lt; max(3, 9.3) &lt;&lt; '\\n';\n</code></pre> Type erased max function <pre><code>// The \"old\" way: max operating on nullified pointers\nvoid *max(void *n1, void *n2, bool (*comp)(void *, void *)) {\n    // `comp` is responsible to internally convert `void*` to the appropriate\n    // data type and perform the comparison.\n    return (comp(n1, n2)) ? n1 : n2;\n}\n</code></pre> Type erased comparison function <pre><code>// The \"old\" way: an extra function operating on the nullified pointers\nbool comp(void *a, void *b) { return (*(int *)a &lt; *(int *)b); }\n</code></pre> Calling function with type erased parameters <pre><code>// In old C++ and C, we need nullify pointers to create generic functions.\n// It's easy to see why this is inconvenient.\nint a = 3;\nint b = 9;\nvoid *m = max(&amp;a, &amp;b, &amp;comp);\nstd::cout &lt;&lt; \"m: \" &lt;&lt; *(int *)m &lt;&lt; '\\n';\n</code></pre> Template class <pre><code>template &lt;class T1, class T2&gt; struct pair {\n    T1 first;\n    T2 second;\n};\n</code></pre> Instances of templated objects <pre><code>pair&lt;int, double&gt; p{3, 3.3};\nstd::cout &lt;&lt; \"p.first: \" &lt;&lt; p.first &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"p.second: \" &lt;&lt; p.second &lt;&lt; '\\n';\n</code></pre> <p>  Share Snippets </p>"},{"location":"basic-syntax/basic-data-types/aggregate-initialization/","title":"Aggregate initialization","text":"<p>Aggregate initialization</p> <p>Aggregate initialization initializes aggregate types.</p> CMakeLists.txt <pre><code>add_executable(aggregate_initialization aggregate_initialization.cpp)\ntarget_compile_features(aggregate_initialization PRIVATE cxx_std_20)\n</code></pre> An aggregate type <pre><code>struct A {\n    int x;\n    int y;\n    int z;\n};\n</code></pre> Initialize type with designated initializers <pre><code>A a{.x = 1, .y = 4, .z = 2};\n</code></pre> List initialization <pre><code>A c{1, 2, 3};\n</code></pre> Nested type <pre><code>struct B {\n    int x;\n    A y;\n    int z;\n};\n</code></pre> Nested initialization <pre><code>B d{.x = 1, .y = {2, 6, 5}, .z = 3};\n</code></pre> <p>  Share Snippets </p>"},{"location":"basic-syntax/basic-data-types/arrays/","title":"Arrays","text":"<p>Arrays</p> <p>In modern C++, <code>std::array</code> is a safe container that encapsulates fixed size arrays.</p> Headers <pre><code>#include &lt;array&gt;\n</code></pre> Fixed size array <pre><code>constexpr int n = 3;\nstd::array&lt;int, n&gt; a = {1, 2, 3};\n</code></pre> Iterate arrays <pre><code>for (size_t i = 0; i &lt; a.size(); ++i) {\n    std::cout &lt;&lt; \"a[\" &lt;&lt; i &lt;&lt; \"]: \" &lt;&lt; a[i] &lt;&lt; '\\n';\n}\n</code></pre> Member functions <pre><code>std::cout &lt;&lt; \"a.size(): \" &lt;&lt; a.size() &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"a.empty(): \" &lt;&lt; a.empty() &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"a.front(): \" &lt;&lt; a.front() &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"a.back(): \" &lt;&lt; a.back() &lt;&lt; '\\n';\n</code></pre> Accessing elements <pre><code>std::cout &lt;&lt; \"a[0]: \" &lt;&lt; a[0] &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"a[1]: \" &lt;&lt; a[1] &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"a[2]: \" &lt;&lt; a[2] &lt;&lt; '\\n';\n</code></pre> Accessing elements <pre><code>std::cout &lt;&lt; \"a[0]: \" &lt;&lt; a[0] &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"a[1]: \" &lt;&lt; a[1] &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"a[2]: \" &lt;&lt; a[2] &lt;&lt; '\\n';\n</code></pre> Underlying raw array <pre><code>// We might still need the underlying raw array\n// to interact with old code\nstd::cout &lt;&lt; \"Underlying raw array - a.data(): \" &lt;&lt; a.data() &lt;&lt; '\\n';\n</code></pre> Array size <pre><code>// array&lt;T,N&gt; has a fixed size in bytes\nstd::cout &lt;&lt; \"sizeof(a): \" &lt;&lt; sizeof(a) &lt;&lt; '\\n';\n</code></pre> Multidimensional array <pre><code>std::array&lt;std::array&lt;double, 3&gt;, 10&gt; matrix;\nfor (size_t i = 0; i &lt; matrix.size(); ++i) {\n    for (size_t j = 0; j &lt; matrix[i].size(); ++j) {\n        matrix[i][j] = 0.5 * i + 0.8 * j;\n    }\n}\n</code></pre> Range-based loop <pre><code>for (const auto &amp;row : matrix) {\n    double sum = 0.;\n    for (const auto &amp;col : row) {\n        sum += col;\n    }\n    std::cout &lt;&lt; \"Row average \" &lt;&lt; sum / row.size() &lt;&lt; '\\n';\n}\n</code></pre> <p>  Share Snippets </p>"},{"location":"basic-syntax/basic-data-types/build-script/","title":"Build script","text":"<pre><code>add_executable(raw_arrays raw_arrays.cpp)\n\nadd_executable(arrays arrays.cpp)\n\nadd_executable(vectors vectors.cpp)\n\nadd_executable(strings strings.cpp)\n\nadd_executable(move move.cpp)\n\nadd_executable(struct struct.cpp)\n\n#[aggregate_initialization CMakeLists.txt\nadd_executable(aggregate_initialization aggregate_initialization.cpp)\ntarget_compile_features(aggregate_initialization PRIVATE cxx_std_20)\n#]\n\n#[structured_binding CMakeLists.txt\nadd_executable(structured_binding structured_binding.cpp)\ntarget_compile_features(structured_binding PRIVATE cxx_std_17)\n#]\n</code></pre>"},{"location":"basic-syntax/basic-data-types/move/","title":"Move","text":"<p>Move</p> <p><code>std::move</code> is used to indicate that an object t may be \"moved from\", i.e. allowing the efficient transfer  of resources from one object to another.</p> Headers <pre><code>#include &lt;utility&gt;\n</code></pre> Copying a vector <pre><code>std::vector&lt;double&gt; v1(30, 1.0);\nstd::vector&lt;double&gt; v2 = v1;\n</code></pre> Both vectors are valid <pre><code>std::cout &lt;&lt; \"v1: \";\nfor (double x: v1) {\n    std::cout &lt;&lt; x &lt;&lt; \" \";\n}\nstd::cout &lt;&lt; '\\n';\n\nstd::cout &lt;&lt; \"v2: \";\nfor (double x: v2) {\n    std::cout &lt;&lt; x &lt;&lt; \" \";\n}\nstd::cout &lt;&lt; '\\n';\n</code></pre> Copying a vector <pre><code>std::vector&lt;double&gt; v1(30, 1.0);\nstd::vector&lt;double&gt; v2 = v1;\n</code></pre> The vector moved-from is invalidated <pre><code>std::cout &lt;&lt; \"v1: \";\n// NOLINTNEXTLINE(bugprone-use-after-move): making a point\nfor (double x: v1) {\n    std::cout &lt;&lt; x &lt;&lt; \" \"; // prints nothing\n}\nstd::cout &lt;&lt; '\\n';\n\nstd::cout &lt;&lt; \"v3: \";\nfor (double x: v3) {\n    std::cout &lt;&lt; x &lt;&lt; \" \";\n}\nstd::cout &lt;&lt; '\\n';\n</code></pre> <p>  Share Snippets </p>"},{"location":"basic-syntax/basic-data-types/raw-arrays/","title":"Raw arrays","text":"<p>Raw arrays</p> <p>An array is a sequence of objects of the same type that occupy a contiguous area of memory. </p> <p>Traditional C-style arrays, or Raw Arrays, are the source of many bugs, but are still common, especially in older code bases. </p> <p>In modern C++, we strongly recommend using <code>std::vector</code> or <code>std::array</code> instead of C-style arrays.</p> Explicit size <pre><code>constexpr int n = 3;\nint a[n];\na[0] = 1;\na[1] = 2;\na[2] = 3;\nstd::cout &lt;&lt; \"a: \" &lt;&lt; a &lt;&lt; '\\n';\n</code></pre> Accessing elements <pre><code>std::cout &lt;&lt; \"a[0]: \" &lt;&lt; a[0] &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"a[1]: \" &lt;&lt; a[1] &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"a[2]: \" &lt;&lt; a[2] &lt;&lt; '\\n';\n</code></pre> Accessing element address <pre><code>std::cout &lt;&lt; \"&amp;a[0]: \" &lt;&lt; &amp;a[0] &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"&amp;a[1]: \" &lt;&lt; &amp;a[1] &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"&amp;a[2]: \" &lt;&lt; &amp;a[2] &lt;&lt; '\\n';\n</code></pre> Implicit size <pre><code>int b[] = {1, 2, 3};\n</code></pre> Accessing elements in a loop <pre><code>for (size_t i = 0; i &lt; n; ++i) {\n    std::cout &lt;&lt; \"b[\" &lt;&lt; i &lt;&lt; \"]: \" &lt;&lt; b[i] &lt;&lt; '\\n';\n}\n</code></pre> Array is converted to its initial pointer <pre><code>std::cout &lt;&lt; \"b: \" &lt;&lt; b &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"&amp;b: \" &lt;&lt; &amp;b &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"b[0]: \" &lt;&lt; b[0] &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"&amp;b[0]: \" &lt;&lt; &amp;b[0] &lt;&lt; '\\n';\n</code></pre> Array addresses are sequential <pre><code>std::cout &lt;&lt; \"b[1]: \" &lt;&lt; b[1] &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"&amp;b[1]: \" &lt;&lt; &amp;b[1] &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"b[2]: \" &lt;&lt; b[2] &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"&amp;b[2]: \" &lt;&lt; &amp;b[2] &lt;&lt; '\\n';\n</code></pre> Raw strings are just arrays of chars <pre><code>char c[] = { 'a', 'b', 't', '\\0' };\n// same as:\nchar d[] = \"abt\";\n</code></pre> Raw strings are streamed until '\\0' is found <pre><code>std::cout &lt;&lt; \"c: \" &lt;&lt; c &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"d: \" &lt;&lt; d &lt;&lt; '\\n';\n</code></pre> <p>  Share Snippets </p>"},{"location":"basic-syntax/basic-data-types/strings/","title":"Strings","text":"<p>Strings</p> <p><code>std::string</code> is a safe container for <code>char</code> strings of dynamic size.</p> <p>It automatically coordinates the process of allocating and deallocating memory for the elements as required.</p> Headers <pre><code>#include &lt;string&gt;\n</code></pre> Create string <pre><code>// Strings are dynamic arrays of chars\nstd::string str = \"avocado\";\n</code></pre> Print the whole string <pre><code>std::cout &lt;&lt; str &lt;&lt; '\\n';\n</code></pre> Iterate the string chars <pre><code>for (size_t i = 0; i &lt; str.size(); ++i) {\n    std::cout &lt;&lt; \"str[\" &lt;&lt; i &lt;&lt; \"]: \" &lt;&lt; str[i] &lt;&lt; '\\n';\n}\n</code></pre> Access index <pre><code>if (str.size() &gt;= 10) {\n    std::cout &lt;&lt; \"str[10]: \" &lt;&lt; str[10] &lt;&lt; '\\n';\n} else {\n    std::cout &lt;&lt; \"str[10]: (does not exist)\" &lt;&lt; '\\n';\n}\n</code></pre> Container functions <pre><code>std::cout &lt;&lt; \"str.size(): \" &lt;&lt; str.size() &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"str.empty(): \" &lt;&lt; str.empty() &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"str.front(): \" &lt;&lt; str.front() &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"str.back(): \" &lt;&lt; str.back() &lt;&lt; '\\n';\n</code></pre> Contiguous addresses (like any array) <pre><code>std::cout &lt;&lt; \"&amp;str: \" &lt;&lt; &amp;str &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"str.data(): \" &lt;&lt; str.data() &lt;&lt; '\\n';\n</code></pre> The subscript operator accesses a single char <pre><code>std::cout &lt;&lt; \"str[0]: \" &lt;&lt; str[0] &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"str[1]: \" &lt;&lt; str[1] &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"str[2]: \" &lt;&lt; str[2] &lt;&lt; '\\n';\n</code></pre> The address of a <code>char</code> prints from that position <pre><code>std::cout &lt;&lt; \"&amp;str[0]: \" &lt;&lt; &amp;str[0] &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"&amp;str[1]: \" &lt;&lt; &amp;str[1] &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"&amp;str[2]: \" &lt;&lt; &amp;str[2] &lt;&lt; '\\n';\n</code></pre> <p>  Share Snippets </p>"},{"location":"basic-syntax/basic-data-types/structured-binding/","title":"Structured binding","text":"<p>Structured binding</p> <p>Structured binding binds the specified names to subobjects or elements of the initializer.</p> <p>Like a reference, a structured binding is an alias to an existing object.</p> CMakeLists.txt <pre><code>add_executable(structured_binding structured_binding.cpp)\ntarget_compile_features(structured_binding PRIVATE cxx_std_17)\n</code></pre> Unpacking pairs <pre><code>std::vector&lt;int&gt; v = {7, 3, 9, 3, 1, 7, 4, 9};\nauto [min_value, max_value] = minmax(v);\nstd::cout &lt;&lt; \"min_value: \" &lt;&lt; min_value &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"max_value: \" &lt;&lt; max_value &lt;&lt; '\\n';\n</code></pre> Unpacking tuples <pre><code>// `stats` returns `std::tuple&lt;int, double, double, double&gt;`\nauto [total, mean, variance, stddev] = stats(v);\nstd::cout &lt;&lt; \"total: \" &lt;&lt; total &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"mean: \" &lt;&lt; mean &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"variance: \" &lt;&lt; variance &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"stddev: \" &lt;&lt; stddev &lt;&lt; '\\n';\n</code></pre> Declare struct <pre><code>struct Foo {\n    int i;\n    char c;\n    double d;\n};\n</code></pre> Unpacking structs <pre><code>Foo f{1, 'a', 2.3};\nauto [i, c, d] = f;\nstd::cout &lt;&lt; \"f.i: \" &lt;&lt; i &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"f.c: \" &lt;&lt; c &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"f.d: \" &lt;&lt; d &lt;&lt; '\\n';\n</code></pre> Creating references <pre><code>auto &amp;[i2, c2, d2] = f;\nstd::cout &lt;&lt; \"i2: \" &lt;&lt; i2 &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"c2: \" &lt;&lt; c2 &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"d2: \" &lt;&lt; d2 &lt;&lt; '\\n';\n</code></pre> Unpacking raw arrays <pre><code>int a[2] = {1, 2};\nauto [x, y] = a;\nstd::cout &lt;&lt; \"x: \" &lt;&lt; x &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"y: \" &lt;&lt; y &lt;&lt; '\\n';\n</code></pre> range-based loop <pre><code>std::map&lt;std::string, int&gt; my_map = {\n    {\"hello\", 1},\n    {\"world\", 2},\n    {\"it's\", 3},\n    {\"me\", 4},\n};\nfor (auto &amp;&amp;[key, value] : my_map) {\n    std::cout &lt;&lt; \"key=\" &lt;&lt; key &lt;&lt; \" value=\" &lt;&lt; value &lt;&lt; '\\n';\n}\n</code></pre> Getting iterator from the insert function <pre><code>if (auto [iter, success] = my_map.insert(std::make_pair(\"Bye\", 5)); success) {\n    auto &amp;[key, value] = *iter;\n    std::cout &lt;&lt; \"insert is successful. The value is \" &lt;&lt; quoted(key) &lt;&lt; '\\n';\n} else {\n    auto &amp;[key, value] = *iter;\n    std::cout &lt;&lt; \"The value \" &lt;&lt; quoted(key) &lt;&lt; \" already exists in the set\\n\";\n}\n</code></pre> Get min and max elements from a vector <pre><code>std::pair&lt;int, int&gt; minmax(std::vector&lt;int&gt; &amp;v) {\n    // unpack tuple of iterators with min and max\n    auto [min_iter, max_iter] = std::minmax_element(v.begin(), v.end());\n    return std::make_pair(*min_iter, *max_iter);\n}\n</code></pre> <p>  Share Snippets </p>"},{"location":"basic-syntax/basic-data-types/vectors/","title":"Vectors","text":"<p>Vectors</p> <p><code>std::vector</code> is a safe container for arrays of dynamic size.</p> <p>It automatically coordinates the process of allocating and deallocating memory for the elements as required.</p> Headers <pre><code>#include &lt;vector&gt;\n</code></pre> Dynamic size vector <pre><code>std::vector&lt;int&gt; v = {1, 2, 3};\n</code></pre> Iterate vector elements <pre><code>for (size_t i = 0; i &lt; v.size(); ++i) {\n    std::cout &lt;&lt; \"v[\" &lt;&lt; i &lt;&lt; \"]: \" &lt;&lt; v[i] &lt;&lt; '\\n';\n}\n</code></pre> Member functions <pre><code>std::cout &lt;&lt; \"v.size(): \" &lt;&lt; v.size() &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"v.empty(): \" &lt;&lt; v.empty() &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"v.front(): \" &lt;&lt; v.front() &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"v.back(): \" &lt;&lt; v.back() &lt;&lt; '\\n';\n</code></pre> Access addresses <pre><code>std::cout &lt;&lt; \"&amp;v: \" &lt;&lt; &amp;v &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"&amp;v[0]: \" &lt;&lt; &amp;v[0] &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"&amp;v[1]: \" &lt;&lt; &amp;v[1] &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"&amp;v[2]: \" &lt;&lt; &amp;v[2] &lt;&lt; '\\n';\n</code></pre> Iterate vector elements <pre><code>for (size_t i = 0; i &lt; v.size(); ++i) {\n    std::cout &lt;&lt; \"v[\" &lt;&lt; i &lt;&lt; \"]: \" &lt;&lt; v[i] &lt;&lt; '\\n';\n}\n</code></pre> Modify vector <pre><code>v.push_back(5);\n</code></pre> Underlying array <pre><code>// We might still need the underlying raw array to interact with old code\nstd::cout &lt;&lt; \"Underlying raw vector: \" &lt;&lt; v.data() &lt;&lt; '\\n';\n</code></pre> Vector inline size <pre><code>// vector&lt;T,N&gt; has no fixed size in bytes\n// sizeof(v) has only the size of the pointers to manage v\nstd::cout &lt;&lt; \"sizeof(v): \" &lt;&lt; sizeof(v) &lt;&lt; '\\n';\n</code></pre> Multidimensional vector <pre><code>std::vector&lt;std::vector&lt;double&gt;&gt; matrix(10, std::vector&lt;double&gt;(3, 0));\nfor (size_t i = 0; i &lt; matrix.size(); ++i) {\n    for (size_t j = 0; j &lt; matrix[i].size(); ++j) {\n        matrix[i][j] = 0.5 * i + 0.8 * j;\n    }\n}\n</code></pre> Multidimensional range-based loops <pre><code>for (const auto &amp;row : matrix) {\n    double sum = 0.;\n    for (const auto &amp;col : row) {\n        sum += col;\n    }\n    std::cout &lt;&lt; \"Row average \" &lt;&lt; sum / row.size() &lt;&lt; '\\n';\n}\n</code></pre> <p>  Share Snippets </p>"},{"location":"basic-syntax/control-flow/conditional/","title":"Conditional","text":"<p>Conditional control flow</p> <p>Conditional expressions and conditional constructs are features of a programming language which perform different computations or actions depending on whether a programmer-specified boolean condition evaluates to true or false</p> Simple conditional <pre><code>if (first_number % 2 == 0) {\n    ++n_even_numbers;\n}\n</code></pre> Ternary Operator <pre><code>// same as: n_even_numbers += second_number % 2 == 0;\nn_even_numbers += (first_number % 2 == 0) ? 1 : 0;\n</code></pre> Branches <pre><code>if (n_even_numbers == 0) {\n    cout &lt;&lt; \"You typed 0 even numbers and 2 odd numbers\\n\";\n} else if (n_even_numbers == 1) {\n    cout &lt;&lt; \"You typed 1 even number e 1 odd number\\n\";\n} else if (n_even_numbers == 2) {\n    cout &lt;&lt; \"You typed 2 even numbers e 0 odd numbers\\n\";\n} else {\n    cout &lt;&lt; \"There's a serious problem here\\n\";\n    return 1;\n}\n</code></pre> Switch on fundamental data types <pre><code>switch (n_even_numbers) {\ncase 0:\n    cout &lt;&lt; \"Zero even numbers. Two odd numbers.\\n\";\n    break;\ncase 1:\n    cout &lt;&lt; \"One even number and one odd number.\\n\";\n    break;\ncase 2:\n    cout &lt;&lt; \"Two even numbers. No odd numbers.\\n\";\n    break;\ndefault:\n    cout &lt;&lt; \"We found a serious error with your program\\n\";\n    return 1;\n}\n</code></pre> Common conditional without n_even_numbers <pre><code>if (first_number % 2 != 0 &amp;&amp; second_number % 2 != 0) {\n    cout &lt;&lt; \"You typed 0 even numbers e 2 odd numbers\\n\";\n} else if (first_number % 2 == 0 &amp;&amp; second_number % 2 == 0) {\n    cout &lt;&lt; \"You typed 2 even numbers e 0 odd numbers\\n\";\n} else {\n    cout &lt;&lt; \"You typed 1 even number e 1 odd number\\n\";\n}\n</code></pre> Printing directly <pre><code>cout &lt;&lt; \"You typed \" &lt;&lt; n_even_numbers &lt;&lt; \" even numbers and \"\n     &lt;&lt; number_of_numbers - n_even_numbers &lt;&lt; \" odd numbers\\n\";\n</code></pre> Ternary operators for fixing plurals <pre><code>cout &lt;&lt; \"You typed \" &lt;&lt; n_even_numbers &lt;&lt; \" even number\";\ncout &lt;&lt; (n_even_numbers == 1 ? \"\" : \"s\");\ncout &lt;&lt; \" and \" &lt;&lt; number_of_numbers - n_even_numbers &lt;&lt; \" odd number\";\ncout &lt;&lt; (number_of_numbers - n_even_numbers == 1 ? \"\" : \"s\");\n</code></pre> Common conditional <pre><code>if (n_even_numbers &gt; number_of_numbers - n_even_numbers) {\n    cout &lt;&lt; \"You have more even numbers\\n\";\n} else {\n    cout &lt;&lt; \"You don't have more even numbers\\n\";\n}\n</code></pre> Ternary operator <pre><code>cout &lt;&lt; \"You \"\n     &lt;&lt; ((n_even_numbers &gt; number_of_numbers - n_even_numbers) ? (\"\")\n                                                               : (\"don't\"));\ncout &lt;&lt; \" have more even numbers than odd numbers\\n\";\n</code></pre> Testing constants <pre><code>if constexpr (number_of_numbers &gt; 2) {\n    cout &lt;&lt; \"You're program is not adapted to that yet\\n\";\n} else {\n    cout &lt;&lt; \"Program for testing up to two numbers\\n\";\n}\n</code></pre> <p>  Share Snippets </p>"},{"location":"basic-syntax/control-flow/loops/","title":"Loops","text":"<p>Loops</p> <p>A loop is a sequence of statements which is specified once but which may be carried out several times in succession. The code \"inside\" the loop (the body of the loop) is obeyed a specified number of times, or once for each of a  collection of items, or until some condition is met, or indefinitely.</p> Basic loop <pre><code>for (int i = 0; i &lt; 10; ++i) {\n    std::cout &lt;&lt; \"Hello world!\" &lt;&lt; '\\n';\n}\n</code></pre> Changing the number of repetitions <pre><code>std::cout &lt;&lt; \"How many hello worlds? \";\nint z;\nstd::cin &gt;&gt; z;\nfor (int i = 0; i &lt; z; ++i) {\n    std::cout &lt;&lt; \"Hello world\" &lt;&lt; '\\n';\n}\n</code></pre> Similar tasks according to the counter <pre><code>for (int i = 0; i &lt; 10; ++i) {\n    std::cout &lt;&lt; \"Hello world \" &lt;&lt; i &lt;&lt; \"!\\n\";\n}\n</code></pre> Changing external variables <pre><code>int total = 0;\nfor (int i = 0; i &lt; 10; ++i) {\n    total += i;\n}\nstd::cout &lt;&lt; \"0+1+2+3+4+...+9: \" &lt;&lt; total &lt;&lt; '\\n';\n</code></pre> Loop + conditional <pre><code>total = 0;\nfor (int i = 0; i &lt; 50; ++i) {\n    const bool is_multiple_of_three = i % 3 == 0;\n    if (is_multiple_of_three) {\n        total += i;\n    }\n}\nstd::cout &lt;&lt; \"0+3+6+9+12+...+48: \" &lt;&lt; total &lt;&lt; '\\n';\n</code></pre> Changing initialization <pre><code>// 5/3 + 7/4 + 9/5 + 11/6 + ...\nfloat series = 0.;\nfor (int i = 3; i &lt; 50; ++i) {\n    const auto i_float = static_cast&lt;float&gt;(i);\n    series += (i_float * 2 - 1) / i_float;\n}\nstd::cout &lt;&lt; \"5/3+7/4+9/5+...+97/49: \" &lt;&lt; series &lt;&lt; '\\n';\n</code></pre> Changing update statement to += <pre><code>total = 0;\nfor (int i = 7; i &lt; 500; i += 7) {\n    total += i;\n}\nstd::cout &lt;&lt; \"7+14+21+...+497: \" &lt;&lt; total &lt;&lt; '\\n';\n</code></pre> Changing update statement to *= <pre><code>for (int i = 2; i &lt;= 1024; i *= 2) {\n    std::cout &lt;&lt; i &lt;&lt; '\\n';\n}\n</code></pre> Index-based loop for containers with subscript operator[] <pre><code>constexpr int n = 100;\nstd::array&lt;double, n&gt; prices{};\nfor (size_t i = 0; i &lt; prices.size(); ++i) {\n    prices[i] = 4.0 + 0.1 * i;\n}\n</code></pre> Range-based loop for containers <pre><code>for (double&amp; price : prices) {\n    std::cout &lt;&lt; \"Item price: \" &lt;&lt; price &lt;&lt; '\\n';\n}\n</code></pre> Range-based loop with constant references <pre><code>double sum = 0.;\nfor (const auto &amp;price : prices) {\n    sum += price;\n}\nstd::cout &lt;&lt; \"Average price: \" &lt;&lt; sum / n &lt;&lt; '\\n';\n</code></pre> Range-based loop with maps <pre><code>std::map&lt;int, int&gt; t;\nt[7] = 2;\nt[8] = 4;\nt[4] = 6;\nfor (const auto &amp;p : t) {\n    std::cout &lt;&lt; p.first &lt;&lt; \": \" &lt;&lt; p.second &lt;&lt; '\\n';\n}\n</code></pre> Range-based loop with value pairs <pre><code>for (const auto &amp;[key, value] : t) {\n    std::cout &lt;&lt; key &lt;&lt; \": \" &lt;&lt; value &lt;&lt; '\\n';\n}\n</code></pre> 2D arrays <pre><code>constexpr int n1 = 100;\nconstexpr int n2 = 3;\nstd::array&lt;std::array&lt;double, n2&gt;, n1&gt; grades{};\nfor (int i = 0; i &lt; n1; ++i) {\n    for (int j = 0; j &lt; n2; ++j) {\n        grades[i][j] = 6. + i * (2. / n1) + j * (2. / n2);\n    }\n}\n</code></pre> 2D range based loop <pre><code>for (const auto &amp;row : grades) {\n    double row_sum = 0.0;\n    for (const auto &amp;col : row) {\n        row_sum += col;\n    }\n    std::cout &lt;&lt; \"Average student grade: \" &lt;&lt; row_sum / row.size() &lt;&lt; '\\n';\n}\n</code></pre> Columns in the external for <pre><code>for (int j = 0; j &lt; n2; ++j) {\n    double col_sum = 0.0;\n    for (int i = 0; i &lt; n1; ++i) {\n        col_sum += grades[i][j];\n    }\n    std::cout &lt;&lt; \"Average score on test \" &lt;&lt; j + 1 &lt;&lt; \": \" &lt;&lt; col_sum / n1\n         &lt;&lt; '\\n';\n}\n</code></pre> While loop <pre><code>int num = 1;\nwhile (num != 0) {\n    std::cout &lt;&lt; \"Enter a number: \";\n    std::cin &gt;&gt; num;\n    std::cout &lt;&lt; num &lt;&lt; \"^2 = \" &lt;&lt; num * num &lt;&lt; '\\n';\n}\n</code></pre> Do-while loop <pre><code>do {\n    std::cout &lt;&lt; \"Enter a number: \";\n    std::cin &gt;&gt; num;\n    std::cout &lt;&lt; num &lt;&lt; \"^2 = \" &lt;&lt; num * num &lt;&lt; '\\n';\n} while (num != 0);\n</code></pre> <p>  Share Snippets </p>"},{"location":"basic-syntax/control-flow/scopes/","title":"Scopes","text":"<p>Scopes</p> <p>The context in which a name is visible is called its scope. For example, if you declare a variable x within a  function, x is only visible within that function body. It has local scope.</p> External and internal scopes <pre><code>int x = 1;\nstd::cout &lt;&lt; \"External x: \" &lt;&lt; x &lt;&lt; '\\n';\nfor (int i = 0; i &lt; 2; ++i) {\n    int y = 2;\n    std::cout &lt;&lt; \"Internal i: \" &lt;&lt; i &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"External x: \" &lt;&lt; x &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"Internal y: \" &lt;&lt; y &lt;&lt; '\\n';\n}\nstd::cout &lt;&lt; \"External x: \" &lt;&lt; x &lt;&lt; '\\n';\n</code></pre> Variables outside their scope <pre><code>// This won't work:\n// std::cout &lt;&lt; \"Internal i: \" &lt;&lt; i &lt;&lt; '\\n';\n// std::cout &lt;&lt; \"Internal y: \" &lt;&lt; y &lt;&lt; '\\n';\n</code></pre> <p>  Share Snippets </p>"},{"location":"basic-syntax/control-flow/sequential/","title":"Sequential","text":"<p>Sequential control flow</p> <p>In structured programming, the ordered sequencing of successive commands is considered one of the basic control  structures, which is used as a building block for programs alongside iteration, recursion and conditionals.</p> Store and output values <pre><code>double l = 4;\ndouble area = l * l;\nstd::cout &lt;&lt; \"Area: \" &lt;&lt; area &lt;&lt; '\\n';\n</code></pre> Store and output values <pre><code>double l = 4;\ndouble area = l * l;\nstd::cout &lt;&lt; \"Area: \" &lt;&lt; area &lt;&lt; '\\n';\n</code></pre> Store and output values <pre><code>double l = 4;\ndouble area = l * l;\nstd::cout &lt;&lt; \"Area: \" &lt;&lt; area &lt;&lt; '\\n';\n</code></pre> <p>  Share Snippets </p>"},{"location":"basic-syntax/data-types/auto/","title":"Type deduction","text":"<p>Type deduction</p> <p>The <code>auto</code> keyword declares a variable whose type is deduced from the initialization expression in its declaration.</p> <p>Auto for fundamental data types:</p> <ul> <li>Avoid using <code>auto</code> for fundamental data types!</li> <li>This is a bad place for <code>auto</code></li> <li>It does not avoid a long type name</li> <li>It creates ambiguity<ul> <li><code>auto x = 87</code> could semantically be any number type</li> </ul> </li> <li>This is somewhat equivalent to:</li> <li>swift:  <code>var dont_do_that = 87</code></li> <li>rust:   <code>let mut dont_do_that = 87</code></li> </ul> <p>On the other hand, <code>auto</code> is very useful in generic functions where there types are not ambiguous.</p> Auto for fundamental data types <pre><code>auto dont_do_that = 87;\nstd::cout &lt;&lt; \"dont_do_that: \" &lt;&lt; dont_do_that &lt;&lt; '\\n';\n</code></pre> Creating a hash table for the next snippet <pre><code>std::unordered_map&lt;std::string, double&gt; t;\nt[\"zero\"] = 0.0;\nt[\"pi\"] = 3.14;\nt[\"ten\"] = 10.0;\n</code></pre> Accessing container without <code>auto</code> <pre><code>// NOLINTNEXTLINE(modernize-use-auto)\nstd::unordered_map&lt;std::string, double&gt;::iterator it = t.find(\"pi\");\nif (it != t.end()) {\n    std::cout &lt;&lt; it-&gt;first &lt;&lt; \": \" &lt;&lt; it-&gt;second &lt;&lt; '\\n';\n}\n</code></pre> Accessing container with <code>auto</code> <pre><code>// This is the perfect place for auto\n// - It avoids a long type name\n// - There's no ambiguity\n//   - Find will always return an iterator\nauto it2 = t.find(\"zero\");\nif (it2 != t.end()) {\n    std::cout &lt;&lt; it2-&gt;first &lt;&lt; \": \" &lt;&lt; it2-&gt;second &lt;&lt; '\\n';\n}\n</code></pre> Get type from another variable <pre><code>decltype(it) it3;\nit3 = it;\n++it3;\nif (it3 != t.end()) {\n    std::cout &lt;&lt; it3-&gt;first &lt;&lt; \": \" &lt;&lt; it3-&gt;second &lt;&lt; '\\n';\n}\n</code></pre> <code>auto</code> in generic functions <pre><code>auto print_map_container = [](const auto &amp;m) {\n    for (auto &amp;&amp;item : m) {\n        std::cout &lt;&lt; item.first &lt;&lt; \": \" &lt;&lt; item.second &lt;&lt; '\\n';\n    }\n};\nprint_map_container(t);\n</code></pre> <p>  Share Snippets </p>"},{"location":"basic-syntax/data-types/constants/","title":"Constants","text":"<p>constants</p> <p>When you do not want others (or yourself) to override existing variable values, use the <code>const</code> keyword. This will declare the variable as \"constant\", which means unchangeable and read-only.</p> Mutable variable <pre><code>int a = 2;\na = 3;\nstd::cout &lt;&lt; \"a : \" &lt;&lt; a &lt;&lt; '\\n';\n</code></pre> Constants as a promise <pre><code>const int b = 3;\n// b = 4; &lt;- this fails. `b` is constant.\nstd::cout &lt;&lt; \"b : \" &lt;&lt; b &lt;&lt; '\\n';\n</code></pre> <code>const</code> from mutable value <pre><code>// `b2` can be initialized with any value, but cannot be changed after this.\n// This is possible, but makes it impossible to know b2 in compile-time.\nconst int b2 = a;\nstd::cout &lt;&lt; \"b2 : \" &lt;&lt; b2 &lt;&lt; '\\n';\n</code></pre> Constant \"more constant than const\" <pre><code>// `c` can only use values available at compile-time\n// `c` cannot be initialized with a mutable value\nconstexpr int c = 4;\nstd::cout &lt;&lt; \"c : \" &lt;&lt; c &lt;&lt; '\\n';\n</code></pre> Constant \"more constant than const\" <pre><code>// `c` can only use values available at compile-time\n// `c` cannot be initialized with a mutable value\nconstexpr int c = 4;\nstd::cout &lt;&lt; \"c : \" &lt;&lt; c &lt;&lt; '\\n';\n</code></pre> Creating arrays from mutable value <pre><code>// The compiler needs to know the size at compile time\n// Impossible:\n// std::array&lt;int,a&gt; v1;\n</code></pre> Creating arrays from compile-time <code>const</code> values <pre><code>// Sometimes possible, if b was not initialized with a mutable value\nstd::array&lt;int, b&gt; v2 = {5, 6, 5};\nstd::cout &lt;&lt; \"v2.size(): \" &lt;&lt; v2.size() &lt;&lt; '\\n';\n</code></pre> Creating arrays from runtime <code>const</code> values <pre><code>// Impossible (b2 depends on a variable):\n// std::array&lt;int,b2&gt; v2b;\n</code></pre> Creating arrays from compile-time <code>constexpr</code> values <pre><code>// Always possible\nstd::array&lt;int, c&gt; v3 = {7, 8, 7, 8};\nstd::cout &lt;&lt; \"v3.size(): \" &lt;&lt; v3.size() &lt;&lt; '\\n';\n</code></pre> <p>  Share Snippets </p>"},{"location":"basic-syntax/data-types/fundamental-data-types/","title":"Fundamental Data Types","text":"<p>Fundamental Data Types</p> <p>A fundamental or primitive type is a data type where the values that it can represent have a very simple nature (a number, a character or a truth-value); the primitive types are the most basic building blocks for any  programming language and are the base for more complex data types.</p> Basic types: bool <pre><code>bool a = true;\nstd::cout &lt;&lt; \"bool a: \" &lt;&lt; a &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"sizeof(a): \" &lt;&lt; sizeof(a) &lt;&lt; \" bytes\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; to_bitset(a) &lt;&lt; std::endl;\n</code></pre> Basic types: int <pre><code>int b = 25;\nstd::cout &lt;&lt; \"int b: \" &lt;&lt; b &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"sizeof(b): \" &lt;&lt; sizeof(b) &lt;&lt; \" bytes\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; to_bitset(b) &lt;&lt; std::endl;\n</code></pre> Basic types: double <pre><code>double c = 1.34;\nstd::cout &lt;&lt; \"double c: \" &lt;&lt; c &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"sizeof(c): \" &lt;&lt; sizeof(c) &lt;&lt; \" bytes\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; to_bitset(c) &lt;&lt; std::endl;\n</code></pre> Basic types: char <pre><code>char d = 'g';\nstd::cout &lt;&lt; \"char d: \" &lt;&lt; d &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"sizeof(d): \" &lt;&lt; sizeof(d) &lt;&lt; \" bytes\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; to_bitset(d) &lt;&lt; std::endl;\n</code></pre> Integer implicit precision: long <pre><code>long g = 25;\nstd::cout &lt;&lt; \"long g: \" &lt;&lt; g &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"sizeof(g): \" &lt;&lt; sizeof(g) &lt;&lt; \" bytes\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; to_bitset(g) &lt;&lt; std::endl;\n</code></pre> Integer implicit precision: long long <pre><code>long long h = 8271;\nstd::cout &lt;&lt; \"long long h: \" &lt;&lt; h &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"sizeof(h): \" &lt;&lt; sizeof(h) &lt;&lt; \" bytes\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; to_bitset(h) &lt;&lt; std::endl;\n</code></pre> Unsigned integer - implicit precision: unsigned long <pre><code>unsigned long i = 987312;\nstd::cout &lt;&lt; \"unsigned long i: \" &lt;&lt; i &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"sizeof(i): \" &lt;&lt; sizeof(i) &lt;&lt; \" bytes\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; to_bitset(i) &lt;&lt; std::endl;\n</code></pre> Unsigned integer - implicit precision: unsigned long long <pre><code>unsigned long long j = 4398271;\nstd::cout &lt;&lt; \"unsigned long long j: \" &lt;&lt; j &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"sizeof(j): \" &lt;&lt; sizeof(j) &lt;&lt; \" bytes\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; to_bitset(j) &lt;&lt; std::endl;\n</code></pre> Integer explicit precision: int8_t <pre><code>int8_t k = 25;\nstd::cout &lt;&lt; \"int8_t k: \" &lt;&lt; k &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"sizeof(k): \" &lt;&lt; sizeof(k) &lt;&lt; \" bytes\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; to_bitset(k) &lt;&lt; std::endl;\n</code></pre> Integer explicit precision: int64_t <pre><code>int64_t l = 542;\nstd::cout &lt;&lt; \"int64_t l: \" &lt;&lt; l &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"sizeof(l): \" &lt;&lt; sizeof(l) &lt;&lt; \" bytes\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; to_bitset(l) &lt;&lt; std::endl;\n</code></pre> Floating point precision: float <pre><code>float o = 25.54;\nstd::cout &lt;&lt; \"float o: \" &lt;&lt; o &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"sizeof(o): \" &lt;&lt; sizeof(o) &lt;&lt; \" bytes\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; to_bitset(o) &lt;&lt; std::endl;\n</code></pre> Floating point precision: long double <pre><code>long double p = 987312.325;\nstd::cout &lt;&lt; \"long double p: \" &lt;&lt; p &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"sizeof(p): \" &lt;&lt; sizeof(p) &lt;&lt; \" bytes\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; to_bitset(p) &lt;&lt; std::endl;\n</code></pre> Basic types: char <pre><code>char d = 'g';\nstd::cout &lt;&lt; \"char d: \" &lt;&lt; d &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"sizeof(d): \" &lt;&lt; sizeof(d) &lt;&lt; \" bytes\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; to_bitset(d) &lt;&lt; std::endl;\n</code></pre> <p>  Share Snippets </p>"},{"location":"basic-syntax/data-types/operators/","title":"Operators","text":"<p>Operators</p> <p>Operators are symbols that perform operations on variables and values. For example, <code>+</code> is an operator used for  addition, while <code>-</code> is an operator used for subtraction.</p> Operators <pre><code>int n1 = 8;\nint n2 = 3;\nstd::cout &lt;&lt; n1 &lt;&lt; \" + \" &lt;&lt; n2 &lt;&lt; \": \" &lt;&lt; n1 + n2 &lt;&lt; '\\n';\nstd::cout &lt;&lt; n1 &lt;&lt; \" - \" &lt;&lt; n2 &lt;&lt; \": \" &lt;&lt; n1 - n2 &lt;&lt; '\\n';\nstd::cout &lt;&lt; n1 &lt;&lt; \" * \" &lt;&lt; n2 &lt;&lt; \": \" &lt;&lt; n1 * n2 &lt;&lt; '\\n';\nstd::cout &lt;&lt; n1 &lt;&lt; \" / \" &lt;&lt; n2 &lt;&lt; \": \" &lt;&lt; n1 / n2 &lt;&lt; '\\n';\nstd::cout &lt;&lt; n1 &lt;&lt; \" % \" &lt;&lt; n2 &lt;&lt; \": \" &lt;&lt; n1 % n2 &lt;&lt; '\\n';\n</code></pre> Operators for floating point types <pre><code>double n3 = 8.;\ndouble n4 = 3.;\nstd::cout &lt;&lt; n3 &lt;&lt; \" + \" &lt;&lt; n4 &lt;&lt; \": \" &lt;&lt; n3 + n4 &lt;&lt; '\\n';\nstd::cout &lt;&lt; n3 &lt;&lt; \" - \" &lt;&lt; n4 &lt;&lt; \": \" &lt;&lt; n3 - n4 &lt;&lt; '\\n';\nstd::cout &lt;&lt; n3 &lt;&lt; \" * \" &lt;&lt; n4 &lt;&lt; \": \" &lt;&lt; n3 * n4 &lt;&lt; '\\n';\nstd::cout &lt;&lt; n3 &lt;&lt; \" / \" &lt;&lt; n4 &lt;&lt; \": \" &lt;&lt; n3 / n4 &lt;&lt; '\\n';\n</code></pre> There is no % for floating point types <pre><code>std::cout &lt;&lt; \"fmod(\" &lt;&lt; n3 &lt;&lt; \", \" &lt;&lt; n4 &lt;&lt; \"): \" &lt;&lt; fmod(n3, n4) &lt;&lt; '\\n';\n// This won't work: std::cout &lt;&lt; n3 &lt;&lt; \" % \" &lt;&lt; n4 &lt;&lt; \": \" &lt;&lt; n3 % n4 &lt;&lt; '\\n';\n</code></pre> Attribution operator <pre><code>n1 += n2; // n1 = n1 + n2;\nstd::cout &lt;&lt; \"n1 after += is \" &lt;&lt; n1 &lt;&lt; '\\n';\nn1 -= n2;\nstd::cout &lt;&lt; \"n1 after -= is \" &lt;&lt; n1 &lt;&lt; '\\n';\nn1 *= n2;\nstd::cout &lt;&lt; \"n1 after *= is \" &lt;&lt; n1 &lt;&lt; '\\n';\nn1 /= n2;\nstd::cout &lt;&lt; \"n1 after /= is \" &lt;&lt; n1 &lt;&lt; '\\n';\nn1 %= n2;\nstd::cout &lt;&lt; \"n1 after %= is \" &lt;&lt; n1 &lt;&lt; '\\n';\n</code></pre> Postfixed increment/decrement <pre><code>n1++; // or n1 += 1; // or n1 = n1 + 1;\nstd::cout &lt;&lt; \"n1 after ++ is \" &lt;&lt; n1 &lt;&lt; '\\n';\nn1--;\nstd::cout &lt;&lt; \"n1 after -- is \" &lt;&lt; n1 &lt;&lt; '\\n';\n</code></pre> Prefixed increment <pre><code>// same as n1 += 1; // or n1 = n1 + 1;\n++n1;\nstd::cout &lt;&lt; \"n1 after ++ is \" &lt;&lt; n1 &lt;&lt; '\\n';\n</code></pre> Prefixed decrement <pre><code>// same as n1 -= 1; // or n1 = n1 - 1;\n--n1;\nstd::cout &lt;&lt; \"n1 after -- is \" &lt;&lt; n1 &lt;&lt; '\\n';\n</code></pre> Postfixed inside an expression: use and increment <pre><code>std::cout &lt;&lt; \"n1: \" &lt;&lt; n1++ &lt;&lt; '\\n';\n</code></pre> Prefixed inside an expression: increment and use <pre><code>std::cout &lt;&lt; \"n1: \" &lt;&lt; ++n1 &lt;&lt; '\\n';\n</code></pre> <p>  Share Snippets </p>"},{"location":"basic-syntax/files/file-streams/","title":"File streams","text":"<p>File streams</p> <p>C++ provides file streams to perform output and input of characters to/from files. These classes are derived directly or indirectly from the classes std::istream and std::ostream. </p> <p>We have already used objects whose types were these classes: <code>std::cin</code> is an object of class <code>std::istream</code> and  <code>std::cout</code> is an object of class ostream. </p> <p>We can use our file streams the same way we are already used to use <code>std::cin</code> and <code>std::cout</code>, with the only  difference that we have to associate these streams with physical files.:</p> Create a vector of numbers <pre><code>std::vector&lt;int&gt; numbers;\nconstexpr size_t n = 15;\nnumbers.resize(n);\nfor (size_t i = 0; i &lt; n; ++i) {\n    numbers[i] = i * 1000 + 1;\n}\n</code></pre> Save numbers in text file <pre><code>std::ofstream fout(\"numbers.txt\");\nfor (int number : numbers) {\n    fout &lt;&lt; number &lt;&lt; \" \";\n}\nfout.close();\n</code></pre> Load numbers from text file <pre><code>std::vector&lt;int&gt; m_numbers;\nstd::ifstream fin(\"numbers.txt\");\ndo {\n    int x;\n    fin &gt;&gt; x;\n    if (fin) {\n        m_numbers.emplace_back(x);\n    }\n} while (fin);\nfin.close();\n</code></pre> Print numbers from file <pre><code>for (const auto &amp;number : numbers) {\n    std::cout &lt;&lt; number &lt;&lt; \" \";\n}\nstd::cout &lt;&lt; '\\n';\nfor (const auto &amp;number : m_numbers) {\n    std::cout &lt;&lt; number &lt;&lt; \" \";\n}\nstd::cout &lt;&lt; '\\n';\n</code></pre> Save numbers in binary file <pre><code>fout.open(\"numbers.bin\", std::ios::binary);\nfor (int &amp;number : numbers) {\n    char *pointer_to_number = (char *)&amp;number;\n    size_t bytes_per_number = sizeof(number);\n    fout.write(pointer_to_number, bytes_per_number);\n}\nfout.close();\n</code></pre> Load numbers from binary file <pre><code>m_numbers.clear();\nfin.open(\"numbers.bin\", std::ios::binary);\nfor (size_t i = 0; i &lt; numbers.size(); ++i) {\n    int x;\n    char *pointer_to_number = (char *)&amp;x;\n    size_t bytes_per_number = sizeof(x);\n    fin.read(pointer_to_number, bytes_per_number);\n    m_numbers.emplace_back(x);\n}\nfin.close();\n</code></pre> Print numbers from file <pre><code>for (const auto &amp;number : numbers) {\n    std::cout &lt;&lt; number &lt;&lt; \" \";\n}\nstd::cout &lt;&lt; '\\n';\nfor (const auto &amp;number : m_numbers) {\n    std::cout &lt;&lt; number &lt;&lt; \" \";\n}\nstd::cout &lt;&lt; '\\n';\n</code></pre> Compare file sizes <pre><code>std::cout &lt;&lt; \"File size (text): \"\n          &lt;&lt; std::filesystem::file_size(\"numbers.txt\") &lt;&lt; \" bytes\\n\";\nstd::cout &lt;&lt; \"File size (binary): \"\n          &lt;&lt; std::filesystem::file_size(\"numbers.bin\") &lt;&lt; \" bytes\\n\";\n</code></pre> <p>  Share Snippets </p>"},{"location":"basic-syntax/files/filesystem/","title":"Filesystem","text":"<p>Filesystem</p> <p>The Filesystem library provides facilities for performing operations on file systems and their components, such as  paths, regular files, and directories. </p> <p>The filesystem library was originally developed as  boost.filesystem, was published as the  technical specification ISO/IEC TS 18822:2015, and finally merged to ISO C++ as of C++17. </p> <p>The boost implementation is currently available on more compilers and platforms than the C++17 library.</p> Find package <pre><code># Use CMake script to identify if Filesystem library is available\n# This will look for the headers &lt;filesystem&gt; or &lt;experimental/filesystem&gt;\n# See CMake Functions\nfind_package(Filesystem)\n</code></pre> Find boost.filesystem if C++17 is not available <pre><code># See https://cmake.org/cmake/help/latest/module/FindBoost.html\nif (NOT Filesystem_FOUND)\n    find_package(Boost COMPONENTS filesystem)\nendif()\n</code></pre> Use C++17 filesystem or Boost.Filesystem <pre><code>add_executable(filesystem_manage filesystem.cpp)\nif (Filesystem_FOUND)\n    target_link_libraries(filesystem_manage PRIVATE std::filesystem)\n    target_compile_definitions(filesystem_manage PRIVATE -DCXX_FILESYSTEM_HEADER=&lt;${CXX_FILESYSTEM_HEADER}&gt;)\n    target_compile_definitions(filesystem_manage PRIVATE -DCXX_FILESYSTEM_NAMESPACE=${CXX_FILESYSTEM_NAMESPACE})\nelseif(Boost_FOUND)\n    target_link_libraries(filesystem_manage PRIVATE Boost::filesystem)\n    target_compile_definitions(filesystem_manage PRIVATE -DCXX_FILESYSTEM_HEADER=&lt;boost/filesystem.hpp&gt;)\n    target_compile_definitions(filesystem_manage PRIVATE -DCXX_FILESYSTEM_NAMESPACE=boost::filesystem)\nendif()\n</code></pre> Include headers found by CMake <pre><code>#include CXX_FILESYSTEM_HEADER\n</code></pre> Define <code>fs</code> as the namespace for the filesystem library <pre><code>namespace fs = CXX_FILESYSTEM_NAMESPACE;\n</code></pre> Writing to file <pre><code>std::ofstream fout;\nfout.open(\"example.txt\");\nif (fout.is_open()) {\n    fout &lt;&lt; \"This is a line.\\n\";\n    fout &lt;&lt; \"This is another line.\\n\";\n    fout.close();\n}\n</code></pre> Reading from file <pre><code>std::string line;\nstd::ifstream fin(\"example.txt\");\nif (fin.is_open()) {\n    while (getline(fin, line)) {\n        std::cout &lt;&lt; line &lt;&lt; '\\n';\n    }\n    fin.close();\n}\n</code></pre> Describing paths <pre><code>fs::path p1{\"C:\\\\\"};\nfs::path p2{\"C:\\\\Windows\"};\nfs::path p3{L\"C:\\\\Boost C++ \\u5E93\"};\nstd::cout &lt;&lt; \"p2.string(): \" &lt;&lt; p2.string() &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"p2.generic_string(): \" &lt;&lt; p2.generic_string() &lt;&lt; '\\n';\n</code></pre> Portable paths <pre><code>fs::path root_p{\"/\"};\nstd::cout &lt;&lt; \"root_p.string(): \" &lt;&lt; root_p.string() &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"root_p.generic_string(): \" &lt;&lt; root_p.generic_string() &lt;&lt; '\\n';\n</code></pre> Path components <pre><code>fs::path p{\"C:\\\\Windows\\\\System\\\\photo.jpg\"};\nstd::cout &lt;&lt; \"p.root_name(): \" &lt;&lt; p.root_name() &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"p.root_directory(): \" &lt;&lt; p.root_directory() &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"p.root_path(): \" &lt;&lt; p.root_path() &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"p.relative_path(): \" &lt;&lt; p.relative_path() &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"p.parent_path(): \" &lt;&lt; p.parent_path() &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"p.filename(): \" &lt;&lt; p.filename() &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"p.stem(): \" &lt;&lt; p.stem() &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"p.extension(): \" &lt;&lt; p.extension() &lt;&lt; '\\n';\n</code></pre> Relative paths <pre><code>fs::path pl{\"/Linux/System/photo.jpg\"};\nstd::cout &lt;&lt; \"pl: \" &lt;&lt; pl &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"pl.lexically_proximate(\\\"/Linux/\\\"): \"\n     &lt;&lt; pl.lexically_proximate(\"/Linux/\") &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"pl.root_name(): \" &lt;&lt; pl.root_name() &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"pl.root_directory(): \" &lt;&lt; pl.root_directory() &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"pl.root_path(): \" &lt;&lt; pl.root_path() &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"pl.relative_path(): \" &lt;&lt; pl.relative_path() &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"pl.parent_path(): \" &lt;&lt; pl.parent_path() &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"pl.filename(): \" &lt;&lt; pl.filename() &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"pl.stem(): \" &lt;&lt; pl.stem() &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"pl.extension(): \" &lt;&lt; pl.extension() &lt;&lt; '\\n';\n</code></pre> Iterate Path components <pre><code>fs::path p4{\"C:\\\\Windows\\\\System\\\\photo.jpg\"};\nfor (const fs::path &amp;pp : p4) {\n    std::cout &lt;&lt; pp &lt;&lt; '\\n';\n}\n</code></pre> Iterate Path components <pre><code>fs::path p5{\"/Linux/System/photo.jpg\"};\nfor (const fs::path &amp;pp : p5) {\n    std::cout &lt;&lt; pp &lt;&lt; '\\n';\n}\n</code></pre> Concatenate paths <pre><code>fs::path p6{\"/\"};\np6 /= \"Linux/System\";\nfor (const fs::path &amp;pp : p6) {\n    std::cout &lt;&lt; pp &lt;&lt; '\\n';\n}\n</code></pre> Files and Directories <pre><code>fs::path p7{\"/\"};\ntry {\n    fs::file_status s = status(p7);\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; fs::is_directory(s) &lt;&lt; '\\n';\n} catch (fs::filesystem_error const &amp;e) {\n    std::cerr &lt;&lt; e.what() &lt;&lt; '\\n';\n}\n</code></pre> File size <pre><code>fs::path p8{\"C:\\\\Windows\\\\win.ini\"};\nstd::error_code ec;\nsize_t filesize = fs::file_size(p8, ec);\nif (!ec) {\n    std::cout &lt;&lt; filesize &lt;&lt; '\\n';\n} else {\n    std::cout &lt;&lt; ec &lt;&lt; '\\n';\n}\n</code></pre> Last time write <pre><code>fs::path p9{\"C:\\\\Windows\\\\win.ini\"};\ntry {\n    // Maybe unused as an example, because the next code snippet\n    // is not portable\n    fs::file_time_type t = last_write_time(p9);\n    /* The following is not portable:\n     * https://en.cppreference.com/w/cpp/filesystem/file_time_type\n    std::time_t cftime = fs::file_time_type::clock::to_time_t(t);\n    std::cout &lt;&lt; cftime &lt;&lt; '\\n';\n     */\n    (void) t; // t is unused because the previous snippet is not portable\n} catch (fs::filesystem_error &amp;e) {\n    std::cout &lt;&lt; e.what() &lt;&lt; '\\n';\n}\n</code></pre> Retrieve total and remaining disk space <pre><code>fs::path p10{\"/\"};\ntry {\n    fs::space_info s = space(p10);\n    std::cout &lt;&lt; \"s.capacity: \" &lt;&lt; s.capacity &lt;&lt; \" bytes\" &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"s.free: \" &lt;&lt; s.free &lt;&lt; \" bytes\" &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"s.available: \" &lt;&lt; s.available &lt;&lt; \" bytes\" &lt;&lt; '\\n';\n} catch (fs::filesystem_error &amp;e) {\n    std::cerr &lt;&lt; e.what() &lt;&lt; '\\n';\n}\n</code></pre> Creating, renaming, and deleting directories <pre><code>fs::path p11 = fs::current_path();\np /= \"test_directory\";\ntry {\n    if (create_directory(p11)) {\n        fs::path p12 = fs::current_path();\n        p12 /= \"test_directory2\";\n        rename(p, p12);\n        fs::remove(p12);\n    } else {\n        std::cout &lt;&lt; \"The path could not be created\" &lt;&lt; '\\n';\n    }\n} catch (fs::filesystem_error &amp;e) {\n    std::cerr &lt;&lt; e.what() &lt;&lt; '\\n';\n}\n</code></pre> absolute path based on a file name <pre><code>try {\n    std::cout &lt;&lt; fs::absolute(\"photo.jpg\") &lt;&lt; '\\n';\n} catch (fs::filesystem_error &amp;e) {\n    std::cerr &lt;&lt; e.what() &lt;&lt; '\\n';\n}\n</code></pre> Iterating over directory files <pre><code>fs::path p13 = fs::current_path();\nfs::directory_iterator range{p13};\nfor (auto &amp;dir_p : range) {\n    std::cout &lt;&lt; dir_p.path().filename() &lt;&lt; '\\n';\n}\n</code></pre> Iterating over directory files <pre><code>fs::path p13 = fs::current_path();\nfs::directory_iterator range{p13};\nfor (auto &amp;dir_p : range) {\n    std::cout &lt;&lt; dir_p.path().filename() &lt;&lt; '\\n';\n}\n</code></pre> File Streams from paths <pre><code>fs::path p15 = fs::absolute(\"example_text.txt\");\nstd::ofstream ofs{p15};\nofs &lt;&lt; \"Hello, world!\\n\";\nofs &lt;&lt; \"Bye, world!\\n\";\n</code></pre> <p>  Share Snippets </p>"},{"location":"basic-syntax/functions/build-script/","title":"Build script","text":"<pre><code>add_executable(functions functions.cpp)\n\nadd_executable(lambda lambda.cpp)\n</code></pre>"},{"location":"basic-syntax/functions/function/","title":"Functions","text":"<p>About functions</p> <p>These snippets are about the syntax for defining functions. They are not about how to achieve tasks with these  functions. The tasks are just placeholders and the C++ STL already provides much better alternatives for most of these algorithms.</p> Function declaration <pre><code>void show_menu();\n</code></pre> Function definition <pre><code>void show_menu() {\n    std::cout &lt;&lt; \"Options:\\n\"\n                 \"[0] Exit\\n\"\n                 \"[1] Sum\\n\"\n                 \"[2] Multiply\\n\";\n}\n</code></pre> Calling Function <pre><code>// Call function 3 times\nfor (int i = 0; i &lt; 3; ++i) {\n    show_menu();\n}\n</code></pre> Declare and define constexpr function - return value <code>double</code> <pre><code>constexpr double pi() { return 3.14159265358979323846; }\n</code></pre> Call constexpr function <pre><code>std::cout &lt;&lt; \"\u03c0 = \" &lt;&lt; pi() &lt;&lt; '\\n';\n</code></pre> Declare and define function with one parameter <pre><code>double power_three(double x) { return x * x * x; }\n</code></pre> Call function with one parameter <pre><code>std::cout &lt;&lt; \"4.4^3 = \" &lt;&lt; power_three(4.4) &lt;&lt; '\\n';\n</code></pre> Function with two parameters <pre><code>double power(double x, int y) {\n    double result = 1;\n    for (int i = 0; i &lt; y; ++i) {\n        result *= x;\n    }\n    return result;\n}\n</code></pre> Call function with two parameters <pre><code>std::cout &lt;&lt; \"4.4^5 = \" &lt;&lt; power(4.4, 5) &lt;&lt; '\\n';\n</code></pre> Function with parameters by reference - No return <pre><code>void times_two(int &amp;x) { x *= 2; }\n</code></pre> Call function with parameters by reference <pre><code>int x = 5;\ntimes_two(x);\nstd::cout &lt;&lt; \"x = \" &lt;&lt; x &lt;&lt; '\\n'; // 10\n</code></pre> Parameters by reference and default parameter <pre><code>// Always pass arrays by reference to avoid copying\nvoid increment_all(std::array&lt;int, 1000&gt; &amp;a, int increment_value = 1) {\n    for (int &amp;x : a) {\n        x += increment_value;\n    }\n}\n</code></pre> Call function with parameter by reference <pre><code>std::array&lt;int, 1000&gt; v{};\nincrement_all(v);\nfor (int i : v) {\n    std::cout &lt;&lt; i &lt;&lt; \" \";\n}\nstd::cout &lt;&lt; '\\n';\n</code></pre> Call function without default parameter <pre><code>increment_all(v, 10);\nfor (int i : v) {\n    std::cout &lt;&lt; i &lt;&lt; \" \";\n}\nstd::cout &lt;&lt; '\\n';\n</code></pre> Parameters by const reference <pre><code>// Parameters by constant reference\n// - We don't want to copy\n// - But we also don't want to change it\nbool has_element(const std::array&lt;int, 1000&gt; &amp;a, int element) {\n    for (int x : a) {\n        if (x == element) {\n            return true;\n        }\n    }\n    return false;\n}\n</code></pre> Call function with parameters by const reference <pre><code>std::array&lt;int, 1000&gt; v{};\nfor (size_t i = 0; i &lt; v.size(); ++i) {\n    v[i] = i;\n}\nif (has_element(v, 400)) {\n    std::cout &lt;&lt; \"Array v has the element 400\" &lt;&lt; '\\n';\n} else {\n    std::cout &lt;&lt; \"Array v doesn't have the element 400\" &lt;&lt; '\\n';\n}\n</code></pre> \"Return\" two values by reference <pre><code>void minmax(int a, int b, int c, int &amp;minimum, int &amp;maximum) {\n    if (a &gt; b) {\n        minimum = b;\n        maximum = a;\n    } else {\n        minimum = a;\n        maximum = b;\n    }\n    if (c &gt; maximum) {\n        maximum = c;\n    }\n    if (c &lt; minimum) {\n        minimum = c;\n    }\n    // values of external variables are set\n}\n</code></pre> \"Returning\" two values by reference <pre><code>int maximum;\nint minimum;\nminmax(5, 3, 8, minimum, maximum);\nstd::cout &lt;&lt; \"Minimum and maximum: \" &lt;&lt; minimum &lt;&lt; \", \" &lt;&lt; maximum &lt;&lt; '\\n';\n</code></pre> Return two values with a pair <pre><code>std::pair&lt;int, int&gt; minmax(int a, int b, int c) {\n    int minimum;\n    int maximum;\n    if (a &gt; b) {\n        minimum = b;\n        maximum = a;\n    } else {\n        minimum = a;\n        maximum = b;\n    }\n    if (c &gt; maximum) {\n        maximum = c;\n    }\n    if (c &lt; minimum) {\n        minimum = c;\n    }\n    return std::make_pair(minimum, maximum);\n}\n</code></pre> Returning two values with a pair <pre><code>std::pair&lt;int, int&gt; p = minmax(5, 3, 8);\nstd::cout &lt;&lt; \"Minimum and maximum: \" &lt;&lt; p.first &lt;&lt; \", \" &lt;&lt; p.second &lt;&lt; '\\n';\n</code></pre> Returning two values with structured binding <pre><code>auto [m1, m2] = minmax(5, 3, 8);\nstd::cout &lt;&lt; \"Minimum and maximum: \" &lt;&lt; m1 &lt;&lt; \", \" &lt;&lt; m2 &lt;&lt; '\\n';\n</code></pre> Returning two values with tie <pre><code>std::tie(m1, m2) = minmax(5, 3, 8);\nstd::cout &lt;&lt; \"Minimum and maximum: \" &lt;&lt; m1 &lt;&lt; \", \" &lt;&lt; m2 &lt;&lt; '\\n';\n</code></pre> \"Return\" three values by reference <pre><code>void sort(int a, int b, int c, int &amp;minimum, int &amp;middle, int &amp;maximum) {\n    minmax(a, b, c, minimum, maximum);\n    if (a != minimum &amp;&amp; a != maximum) {\n        middle = a;\n        return;\n    }\n    if (b != minimum &amp;&amp; b != maximum) {\n        middle = b;\n        return;\n    }\n    middle = c;\n}\n</code></pre> \"Returning\" three values by reference <pre><code>int minimum;\nint middle;\nint maximum;\nsort(5, 3, 8, minimum, middle, maximum);\nstd::cout &lt;&lt; \"Sorting 5, 3, 8 = \" &lt;&lt; minimum &lt;&lt; \", \" &lt;&lt; middle &lt;&lt; \", \"\n          &lt;&lt; maximum &lt;&lt; '\\n';\n</code></pre> Return three values with a tuple <pre><code>std::tuple&lt;int, int, int&gt; sort(int a, int b, int c) {\n    auto [minimum, maximum] = minmax(a, b, c);\n    if (a != minimum &amp;&amp; a != maximum) {\n        return std::make_tuple(minimum, a, maximum);\n    }\n    if (b != minimum &amp;&amp; b != maximum) {\n        return std::make_tuple(minimum, b, maximum);\n    }\n    return std::make_tuple(minimum, b, maximum);\n}\n</code></pre> Returning three values with a tuple <pre><code>std::tuple&lt;int, int, int&gt; t = sort(5, 3, 8);\nstd::cout &lt;&lt; \"Sorting 5, 3, 8: \" &lt;&lt; get&lt;0&gt;(t) &lt;&lt; \", \" &lt;&lt; get&lt;1&gt;(t) &lt;&lt; \", \"\n          &lt;&lt; get&lt;2&gt;(t) &lt;&lt; '\\n';\n</code></pre> Returning three values with structured binding <pre><code>auto [minimum3, middle3, maximum3] = sort(5, 3, 8);\nstd::cout &lt;&lt; \"Sorting 5, 3, 8: \" &lt;&lt; minimum3 &lt;&lt; \", \" &lt;&lt; middle3 &lt;&lt; \", \"\n          &lt;&lt; maximum3 &lt;&lt; '\\n';\n</code></pre> Returning three values with tie <pre><code>std::tie(minimum3, middle3, maximum3) = sort(5, 3, 8);\nstd::cout &lt;&lt; \"Sorting 5, 3, 8: \" &lt;&lt; minimum3 &lt;&lt; \", \" &lt;&lt; middle3 &lt;&lt; \", \"\n          &lt;&lt; maximum3 &lt;&lt; '\\n';\n</code></pre> Parameter by pointer by value <pre><code>// Pass pointers by value: https://youtu.be/xGDLkt-jBJ4?t=869\n// As small as the reference and no other level of indirection\nvoid pointer_to_cube(std::shared_ptr&lt;int&gt; p) {\n    if (p) {\n        *p = *p * *p * *p;\n    }\n}\n</code></pre> Parameter by pointer by value <pre><code>std::shared_ptr&lt;int&gt; ptr = std::make_shared&lt;int&gt;(5);\npointer_to_cube(ptr);\nstd::cout &lt;&lt; \"5^3 = \" &lt;&lt; *ptr &lt;&lt; '\\n';\n</code></pre> Iterative Fibonacci function <pre><code>int fibonacci_iterative(int n) {\n    if (n == 0) {\n        return 0;\n    } else if (n &lt;= 2) {\n        return 1;\n    }\n    int fib;\n    int fib_previous = 1;\n    int fib_previous_2 = 1;\n    for (int i = 3; i &lt;= n; ++i) {\n        fib = fib_previous + fib_previous_2;\n        fib_previous_2 = fib_previous;\n        fib_previous = fib;\n    }\n    return fib;\n}\n</code></pre> Recursive Fibonacci function <pre><code>int fibonacci_recursive(int n) {\n    if (n &gt; 2) {\n        return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2);\n    } else {\n        return n == 0 ? 0 : 1;\n    }\n}\n</code></pre> Iterative and Recursive functions <pre><code>std::cout &lt;&lt; \"fibonacci_iterative(6) = \" &lt;&lt; fibonacci_iterative(6) &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"fibonacci_recursive(6) = \" &lt;&lt; fibonacci_recursive(6) &lt;&lt; '\\n';\n</code></pre> <p>  Share Snippets </p>"},{"location":"basic-syntax/functions/lambda/","title":"Lambda Functions","text":"<p>Lambda functions</p> <p>A lambda is a convenient way of defining an anonymous function object right at the location where it's invoked.</p> <p>Typically lambdas are used to encapsulate a few lines of code that are passed to algorithms to customize their  behavior. </p> Defining a functor manually <pre><code>class add {\n  public:\n    double operator()(double left, double right) { return left + right; }\n};\n</code></pre> Calling a functor <pre><code>// Function objects overload operator() so they act like functions\ndouble number = add()(2, 3);\nstd::cout &lt;&lt; number &lt;&lt; '\\n';\n</code></pre> Keeping inline lambda functions in variables <pre><code>// Automatically creates a functor for the function\nauto function = []() { std::cout &lt;&lt; \"Hello, world! \"; };\n</code></pre> Calling a lambda <pre><code>function();\n</code></pre> Lambdas as arguments <pre><code>// Sort in increasing order\nstd::vector&lt;int&gt; v{4, 3, 1, 2};\nauto comparison = [](int a, int b) { return a &lt; b; };\nstd::sort(v.begin(), v.end(), comparison);\n</code></pre> Lambdas in function calls <pre><code>// Sort in decreasing order\nstd::sort(v.begin(), v.end(), [](int a, int b) { return a &gt; b; });\n// Print each element\nstd::for_each(v.begin(), v.end(),\n              [](const double c) { std::cout &lt;&lt; c &lt;&lt; \" \"; });\nstd::cout &lt;&lt; '\\n';\n</code></pre> Store lambda as std::function <pre><code>std::function&lt;int(int)&gt; func = [](int i) { return i + 10; };\nstd::cout &lt;&lt; \"func(6): \" &lt;&lt; func(6) &lt;&lt; '\\n';\n</code></pre> Capturing values in lambda function <pre><code>// These values are external to the function parameters\nint x = 10;\nstd::function&lt;int(int)&gt; func2 = [x](int i) { return i + x; };\nstd::cout &lt;&lt; \"func2(6): \" &lt;&lt; func2(6) &lt;&lt; '\\n';\n</code></pre> Parameter type deduction <pre><code>auto decreasing_comparison = [](auto a, auto b) { return b &lt; a; };\nstd::vector&lt;double&gt; v2 = {3.6, 3.2, 7.5, 2.4};\nstd::sort(v.begin(), v.end(), decreasing_comparison);\n</code></pre> Binding parameters to the function <pre><code>// Creates new functions from existing functions\n// Create base function my_divide\nauto my_divide = [](double x, double y) { return x / y; };\nstd::cout &lt;&lt; \"my_divide(4,7): \" &lt;&lt; my_divide(4, 7) &lt;&lt; '\\n';\n\n// Make x and y always 10 and 2\n// Function fn_five has no parameters now\nauto fn_five = std::bind(my_divide, 10, 2);\nstd::cout &lt;&lt; \"fn_five(): \" &lt;&lt; fn_five() &lt;&lt; '\\n';\n</code></pre> Bind a single parameter <pre><code>// Function has only one parameter now\nauto fn_half =\n    std::bind(my_divide, std::placeholders::_1, 2); // returns x/2\nstd::cout &lt;&lt; \"fn_half(10): \" &lt;&lt; fn_half(10) &lt;&lt; '\\n';\n</code></pre> Keep parameters and convert the return type <pre><code>auto fn_floor = std::bind&lt;int&gt;(my_divide, std::placeholders::_1,\n                               std::placeholders::_2); // returns int(x/y)\nstd::cout &lt;&lt; \"fn_floor(10,2): \" &lt;&lt; fn_floor(13, 2) &lt;&lt; '\\n';\n</code></pre> Sorting with lambdas <pre><code>std::vector&lt;int&gt; myvector = {32, 71, 12, 45, 26, 80, 53, 33};\nstd::sort(myvector.begin(), myvector.begin() + 4); // uses operator &lt;\nstd::sort(myvector.begin() + 4, myvector.end(),\n          [](auto x, auto y) { return x &gt; y; }); // use operator &gt;\n</code></pre> Checking conditions on all elements <pre><code>// Many algorithms hardly make much sense without lambdas\nstd::vector&lt;int&gt; foo = {3, 5, 7, 11, 13, 17, 19, 23};\nauto is_odd = [](int i) { return i % 2; };\nif (std::all_of(foo.begin(), foo.end(), is_odd)) {\n    std::cout &lt;&lt; \"All the elements are odd numbers.\\n\";\n}\n</code></pre> Check any of elements <pre><code>std::array&lt;int, 7&gt; foo2 = {0, 1, -1, 3, -3, 5, -5};\nif (std::any_of(foo2.begin(), foo2.end(), [](int i) { return i &lt; 0; })) {\n    std::cout &lt;&lt; \"There are negative elements in the range.\\n\";\n}\n</code></pre> Check none of the element <pre><code>std::array&lt;int, 8&gt; foo3 = {1, 2, 4, 8, 16, 32, 64, 128};\nif (std::none_of(foo3.begin(), foo3.end(), [](int i) { return i &lt; 0; })) {\n    std::cout &lt;&lt; \"There are no negative elements in the range.\\n\";\n}\n</code></pre> Find if element <pre><code>std::vector&lt;int&gt; v3 = {10, 25, 40, 55};\nauto it =\n    std::find_if(v3.begin(), v3.end(), [](auto i) { return i % 2 == 1; });\nstd::cout &lt;&lt; \"The first odd value is \" &lt;&lt; *it &lt;&lt; '\\n';\n</code></pre> Removing if element <pre><code>std::vector&lt;int&gt; v4{1, 2, 3, 4, 5, 6, 7};\nauto last = remove_if(v4.begin(), v4.end(), [](int n) { return n &lt; 6; });\nv4.erase(last, v4.end());\n</code></pre> Removing if element <pre><code>x = 5;\nv4.erase(remove_if(v4.begin(), v4.end(), [x](int n) { return n &lt; x; }),\n         v4.end());\n</code></pre> Counting if elements <pre><code>std::vector&lt;int&gt; v5(9);\nstd::iota(v5.begin(), v5.end(), 1);\nint mycount = std::count_if(v5.begin(), v5.end(),\n                            [](int i) { return ((i % 2) == 1); });\nstd::cout &lt;&lt; \"My vector contains \" &lt;&lt; mycount &lt;&lt; \" odd values.\\n\";\n</code></pre> Replacing if match <pre><code>std::vector&lt;int&gt; v6(9);\nstd::iota(v6.begin(), v6.end(), 1);\nreplace_if(\n    v6.begin(), v6.end(), [](int i) { return ((i % 2) == 1); }, 0);\n</code></pre> <p>  Share Snippets </p>"},{"location":"basic-syntax/input-output/format/","title":"Format","text":"<p>About <code>fmt</code>/<code>format</code></p> <ul> <li>fmt/format has been accepted into C++20</li> <li>It has the best of <code>printf</code> and <code>cout</code></li> <li>Many compilers don't implement it yet</li> <li>We still depend on <code>&lt;fmt/format.h&gt;</code></li> </ul> Find and link fmt library <pre><code>find_package(fmt QUIET)\nif (NOT fmt_FOUND)\n    FetchContent_Declare(\n            fmt\n            GIT_REPOSITORY https://github.com/fmtlib/fmt\n            GIT_TAG        8.1.1\n    )\n    FetchContent_MakeAvailable(fmt)\nendif()\nadd_executable(format format.cpp)\ntarget_link_libraries(format fmt::fmt)\n</code></pre> Headers <pre><code>#include &lt;fmt/chrono.h&gt;  // time formatters\n#include &lt;fmt/color.h&gt;   // color formatters\n#include &lt;fmt/format.h&gt;  // main header\n#include &lt;fmt/ostream.h&gt; // ostream formatters\n#include &lt;fmt/ranges.h&gt;  // range formatters\n</code></pre> Simple print <pre><code>fmt::print(\"Hello, world!\\n\");\n</code></pre> Format to string <pre><code>std::cout &lt;&lt; fmt::format(\"The answer is {}.\\n\", 42);\n</code></pre> Format with order <pre><code>std::cout &lt;&lt; fmt::format(\"I'd rather be {1} than {0}.\\n\", \"right\", \"happy\");\n</code></pre> Chrono literals <pre><code>using namespace std::literals::chrono_literals;\nfmt::print(\"Default format: {} {}\\n\", 42s, 100ms);\n</code></pre> strftime-like format <pre><code>fmt::print(\"strftime-like format: {:%H:%M:%S}\\n\", 3h + 15min + 30s);\n</code></pre> Format ranges <pre><code>std::vector&lt;int&gt; v = {1, 2, 3};\nfmt::print(\"{}\\n\", v);\n</code></pre> Format tuple <pre><code>std::tuple&lt;char, int, float&gt; t2{'a', 1, 2.0f};\nfmt::print(\"{}\", t2);\n</code></pre> Color support <pre><code>fmt::print(fg(fmt::color::crimson) | fmt::emphasis::bold, \"Hello, {}!\\n\",\n           \"world\");\nauto style = fg(fmt::color::floral_white) | bg(fmt::color::slate_gray) |\n             fmt::emphasis::underline;\nfmt::print(style, \"Hello, {}!\\n\", \"\u043c\u0438\u0440\");\n</code></pre> UTF-8 <pre><code>print(fg(fmt::color::steel_blue) | fmt::emphasis::italic, \"Hello, {}!\\n\", \"\u4e16\u754c\");\n</code></pre> Format to memory <pre><code>std::vector&lt;char&gt; out;\nfmt::format_to(std::back_inserter(out), \"For a moment, {} happened.\", \"nothing\");\nfmt::print(\"{}\", out.data());\n</code></pre> <p>  Share Snippets </p>"},{"location":"basic-syntax/input-output/hello-world/","title":"Hello World","text":"Your first C++ programCMakeLists.txt <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    std::cout &lt;&lt; \"Hello world\" &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre> <pre><code>add_executable(hello_world hello_world.cpp)\n</code></pre>"},{"location":"basic-syntax/input-output/input/","title":"Input","text":"Headers <pre><code>#include &lt;iostream&gt;\n</code></pre> User input <pre><code>int age;\nstd::cout &lt;&lt; \"How old are you? \";\nstd::cin &gt;&gt; age;\n</code></pre> User input (Handling error) <pre><code>std::cout &lt;&lt; \"How old are you again? \";\nif (!(std::cin &gt;&gt; age)) {\n    std::cout &lt;&lt; \"There is an error in your input\\n\";\n    return 1;\n}\n</code></pre> Consuming input <pre><code>if (age &gt;= 18) {\n    std::cout &lt;&lt; \"Welcome!\\n\";\n} else {\n    std::cout &lt;&lt; \"Sorry.\\n\";\n    return 1;\n}\n</code></pre> <p>  Share Snippets </p>"},{"location":"basic-syntax/input-output/output/","title":"Output","text":"printf <pre><code>printf(\"Sorry.\");\n</code></pre> std::cout <pre><code>std::cout &lt;&lt; \"Sorry.\" &lt;&lt; '\\n';\n</code></pre> Flushing std::cout <pre><code>std::cout &lt;&lt; \"Sorry.\" &lt;&lt; std::endl;\n</code></pre> printf with parameters <pre><code>printf(\"Welcome! You are %d years old.\", age);\n</code></pre> std::cout with parameters <pre><code>std::cout &lt;&lt; \"Welcome! You are \" &lt;&lt; age &lt;&lt; \" years old.\" &lt;&lt; '\\n';\n</code></pre> Flushing std::cout with parameters <pre><code>std::cout &lt;&lt; \"Welcome! You are \" &lt;&lt; age &lt;&lt; \" years old.\" &lt;&lt; std::endl;\n</code></pre> <p>  Share Snippets </p> <p>Some people told me <code>std::endl</code> is evil. Is that true?</p> <p>Introductory snippets usually use <code>std::endl</code> instead of <code>'\\n'</code>, while some guides recommend always using <code>'\\n'</code>.</p> <ul> <li>Flushing with <code>std::endl</code> does have a semantic meaning    different from <code>'\\n</code>, which is a nice convention for small snippets</li> <li><code>std::endl</code> means \"please include a line break in the buffer and show me what's in the output buffer right now\"</li> <li><code>'\\n'</code> means \"please include a line break in the buffer\"</li> </ul> <p>The reason people correctly say that <code>std::endl</code> costs more than <code>'\\n'</code>. But it costs more because it does not do the same thing. It exists for a reason. There are some situations  where it makes sense to flush the stream. What's important is to be informed about what it does and how much it costs.</p> <ul> <li>When not working with files, which in the common scenario of introductory snippets, the time difference between   flushing <code>std::cout</code> to the console (not files!) tends to be negligible</li> <li>Almost no application is spending more time flushing than calculating things to flush. Unless it's a   flushing benchmark.</li> </ul> <p>On the other hand, some people will simply say <code>std::endl</code> is evil, but this is misleading. They are usually  generalizing from benchmarks that explore specific edge cases to prove a point. These benchmarks are usually meant to show the difference between <code>'\\n'</code> and <code>std::endl</code> and not as proof that <code>std::endl</code> is evil per se, or  significantly more expensive than <code>'\\n'</code> in all possible use cases.</p> <p>We can't tell you which is better because they do different things. But we can tell you their differences and their cost:</p> <ul> <li>The definitions:<ul> <li>The buffer: The streams usually store the data in a buffer, which is meant to make things more efficient.      The buffer reduces the number of trips to their final destination.</li> <li>Flushing: Once the buffer is full, then the data goes to its final destination, which is usually the console     or a file. For convenience, when that happens, we say the stream is flushing the buffer.</li> <li>Commands: C++ gives you the option to flush what is in the buffer immediately or you might wait for the      stream to flush automatically according to some internal heuristic.</li> <li>Automatically flushing: This heuristic is usually when the buffer is full, or when the buffer is about to     be destructed. Sometimes, it flushes automatically when it sees a new line. That depends on the implementation.</li> </ul> </li> <li>What the commands mean: <ul> <li>Flushing does have a semantic meaning different from <code>'\\n'</code>, and this might be a good convention for some      pieces of code, especially when you want to make sure you will see the output immediately, particularly for      <code>std::cout</code>.</li> <li><code>'\\n'</code> means \"put a newline in the buffer\"</li> <li><code>std::flush</code> means \"show me what's in the buffer now\"</li> <li><code>std::endl</code> means \"put a newline in the buffer and then show me what's in the buffer now\"</li> </ul> </li> <li>Their cost: <ul> <li>By the definition above, <code>std::endl</code> logically costs more than <code>'\\n'</code> because it's doing what <code>'\\n'</code> does     plus one more thing. Some people often use examples and benchmarks flushing files as evidence that      <code>std::endl</code> is evil per se. But there's a catch here:</li> <li>There's very little reason to flush to files because we don't usually care if the data gets in the file a     little later.</li> <li>Flushing to files is much more comparatively expensive than flushing to <code>std::cout</code>.</li> <li>If you benchmark this difference, you will see the time difference of flushing <code>std::cout</code> to the console     (not files!) is negligible:<ul> <li>GCC -O2: Flush: 2.32234e-06 / Don't Flush: 2.26303e-06</li> <li>Clang -O2: Flush: 2.33343e-06 / Don't Flush: 2.23031e-06</li> </ul> </li> <li>Besides this small difference, flushing to console is much more likely to be useful than flushing to a file.</li> <li>Also, this difference is almost certainly smaller in a real application. Almost no application is spending     more time flushing than calculating things to flush. Unless it's a flushing benchmark like the one above.</li> </ul> </li> </ul> <p>In the end, flushing to a file is almost always a bad idea. Flushing to the console won't probably have any  significant impact on performance. In that second case, if not flushing can cause you any problems, just flush.</p>"},{"location":"basic-syntax/pointers/address-operator/","title":"Address Operator","text":"<p>Address Operator</p> <p>An address-of operator is a mechanism within C++ that returns the memory address of a variable. These addresses  returned by the address-of operator are known as pointers, because they \"point\" to the variable in memory.</p> Print variable and its address <pre><code>int a = 10;\ncout &lt;&lt; \"a: \" &lt;&lt; a &lt;&lt; '\\n';\ncout &lt;&lt; \"&amp;a (hex): \" &lt;&lt; &amp;a &lt;&lt; '\\n';\ncout &lt;&lt; \"&amp;a: (dec) \" &lt;&lt; reinterpret_cast&lt;uintptr_t&gt;(&amp;a) &lt;&lt; '\\n';\n</code></pre> Create another stack variable <pre><code>int b = 10;\ncout &lt;&lt; \"b: \" &lt;&lt; b &lt;&lt; '\\n';\ncout &lt;&lt; \"&amp;b (hex): \" &lt;&lt; &amp;b &lt;&lt; '\\n';\ncout &lt;&lt; \"&amp;b: (dec) \" &lt;&lt; reinterpret_cast&lt;uintptr_t&gt;(&amp;b) &lt;&lt; '\\n';\n</code></pre> Create a value in the heap <pre><code>auto c = std::make_unique&lt;int&gt;(10);\ncout &lt;&lt; \"*c: \" &lt;&lt; *c &lt;&lt; '\\n';\ncout &lt;&lt; \"c (hex): \" &lt;&lt; c &lt;&lt; '\\n'; // address should be distant from a and b\ncout &lt;&lt; \"c: (dec) \" &lt;&lt; reinterpret_cast&lt;uintptr_t&gt;(c.get()) &lt;&lt; '\\n';\n</code></pre> Distance between two stack variables <pre><code>cout &lt;&lt; \"Distance &amp;b - &amp;a = \" &lt;&lt; &amp;b - &amp;a &lt;&lt; \" ints\\n\";\ncout &lt;&lt; \"Distance &amp;b - &amp;a = \" &lt;&lt; reinterpret_cast&lt;unsigned char*&gt;(&amp;b) - reinterpret_cast&lt;unsigned char*&gt;(&amp;a) &lt;&lt; \" bytes\\n\";\n</code></pre> Distance between stack and heap variables <pre><code>cout &lt;&lt; \"Distance c.get() - &amp;a = \" &lt;&lt; c.get() - &amp;a &lt;&lt; \" ints\\n\";\ncout &lt;&lt; \"Distance c.get() - &amp;a = \" &lt;&lt; reinterpret_cast&lt;unsigned char*&gt;(c.get()) - reinterpret_cast&lt;unsigned char*&gt;(&amp;a) &lt;&lt; \" bytes\\n\";\n</code></pre> <p>  Share Snippets </p>"},{"location":"basic-syntax/pointers/build-script/","title":"Build script","text":"<pre><code>add_executable(address_operator address_operator.cpp)\n\nadd_executable(raw_pointers raw_pointers.cpp)\n\nadd_executable(references references.cpp)\n\nadd_executable(smart_pointers smart_pointers.cpp)\n</code></pre>"},{"location":"basic-syntax/pointers/raw-pointers/","title":"Raw pointers","text":"<p>Raw pointers</p> <p>A pointer is a type of variable. It stores the address of an object in memory, and is used to access that object.  A raw pointer is a pointer whose lifetime isn't controlled by an encapsulating object, such as a smart pointer.</p> <p>Raw pointers might be dangerous. Try to avoid them.</p> Pointer to an int on the heap <pre><code>int *x = new int(5);\n</code></pre> Print pointer address <pre><code>std::cout &lt;&lt; \"x: \" &lt;&lt; x &lt;&lt; '\\n';\n</code></pre> Print pointed value if any <pre><code>if (x) {\n    std::cout &lt;&lt; \"*x: \" &lt;&lt; *x &lt;&lt; '\\n';\n} else {\n    std::cout &lt;&lt; \"*x: empty\" &lt;&lt; '\\n';\n}\n</code></pre> Delete value pointed <pre><code>// - Forgetting to delete causes memory leaks\n// - Forgetting to update to nullptr might lead to segmentation faults\n// - Use smart pointers to delete the data automatically\ndelete x;\nx = nullptr;\n</code></pre> Raw dynamic arrays <pre><code>// - This is what existed before vectors\n// - Point to a sequence of values\n// - Always use vectors instead of this\n// - If you need to access the raw data, use vector::data()\nint *x2 = new int[10];\nfor (int i2 = 0; i2 &lt; 10; ++i2) {\n    x2[i2] = 10 + i2 * 10;\n}\n</code></pre> Print addresses <pre><code>std::cout &lt;&lt; \"x2: \" &lt;&lt; x2 &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"&amp;x2[0]: \" &lt;&lt; &amp;x2[0] &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"x2[0]: \" &lt;&lt; x2[0] &lt;&lt; '\\n';\n</code></pre> Points to the first number in the sequence <pre><code>std::cout &lt;&lt; \"*x2: \" &lt;&lt; *x2 &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"x2[3]: \" &lt;&lt; x2[3] &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"*(x2+3): \" &lt;&lt; *(x2 + 3) &lt;&lt; '\\n';\n</code></pre> Deallocate sequence <pre><code>// - Slightly different command: more danger\ndelete[] x2;\nx2 = nullptr;\n</code></pre> <p>  Share Snippets </p>"},{"location":"basic-syntax/pointers/references/","title":"References","text":"<p>References</p> <ul> <li>They solve some problems with raw pointers</li> <li>Once initialized, a reference cannot be changed. This makes them less dangerous.</li> <li>Instead of \"pointing\" to an address, a reference only \"refers\" to a fixed address / variable</li> </ul> References to stack value <pre><code>int n = 1;\nint &amp;r1 = n;\nint &amp;r2 = r1;\nint &amp;r3 = n;\n</code></pre> References as aliases <pre><code>std::cout &lt;&lt; \"n: \" &lt;&lt; n &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"r1: \" &lt;&lt; r1 &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"r2: \" &lt;&lt; r2 &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"r3: \" &lt;&lt; r3 &lt;&lt; '\\n';\n</code></pre> Reference to array <pre><code>int ar[3];\nint(&amp;ra)[3] = ar;\n</code></pre> Reference as array alias <pre><code>std::cout &lt;&lt; \"ar: \" &lt;&lt; ar &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"ra: \" &lt;&lt; ra &lt;&lt; '\\n';\n</code></pre> Reference to pointer <pre><code>int *p = new int(3);\nint *&amp;ppr = p;\n</code></pre> Reference as array alias <pre><code>std::cout &lt;&lt; \"ar: \" &lt;&lt; ar &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"ra: \" &lt;&lt; ra &lt;&lt; '\\n';\n</code></pre> Reference to value pointed by p <pre><code>int &amp;prr = *p;\nstd::cout &lt;&lt; \"prr: \" &lt;&lt; prr &lt;&lt; '\\n';\n</code></pre> Deleting pointer is not the responsibility of the reference <pre><code>delete p;\n// ppr and prr are now dangling references\n</code></pre> <p>  Share Snippets </p>"},{"location":"basic-syntax/pointers/smart-pointers/","title":"Smart pointers","text":"<p>Smart pointers</p> <p>Use smart pointers instead of raw pointer whenever possible:</p> <ul> <li>But you can't do it without understanding raw pointers</li> <li>Recur to raw non-owning pointers if they are needed</li> </ul> <p>In general, use:</p> <p>1) No pointers at all</p> <p>2) Raw non-owning pointers or references if they are needed</p> <p>3) Smart pointers IF owning pointers can not be averted</p> <p>4) Owning raw pointers if you know exactly what you are doing        and need them (e.g. interfacing with C code).</p> <p>There are 2 important types of smart pointers:</p> <ul> <li>Unique pointer: <ul> <li>Only one pointer can point to an address</li> <li>Deletes data automatically when the pointer is destroyed</li> </ul> </li> <li>Shared pointer: <ul> <li>More than one pointer can point to the same address</li> <li>Deletes data automatically when the last pointer is destroyed</li> <li>More expensive than unique pointers</li> </ul> </li> </ul> Unique pointer with no pointed value <pre><code>// Only one unique pointer can point to an address\nstd::unique_ptr&lt;int&gt; c;\nif (c) {\n    std::cout &lt;&lt; \"*c : \" &lt;&lt; *c &lt;&lt; '\\n';\n} else {\n    std::cout &lt;&lt; \"c is empty\" &lt;&lt; '\\n';\n}\n</code></pre> Changing value of unique pointer <pre><code>// Previous value is deleted if needed\nc = std::make_unique&lt;int&gt;(2);\nif (c) {\n    std::cout &lt;&lt; \"*c : \" &lt;&lt; *c &lt;&lt; '\\n';\n} else {\n    std::cout &lt;&lt; \"c is empty\" &lt;&lt; '\\n';\n}\n</code></pre> Initialize unique pointer with value <pre><code>auto c2 = std::make_unique&lt;int&gt;(3);\n</code></pre> Swap unique pointers <pre><code>// Swapping values is valid\nc.swap(c2);\n// c = c2; &lt;- but copying doesn't work\n</code></pre> Moving values is valid <pre><code>c = std::move(c2);\nif (c) {\n    std::cout &lt;&lt; \"New *c : \" &lt;&lt; *c &lt;&lt; '\\n';\n} else {\n    std::cout &lt;&lt; \"c is empty\" &lt;&lt; '\\n';\n}\n</code></pre> Create shared pointer <pre><code>auto sp = std::make_shared&lt;int&gt;(2);\nif (sp) {\n    std::cout &lt;&lt; \"New *sp : \" &lt;&lt; *sp &lt;&lt; '\\n';\n} else {\n    std::cout &lt;&lt; \"sp is empty\" &lt;&lt; '\\n';\n}\n</code></pre> Share pointed value <pre><code>std::shared_ptr&lt;int&gt; sp2 = sp;\n*sp2 = 3;\nif (sp) {\n    std::cout &lt;&lt; \"New *sp : \" &lt;&lt; *sp &lt;&lt; '\\n'; // 3\n} else {\n    std::cout &lt;&lt; \"sp is empty\" &lt;&lt; '\\n';\n}\nif (sp2) {\n    std::cout &lt;&lt; \"New *sp2 : \" &lt;&lt; *sp &lt;&lt; '\\n'; // 3\n} else {\n    std::cout &lt;&lt; \"sp2 is empty\" &lt;&lt; '\\n';\n}\n\n//[count Count number of shared pointers\n// How many pointers are pointing to this number?\nstd::cout &lt;&lt; \"There are \" &lt;&lt; sp.use_count() &lt;&lt; \" pointers to \" &lt;&lt; sp.get()\n          &lt;&lt; '\\n';\n</code></pre> Count number of shared pointers <pre><code>// How many pointers are pointing to this number?\nstd::cout &lt;&lt; \"There are \" &lt;&lt; sp.use_count() &lt;&lt; \" pointers to \" &lt;&lt; sp.get()\n          &lt;&lt; '\\n';\n</code></pre> <p>  Share Snippets </p>"},{"location":"cmake-functions/project-flags/","title":"Project Flags","text":"Set variable indicating if this is a master project <pre><code>if (${CMAKE_CURRENT_SOURCE_DIR} STREQUAL ${CMAKE_SOURCE_DIR})\n    set(MASTER_PROJECT ON)\nelse ()\n    set(MASTER_PROJECT OFF)\nendif ()\n</code></pre> Set variables indicating if mode is Debug or Release <pre><code>if (CMAKE_BUILD_TYPE STREQUAL \"Debug\")\n    set(DEBUG_MODE ON)\n    set(NOT_DEBUG_MODE OFF)\n    set(RELEASE_MODE OFF)\n    set(NOT_RELEASE_MODE ON)\nelse ()\n    set(DEBUG_MODE OFF)\n    set(NOT_DEBUG_MODE ON)\n    set(RELEASE_MODE ON)\n    set(NOT_RELEASE_MODE OFF)\nendif ()\n</code></pre> Create booleans GCC and CLANG to identify the compiler more easily <pre><code>set(CLANG OFF)\nset(GCC OFF)\nif (CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\" OR CMAKE_CXX_COMPILER_ID STREQUAL \"AppleClang\")\n    set(CLANG ON)\nelseif (CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\")\n    set(GCC ON)\nendif ()\n</code></pre> Set the default optimization flags <pre><code># This will set the flags only if the user didn't explicitly choose them with -DCMAKE_CXX_FLAGS\nif (NOT CMAKE_CXX_FLAGS)\n    if (CMAKE_BUILD_TYPE STREQUAL \"Debug\")\n        if (MSVC)\n            list(APPEND CMAKE_CXX_FLAGS \"/O0\")\n        else ()\n            list(APPEND CMAKE_CXX_FLAGS \"-O0\")\n        endif ()\n    else ()\n        if (MSVC)\n            list(APPEND CMAKE_CXX_FLAGS \"/O2\")\n        else ()\n            list(APPEND CMAKE_CXX_FLAGS \"-O2\")\n        endif ()\n    endif ()\n    message(\"Setting CXX flags to default for ${CMAKE_BUILD_TYPE} mode (${CMAKE_CXX_FLAGS})\")\nelse ()\n    message(\"CXX flags are already set to ${CMAKE_CXX_FLAGS}\")\nendif ()\n</code></pre> <p>  Share Snippets </p>"},{"location":"cmake-functions/qt-helpers/","title":"Qt Helpers","text":"Try to find and add the QT directories to CMAKE_PREFIX_PATH <pre><code># This script looks for Qt5 only\n# - Change this variable to adapt the script\nset(QT_VERSION 5)\n\n# Reasonable paths to look for Qt\nset(QT_PATH_HINTS\n        /usr/local/qt/\n        /usr/local/Cellar/qt/\n        \"C:\\\\Qt\\\\\"\n        )\n\n# Reasonable paths to look for the Qt CMake scripts\nset(QT_CMAKE_PATH_POSTFIX_HINTS\n        lib/cmake/\n        lib/cmake/Qt${QT_VERSION}\n        )\n\n# Look for Qt paths\nforeach (QT_PATH_HINT ${QT_PATH_HINTS})\n    if (EXISTS ${QT_PATH_HINT} AND IS_DIRECTORY ${QT_PATH_HINT})\n        message(\"Found Qt hint path ${QT_PATH_HINT}\")\n        # Explore children directories\n        file(GLOB QT_PATH_HINT_CHILDREN RELATIVE ${QT_PATH_HINT} ${QT_PATH_HINT}/*)\n        foreach (QT_PATH_HINT_CHILD ${QT_PATH_HINT_CHILDREN})\n            set(FULL_QT_PATH_HINT_CHILD ${QT_PATH_HINT}${QT_PATH_HINT_CHILD})\n            if (IS_DIRECTORY ${FULL_QT_PATH_HINT_CHILD})\n                message(\"Found child directory ${FULL_QT_PATH_HINT_CHILD}\")\n                # Check if it matches the pattern of version numbers\n                if (QT_PATH_HINT_CHILD MATCHES \"[0-9]+\\\\.?[0-9]*\\\\.?[0-9]*\")\n                    message(\"${QT_PATH_HINT_CHILD} follows the version pattern\")\n                    if (NOT ${FULL_QT_PATH_HINT_CHILD} IN_LIST CMAKE_PREFIX_PATH)\n                        message(\"Adding new Qt hint child ${FULL_QT_PATH_HINT_CHILD} to CMAKE_PREFIX_PATH\")\n                        list(APPEND CMAKE_PREFIX_PATH ${FULL_QT_PATH_HINT_CHILD})\n                    endif ()\n                    # Explore possible path postfixes for CMake scripts\n                    foreach (QT_CMAKE_PATH_POSTFIX_HINT ${QT_CMAKE_PATH_POSTFIX_HINTS})\n                        set(FULL_QT_CMAKE_PATH ${FULL_QT_PATH_HINT_CHILD}/${QT_CMAKE_PATH_POSTFIX_HINT})\n                        message(\"Testing ${FULL_QT_CMAKE_PATH}\")\n                        if (EXISTS ${FULL_QT_CMAKE_PATH} AND IS_DIRECTORY ${FULL_QT_CMAKE_PATH})\n                            message(\"Found ${FULL_QT_CMAKE_PATH}\")\n                            if (NOT ${FULL_QT_CMAKE_PATH} IN_LIST CMAKE_PREFIX_PATH)\n                                message(\"Adding ${FULL_QT_CMAKE_PATH} to CMAKE_PREFIX_PATH\")\n                                list(APPEND CMAKE_PREFIX_PATH ${FULL_QT_CMAKE_PATH})\n                            else ()\n                                message(\"Already found ${FULL_QT_CMAKE_PATH} in CMAKE_PREFIX_PATH\")\n                            endif ()\n                        endif ()\n                    endforeach ()\n                endif ()\n            endif ()\n        endforeach ()\n    endif ()\nendforeach ()\n</code></pre> <p>  Share Snippets </p>"},{"location":"cmake-functions/sanitizers/","title":"Sanitizers","text":"Add sanitizer flag to all targets <pre><code>include(CheckCXXCompilerFlag)\nif (CMAKE_CXX_COMPILER_ID MATCHES \"Clang\" OR CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\" OR CMAKE_CXX_COMPILER_ID STREQUAL \"AppleClang\")\n    message(\"Looking for -fsanitize=${flag}\")\n    set(CMAKE_REQUIRED_FLAGS \"-Werror -fsanitize=${flag}\")\n    check_cxx_compiler_flag(-fsanitize=${flag} HAVE_FLAG_SANITIZER)\n    if (HAVE_FLAG_SANITIZER)\n        message(\"Adding -fsanitize=${flag}\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -fsanitize=${flag} -fno-omit-frame-pointer\")\n        set(DCMAKE_C_FLAGS \"${DCMAKE_C_FLAGS} -fsanitize=${flag} -fno-omit-frame-pointer\")\n        set(CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} -fsanitize=${flag}\")\n        set(DCMAKE_MODULE_LINKER_FLAGS \"${DCMAKE_MODULE_LINKER_FLAGS} -fsanitize=${flag}\")\n    else ()\n        message(\"-fsanitize=${flag} unavailable\")\n    endif ()\nendif ()\n</code></pre> Add address sanitizer to all targets <pre><code>add_sanitizer(\"address\")\n</code></pre> Add thread sanitizer to all targets <pre><code>add_sanitizer(\"thread\")\n</code></pre> Add undefined sanitizer to all targets <pre><code>add_sanitizer(\"undefined\")\n</code></pre> Add memory sanitizer to all targets <pre><code>add_sanitizer(\"memory\")\n</code></pre> Add leak sanitizer to all targets <pre><code>add_sanitizer(\"leak\")\n</code></pre> Add all sanitizers to all targets <pre><code># Choose a subset of sanitizers not in conflict\nadd_address_sanitizer()\nadd_leak_sanitizer()\nadd_undefined_sanitizer()\n# not allowed with address sanitizer\n# add_thread_sanitizer()\n# not supported\n# add_memory_sanitizer()\n</code></pre> <p>  Share Snippets </p>"},{"location":"cmake-functions/target-options/","title":"Target Options","text":"Enable pedantic warnings for a target <pre><code># Set warning levels to about the same level for MSVC, GCC, and Clang\nif (MSVC)\n    target_compile_options(${TARGET_NAME} PRIVATE /W4 /WX)\nelse ()\n    target_compile_options(${TARGET_NAME} PRIVATE -Wall -Wextra -pedantic -Werror)\nendif ()\n</code></pre> Enable pedantic warnings for a target <pre><code># Set warning levels to about the same level for MSVC, GCC, and Clang\nif (MSVC)\n    target_compile_options(${TARGET_NAME} PRIVATE /W4 /WX)\nelse ()\n    target_compile_options(${TARGET_NAME} PRIVATE -Wall -Wextra -pedantic -Werror)\nendif ()\n</code></pre> <p>  Share Snippets </p>"},{"location":"guis/imgui/","title":"ImGUI","text":"Find OpenGL <pre><code>find_package(OpenGL)\n</code></pre> Fetch GLAD <pre><code>FetchContent_Declare(glad GIT_REPOSITORY https://github.com/Dav1dde/glad.git GIT_TAG df8e9e16110b305479a875399cee13daa0ccadd9)\nFetchContent_MakeAvailable(glad)\n</code></pre> Fetch GLFW <pre><code>set(GLFW_BUILD_DOCS OFF CACHE BOOL \"\" FORCE)\nset(GLFW_BUILD_EXAMPLES OFF CACHE BOOL \"\" FORCE)\nset(GLFW_BUILD_TESTS OFF CACHE BOOL \"\" FORCE)\nset(GLFW_INSTALL OFF CACHE BOOL \"\" FORCE)\nFetchContent_Declare(glfw GIT_REPOSITORY https://github.com/glfw/glfw.git GIT_TAG 3.3.2)\nFetchContent_MakeAvailable(glfw)\n</code></pre> Fetch ImGUI <pre><code>FetchContent_Declare(\n        imgui\n        GIT_REPOSITORY https://github.com/ocornut/imgui.git\n        GIT_TAG v1.77\n)\nFetchContent_GetProperties(imgui)\nif (NOT imgui_POPULATED)\n    FetchContent_Populate(imgui)\n    set(IMGUI_INCLUDE_DIR ${imgui_SOURCE_DIR}/)\n    file(GLOB IMGUI_SOURCES ${imgui_SOURCE_DIR}/*.cpp)\n    file(GLOB IMGUI_HEADERS ${imgui_SOURCE_DIR}/*.h)\n    add_library(imgui STATIC ${IMGUI_SOURCES} ${IMGUI_SOURCES} ${imgui_SOURCE_DIR}/examples/imgui_impl_glfw.cpp ${imgui_SOURCE_DIR}/examples/imgui_impl_opengl3.cpp)\n    add_definitions(-DIMGUI_IMPL_OPENGL_LOADER_GLAD)\n</code></pre> Link ImGUI <pre><code>    target_include_directories(imgui PUBLIC ${IMGUI_INCLUDE_DIR} ${OPENGL_INCLUDE_DIR} ${GLFW_INCLUDE_DIR} ${GLAD_INCLUDE_DIR})\n    target_link_libraries(imgui ${OPENGL_LIBRARIES} glfw glad)\nendif ()\n</code></pre> <p>  Share Snippets </p> Headers <pre><code>#include \"imgui.h\"\n</code></pre> GLFW backend headers <pre><code>#include \"examples/imgui_impl_glfw.h\"\n#include \"examples/imgui_impl_opengl3.h\"\n</code></pre> Load OpenGL functions <pre><code>#if defined(IMGUI_IMPL_OPENGL_LOADER_GL3W)\n#include &lt;GL/gl3w.h&gt; // Initialize with gl3wInit()\n#elif defined(IMGUI_IMPL_OPENGL_LOADER_GLEW)\n#include &lt;GL/glew.h&gt; // Initialize with glewInit()\n#elif defined(IMGUI_IMPL_OPENGL_LOADER_GLAD)\n#include &lt;glad/glad.h&gt; // Initialize with gladLoadGL()\n#elif defined(IMGUI_IMPL_OPENGL_LOADER_GLBINDING2)\n#define GLFW_INCLUDE_NONE // GLFW including OpenGL headers causes ambiguity or\n                          // multiple definition errors.\n#include &lt;glbinding/Binding.h&gt; // Initialize with glbinding::Binding::initialize()\n#include &lt;glbinding/gl/gl.h&gt;\n</code></pre> Setup window <pre><code>    glfwSetErrorCallback(glfw_error_callback);\n    if (!glfwInit())\n        return 1;\n\n        // Decide GL+GLSL versions\n#if __APPLE__\n    // GL 3.2 + GLSL 150\n    const char *glsl_version = \"#version 150\";\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 2);\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); // 3.2+ only\n    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); // Required on Mac\n#else\n    // GL 3.0 + GLSL 130\n    const char *glsl_version = \"#version 130\";\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 0);\n    // glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);  // 3.2+\n    // only glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); // 3.0+ only\n#endif\n\n    // Create window with graphics context\n    GLFWwindow *window = glfwCreateWindow(\n        1280, 720, \"Dear ImGui GLFW+OpenGL3 example\", NULL, NULL);\n    if (window == NULL)\n        return 1;\n    glfwMakeContextCurrent(window);\n    glfwSwapInterval(1); // Enable vsync\n</code></pre> Setup Dear ImGui context <pre><code>IMGUI_CHECKVERSION();\nImGui::CreateContext();\nImGuiIO &amp;io = ImGui::GetIO();\n(void)io;\n// io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;     // Enable\n// Keyboard Controls io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad; //\n// Enable Gamepad Controls\n\n// Setup Dear ImGui style\nImGui::StyleColorsDark();\n// ImGui::StyleColorsClassic();\n\n// Setup Platform/Renderer bindings\nImGui_ImplGlfw_InitForOpenGL(window, true);\nImGui_ImplOpenGL3_Init(glsl_version);\n</code></pre> Start the Dear ImGui frame for the iteration <pre><code>ImGui_ImplOpenGL3_NewFrame();\nImGui_ImplGlfw_NewFrame();\nImGui::NewFrame();\n</code></pre> Render demo <pre><code>if (show_demo_window)\n    ImGui::ShowDemoWindow(&amp;show_demo_window);\n</code></pre> Rendering <pre><code>ImGui::Render();\nint display_w, display_h;\nglfwGetFramebufferSize(window, &amp;display_w, &amp;display_h);\nglViewport(0, 0, display_w, display_h);\nglClearColor(clear_color.x, clear_color.y, clear_color.z,\n             clear_color.w);\nglClear(GL_COLOR_BUFFER_BIT);\nImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());\n</code></pre> Cleanup <pre><code>ImGui_ImplOpenGL3_Shutdown();\nImGui_ImplGlfw_Shutdown();\nImGui::DestroyContext();\n</code></pre> <p>  Share Snippets </p>"},{"location":"guis/opengl-glfw/","title":"SDL","text":"Find OpenGL <pre><code>find_package(OpenGL)\n</code></pre> Fetch GLAD <pre><code>FetchContent_Declare(glad GIT_REPOSITORY https://github.com/Dav1dde/glad.git GIT_TAG df8e9e16110b305479a875399cee13daa0ccadd9)\nFetchContent_MakeAvailable(glad)\n</code></pre> Fetch GLFW <pre><code>set(GLFW_BUILD_DOCS OFF CACHE BOOL \"\" FORCE)\nset(GLFW_BUILD_EXAMPLES OFF CACHE BOOL \"\" FORCE)\nset(GLFW_BUILD_TESTS OFF CACHE BOOL \"\" FORCE)\nset(GLFW_INSTALL OFF CACHE BOOL \"\" FORCE)\nFetchContent_Declare(glfw GIT_REPOSITORY https://github.com/glfw/glfw.git GIT_TAG 3.3.2)\nFetchContent_MakeAvailable(glfw)\n</code></pre> Link GLFW <pre><code>add_executable(opengl_hello opengl_hello.cpp)\ntarget_link_libraries(opengl_hello PUBLIC glad glfw)\n</code></pre> <p>  Share Snippets </p> Headers <pre><code>#include &lt;glad/glad.h&gt;\n#include &lt;GLFW/glfw3.h&gt;\n</code></pre> Declare callback functions <pre><code>void framebuffer_size_callback(GLFWwindow *window, int width, int height);\nvoid processInput(GLFWwindow *window);\n</code></pre> Initialize GLFW <pre><code>    glfwInit();\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n\n#ifdef __APPLE__\n    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);\n#endif\n</code></pre> Create window <pre><code>const unsigned int SCR_WIDTH = 800;\nconst unsigned int SCR_HEIGHT = 600;\n\nGLFWwindow *window =\n    glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, \"LearnOpenGL\", NULL, NULL);\nif (window == NULL) {\n    std::cout &lt;&lt; \"Failed to create GLFW window\" &lt;&lt; std::endl;\n    glfwTerminate();\n    return -1;\n}\nglfwMakeContextCurrent(window);\nglfwSetFramebufferSizeCallback(window, framebuffer_size_callback);\n</code></pre> Load OpenGL function pointers <pre><code>if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) {\n    std::cout &lt;&lt; \"Failed to initialize GLAD\" &lt;&lt; std::endl;\n    return -1;\n}\n</code></pre> Start render loop <pre><code>while (!glfwWindowShouldClose(window)) {\n</code></pre> Process input <pre><code>processInput(window);\n</code></pre> Render <pre><code>glClearColor(0.2f, 0.3f, 0.3f, 1.0f);\nglClear(GL_COLOR_BUFFER_BIT);\n</code></pre> Swap buffer and poll events <pre><code>    glfwSwapBuffers(window);\n    glfwPollEvents();\n}\n</code></pre> Terminate GLFW <pre><code>glfwTerminate();\n</code></pre> Function to process input <pre><code>void processInput(GLFWwindow *window) {\n    if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)\n        glfwSetWindowShouldClose(window, true);\n}\n</code></pre> Function to process window resize <pre><code>void framebuffer_size_callback([[maybe_unused]] GLFWwindow *window, int width, int height) {\n    // make sure the viewport matches the new window dimensions; note that width\n    // and height will be significantly larger than specified on retina\n    // displays.\n    glViewport(0, 0, width, height);\n}\n</code></pre> <p>  Share Snippets </p>"},{"location":"guis/opengl-sdl/","title":"SDL","text":"Find SDL <pre><code>find_package(SDL2 QUIET)\n</code></pre> Find GLAD <pre><code>if (SDL2_FOUND)\n    if (NOT TARGET glad AND EXPECTED_COMPILER)\n        FetchContent_Declare(glad GIT_REPOSITORY https://github.com/Dav1dde/glad.git GIT_TAG df8e9e16110b305479a875399cee13daa0ccadd9)\n        FetchContent_MakeAvailable(glad)\n    endif ()\n</code></pre> Link SDL <pre><code>    if (SDL2_FOUND AND EXPECTED_COMPILER)\n        add_executable(sdl_hello sdl_hello.cpp)\n        target_link_libraries(sdl_hello PUBLIC ${SDL2_LIBRARIES} glad)\n        target_include_directories(sdl_hello PRIVATE ${SDL2_INCLUDE_DIRS})\n    endif ()\nendif ()\n</code></pre> <p>  Share Snippets </p> Headers <pre><code>#include &lt;glad/glad.h&gt;\n// SDL\n#include &lt;SDL.h&gt;\n#include &lt;SDL_syswm.h&gt;\n\n#if defined(__APPLE__)\n#include \"TargetConditionals.h\"\n#endif\n</code></pre> Setup SDL <pre><code>// (Some versions of SDL before &lt;2.0.10 appears to have performance/stalling\n// issues on a minority of Windows systems, depending on whether\n// SDL_INIT_GAMECONTROLLER is enabled or disabled.. updating to latest\n// version of SDL is recommended!)\nif (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_TIMER | SDL_INIT_GAMECONTROLLER) !=\n    0) {\n    printf(\"Error: %s\\n\", SDL_GetError());\n    return -1;\n}\n</code></pre> Decide GL+GLSL versions <pre><code>#if __APPLE__\n    // GL 3.2 Core + GLSL 150\n    // const char *glsl_version = \"#version 150\";\n    SDL_GL_SetAttribute(\n        SDL_GL_CONTEXT_FLAGS,\n        SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG); // Always required on Mac\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK,\n                        SDL_GL_CONTEXT_PROFILE_CORE);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 2);\n#else\n    // GL 3.0 + GLSL 130\n    const char *glsl_version = \"#version 130\";\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, 0);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK,\n                        SDL_GL_CONTEXT_PROFILE_CORE);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 0);\n#endif\n</code></pre> Create window with graphics context <pre><code>SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);\nSDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);\nSDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 8);\nSDL_WindowFlags window_flags = (SDL_WindowFlags)(\n    SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE | SDL_WINDOW_ALLOW_HIGHDPI);\n\nSDL_Window *window =\n    SDL_CreateWindow(\"SDL2 Example\", SDL_WINDOWPOS_CENTERED,\n                     SDL_WINDOWPOS_CENTERED, 1280, 720, window_flags);\nSDL_GLContext gl_context = SDL_GL_CreateContext(window);\nSDL_GL_MakeCurrent(window, gl_context);\nSDL_GL_SetSwapInterval(1); // Enable vsync\n</code></pre> Initialize OpenGL loader <pre><code>bool err = gladLoadGL() == 0;\nif (err) {\n    fprintf(stderr, \"Failed to initialize OpenGL loader!\\n\");\n    return 1;\n}\n</code></pre> Initialize loop <pre><code>bool done = false;\nwhile (!done) {\n</code></pre> Poll events <pre><code>SDL_Event event;\nwhile (SDL_PollEvent(&amp;event)) {\n    if (event.type == SDL_QUIT) {\n        done = true;\n    }\n    if (event.type == SDL_WINDOWEVENT &amp;&amp;\n        event.window.event == SDL_WINDOWEVENT_CLOSE &amp;&amp;\n        event.window.windowID == SDL_GetWindowID(window)) {\n        done = true;\n    }\n}\n</code></pre> Update viewport <pre><code>    glViewport(0, 0, 600, 400);\n    glClearColor(0.45f, 0.55f, 0.60f, 1.00f);\n    glClear(GL_COLOR_BUFFER_BIT);\n    SDL_GL_SwapWindow(window);\n}\n</code></pre> Close context <pre><code>SDL_GL_DeleteContext(gl_context);\nSDL_DestroyWindow(window);\nSDL_Quit();\n</code></pre> <p>  Share Snippets </p>"},{"location":"guis/qt/","title":"Qt","text":"Show message if Qt5Widgets_DIR is not set <pre><code>if (NOT CMAKE_PREFIX_PATH AND NOT Qt5Widgets_DIR)\n    message(\"CMAKE_PREFIX_PATH is not defined, you may need to set it \"\n            \"(-DCMAKE_PREFIX_PATH=\\\"path/to/Qt/lib/cmake\\\" or -DCMAKE_PREFIX_PATH=/usr/include/{host}/qt{version}/ on Ubuntu)\")\n\n    message(\"CMAKE_PREFIX_PATH is not defined.\"\n            \"find_package(Qt5) is probably not going to work. \"\n            \" Set the CMAKE_PREFIX_PATH environment variable to the install prefix of Qt 5\"\n            \" - Set it in the command line as -DCMAKE_PREFIX_PATH=\\\"path/to/Qt5/lib/cmake\\\"\"\n            \" - Or set it in your build script with set(CMAKE_PREFIX_PATH path/to/Qt5/lib/cmake)\")\nendif ()\n</code></pre> Find Qt <pre><code>find_package(Qt5 COMPONENTS Widgets QUIET)\n</code></pre> Enable MOC <pre><code>set(CMAKE_AUTOMOC ON)\nset(CMAKE_AUTORCC ON)\nset(CMAKE_AUTOUIC ON)\n</code></pre> Link Qt <pre><code>add_executable(qt_helloworld qt_hello.cpp)\ntarget_link_libraries(qt_helloworld Qt5::Widgets)\n</code></pre> Disable MOC <pre><code>set(CMAKE_AUTOMOC OFF)\nset(CMAKE_AUTORCC OFF)\nset(CMAKE_AUTOUIC OFF)\n</code></pre> <p>  Share Snippets </p> Headers <pre><code>#include &lt;QApplication&gt;\n#include &lt;QPushButton&gt;\n</code></pre> Create Qt Application <pre><code>QApplication app(argc, argv);\n</code></pre> Create window <pre><code>QWidget window;\nwindow.setFixedSize(100, 80);\n</code></pre> Create button and attach to window <pre><code>auto *buttonInfo = new QPushButton(\"Info\", &amp;window);\nbuttonInfo-&gt;setGeometry(10, 10, 80, 30);\n</code></pre> Set button callback <pre><code>QApplication::connect(buttonInfo, &amp;QPushButton::clicked,\n                      [] { std::cout &lt;&lt; \"Info\" &lt;&lt; std::endl; });\n</code></pre> Create quit button <pre><code>auto *buttonQuit = new QPushButton(\"Quit\", &amp;window);\nbuttonQuit-&gt;setGeometry(10, 40, 80, 30);\n</code></pre> Set quit button callback <pre><code>QApplication::connect(buttonQuit, &amp;QPushButton::clicked,\n                      [] { QApplication::quit(); });\n</code></pre> Run application <pre><code>window.show();\nreturn app.exec();\n</code></pre> <p>  Share Snippets </p>"},{"location":"guis/system-tray/","title":"System tray","text":"Fetch tray library <pre><code>FetchContent_Declare(\n        tray\n        GIT_REPOSITORY https://github.com/wormyrocks/tray.git\n        GIT_TAG 3e4a1447bff413e6907c5e43ac8d65e36866fdfd\n)\nFetchContent_GetProperties(tray)\n</code></pre> Create tray target <pre><code>if (NOT tray_POPULATED)\n    FetchContent_Populate(tray)\n    add_library(tray INTERFACE)\n    target_sources(tray INTERFACE ${tray_SOURCE_DIR}/tray.h)\n    target_include_directories(tray INTERFACE ${tray_SOURCE_DIR})\n    if (WIN32)\n        target_compile_definitions(tray INTERFACE TRAY_WINAPI)\n    elseif (APPLE)\n        target_compile_definitions(tray INTERFACE TRAY_APPKIT)\n        target_link_libraries(tray INTERFACE \"-framework Cocoa\")\n        # Some warnings the library doesn't deal with\n        target_compile_options(tray INTERFACE -Wno-unused-parameter)\n        target_compile_options(tray INTERFACE -Wno-unused-variable)\n        target_compile_options(tray INTERFACE -Wno-writable-strings)\n        target_compile_options(tray INTERFACE -Wno-misleading-indentation)\n    elseif (UNIX)\n        target_compile_definitions(tray INTERFACE TRAY_APPINDICATOR)\n        target_link_libraries(tray INTERFACE \"$(shell pkg-config --cflags appindicator3-0.1 --libs appindicator3-0.1)\")\n        # Some warnings the library doesn't deal with\n        target_compile_options(tray INTERFACE -Wno-unused-parameter)\n        target_compile_options(tray INTERFACE -Wno-unused-variable)\n        target_compile_options(tray INTERFACE -Wno-writable-strings)\n        target_compile_options(tray INTERFACE -Wno-misleading-indentation)\n    endif ()\nendif ()\n</code></pre> Link tray library <pre><code>add_executable(tray_helloworld tray_hello.cpp)\ntarget_link_libraries(tray_helloworld tray)\n</code></pre> Copy tray icons <pre><code>if (WIN32)\n    file(COPY ${tray_SOURCE_DIR}/icon.ico DESTINATION ${CMAKE_CURRENT_BINARY_DIR})\nelseif (APPLE)\n    file(COPY ${tray_SOURCE_DIR}/icon.png DESTINATION ${CMAKE_CURRENT_BINARY_DIR})\nendif ()\n</code></pre> <p>  Share Snippets </p> Headers <pre><code>#include &lt;tray.h&gt;\n</code></pre> Encapsulate tray and menu options into a class <pre><code>class tray_and_menu {\n  public:\n    tray_and_menu() {\n        // Setup arrays with tray items\n        if (tray_.menu != nullptr) {\n            return;\n        }\n\n        tray_.menu = new tray_menu[8];\n        tray_.menu[0] = {.text = \"Hello\", .cb = hello_cb, .submenu = nullptr};\n        tray_.menu[1] = {\n            .text = \"Checked\", .cb = toggle_cb, .submenu = nullptr};\n        tray_.menu[2] = {.text = \"Disabled\", .disabled = 1, .submenu = nullptr};\n        tray_.menu[3] = {.text = \"-\", .submenu = nullptr};\n        tray_.menu[4] = {.text = \"SubMenu\", .submenu = new tray_menu[3]};\n        tray_.menu[5] = {.text = \"-\", .submenu = nullptr};\n        tray_.menu[6] = {.text = \"Quit\", .cb = quit_cb, .submenu = nullptr};\n        tray_.menu[7] = {.text = nullptr, .submenu = nullptr};\n\n        tray_.menu[4].submenu[0] = {.text = \"FIRST\",\n                                    .checked = 1,\n                                    .cb = submenu_cb,\n                                    .submenu = nullptr};\n        tray_.menu[4].submenu[1] = {.text = \"SECOND\",\n                                    .submenu = new tray_menu[6]};\n        tray_.menu[4].submenu[2] = {.text = nullptr, .submenu = nullptr};\n\n        tray_.menu[4].submenu[1].submenu[0] = {.text = \"THIRD\",\n                                               .submenu = new tray_menu[4]};\n        tray_.menu[4].submenu[1].submenu[1] = {.text = \"FOUR\",\n                                               .submenu = new tray_menu[3]};\n        tray_.menu[4].submenu[1].submenu[2] = {.text = nullptr,\n                                               .submenu = nullptr};\n\n        tray_.menu[4].submenu[1].submenu[0].submenu[0] = {\n            .text = \"7\", .cb = submenu_cb, .submenu = nullptr};\n        tray_.menu[4].submenu[1].submenu[0].submenu[1] = {.text = \"-\",\n                                                          .submenu = nullptr};\n        tray_.menu[4].submenu[1].submenu[0].submenu[2] = {\n            .text = \"8\", .cb = submenu_cb, .submenu = nullptr};\n        tray_.menu[4].submenu[1].submenu[0].submenu[3] = {.text = nullptr,\n                                                          .submenu = nullptr};\n\n        tray_.menu[4].submenu[1].submenu[1].submenu[0] = {\n            .text = \"5\", .cb = submenu_cb, .submenu = nullptr};\n        tray_.menu[4].submenu[1].submenu[1].submenu[1] = {\n            .text = \"6\", .cb = submenu_cb, .submenu = nullptr};\n        tray_.menu[4].submenu[1].submenu[1].submenu[2] = {\n            .text = nullptr, .cb = submenu_cb, .submenu = nullptr};\n\n        if (tray_init(&amp;tray_) &lt; 0) {\n            std::runtime_error(\"failed to create tray_\");\n        }\n    }\n\n    ~tray_and_menu() {\n        delete[] tray_.menu[4].submenu[1].submenu[1].submenu;\n        delete[] tray_.menu[4].submenu[1].submenu[0].submenu;\n        delete[] tray_.menu[4].submenu[1].submenu;\n        delete[] tray_.menu[4].submenu;\n        delete[] tray_.menu[3].submenu;\n        delete[] tray_.menu-&gt;submenu;\n        tray_.menu-&gt;submenu = nullptr;\n    }\n\n    static void run_tray() {\n        while (tray_loop(1) == 0) {\n            std::cout &lt;&lt; \"Iteration\" &lt;&lt; std::endl;\n        }\n    }\n\n  private:\n    static void toggle_cb(struct tray_menu *item) {\n        std::cout &lt;&lt; \"toggle cb\" &lt;&lt; std::endl;\n        item-&gt;checked = !item-&gt;checked;\n        tray_update(&amp;tray_);\n    }\n\n    static void hello_cb(struct tray_menu *item) {\n        (void)item;\n        std::cout &lt;&lt; \"hello cb\" &lt;&lt; std::endl;\n        // NOLINTNEXTLINE(bugprone-branch-clone)\n        if (strcmp(tray_.icon, TRAY_ICON1) == 0) {\n            tray_.icon = TRAY_ICON2;\n        } else {\n            tray_.icon = TRAY_ICON1;\n        }\n        tray_update(&amp;tray_);\n    }\n\n    static void quit_cb(struct tray_menu *item) {\n        (void)item;\n        std::cout &lt;&lt; \"quit cb\" &lt;&lt; std::endl;\n        tray_exit();\n    }\n\n    static void submenu_cb(struct tray_menu *item) {\n        (void)item;\n        std::cout &lt;&lt; \"submenu: clicked on \" &lt;&lt; item-&gt;text &lt;&lt; std::endl;\n        tray_update(&amp;tray_);\n    }\n\n  private /* members */:\n    // Tray with pointers to menu\n    static tray tray_;\n};\n</code></pre> Instantiate tray <pre><code>tray tray_and_menu::tray_{.icon = TRAY_ICON1, .menu = nullptr};\n</code></pre> Run tray <pre><code>tray_and_menu t;\ntray_and_menu::run_tray();\n</code></pre> <p>  Share Snippets </p>"},{"location":"guis/webview/","title":"Webview","text":"Fetch webview <pre><code>FetchContent_Declare(\n        webview\n        GIT_REPOSITORY https://github.com/webview/webview.git\n        GIT_TAG 50e4bcc420abdc7be96a54b7c79934a000b76901\n)\nFetchContent_GetProperties(webview)\n</code></pre> Create webview target <pre><code>if (NOT webview_POPULATED)\n    # Library does not have a CMake build script\n    # We have to do it ourselves\n    FetchContent_Populate(webview)\n    add_library(webview INTERFACE)\n    target_sources(webview INTERFACE ${webview_SOURCE_DIR}/webview.h)\n    target_include_directories(webview INTERFACE ${webview_SOURCE_DIR})\n\n    # Set compile options\n    # See: https://github.com/webview/webview/blob/master/script/build.sh\n    if (WIN32)\n        target_compile_definitions(webview INTERFACE WEBVIEW_EDGE)\n        # See: https://github.com/webview/webview/blob/master/script/build.bat\n        target_link_libraries(webview INTERFACE \"-mwindows -L./dll/x64 -lwebview -lWebView2Loader\")\n        # target_compile_options(...) ?\n    elseif (APPLE)\n        target_compile_definitions(webview INTERFACE WEBVIEW_COCOA)\n        target_compile_definitions(webview INTERFACE \"GUI_SOURCE_DIR=\\\"${CMAKE_CURRENT_SOURCE_DIR}\\\"\")\n        target_compile_options(webview INTERFACE -Wno-all -Wno-extra -Wno-pedantic -Wno-delete-non-abstract-non-virtual-dtor)\n        target_link_libraries(webview INTERFACE \"-framework WebKit\")\n    elseif (UNIX)\n        target_compile_definitions(webview INTERFACE WEBVIEW_GTK)\n        target_compile_options(webview INTERFACE -Wall -Wextra -Wpedantic)\n        target_link_libraries(webview INTERFACE \"$(pkg-config --cflags --libs gtk+-3.0 webkit2gtk-4.0)\")\n    endif ()\nendif ()\n</code></pre> Link webview <pre><code>add_executable(webview_hello webview_hello.cpp)\ntarget_link_libraries(webview_hello PUBLIC webview)\n</code></pre> <p>  Share Snippets </p> Headers <pre><code>#include &lt;webview.h&gt;\n</code></pre> Create a webview <pre><code>webview::webview w(true, nullptr);\nw.set_title(\"Example\");\nw.set_size(480, 320, WEBVIEW_HINT_NONE);\nw.set_size(180, 120, WEBVIEW_HINT_MIN);\n</code></pre> Bind javascript function receiving a string <pre><code>w.bind(\"noop\", [](std::string s) -&gt; std::string {\n    std::cout &lt;&lt; s &lt;&lt; std::endl;\n    return s;\n});\n</code></pre> Bind javascript function receiving two ints <pre><code>w.bind(\"add\", [](std::string s) -&gt; std::string {\n    auto a = std::stoi(webview::json_parse(s, \"\", 0));\n    auto b = std::stoi(webview::json_parse(s, \"\", 1));\n    return std::to_string(a + b);\n});\n</code></pre> Render webview <pre><code>  w.navigate(R\"(data:text/html,\n  &lt;!doctype html&gt;\n  &lt;html&gt;\n    &lt;body&gt;hello&lt;/body&gt;\n    &lt;script&gt;\n      window.onload = function() {\n        document.body.innerText = `hello, ${navigator.userAgent}`;\n        noop('hello').then(function(res) {\n          console.log('noop res', res);\n        });\n        add(1, 2).then(function(res) {\n          console.log('add res', res);\n        });\n      };\n    &lt;/script&gt;\n  &lt;/html&gt;\n)\");\n</code></pre> Run application <pre><code>w.run();\n</code></pre> <p>  Share Snippets </p>"},{"location":"installing-cpp/cling/","title":"Interpreter / Cling","text":"<p>If you are using C++ for scientific computing or learning C++, it's often useful to have a C++ interpreter for short experiments.</p> <p>You can install Cling from most package managers for Linux or Mac OS. You can also follow the instructions on their website to download the binaries or build it from source.</p> <p>Although you can use <code>cling</code> directly, it is much more convenient to use the interpreter as a Jupyter notebook kernel. You can follow these instructions to install Jupyter Lab, and these instructions to install the <code>xeus-cling</code> kernel. </p> <p>This creates a beautiful environment for playing with C++ interactively:</p> <p></p>"},{"location":"installing-cpp/cmake/","title":"CMake","text":""},{"location":"installing-cpp/cmake/#cmake","title":"CMake","text":"<p>CMake is the most common build system for C++. Instead of using the compiler directly, CMake controls the compilation process through platform independent configuration files.</p>"},{"location":"installing-cpp/cmake/#install-cmake","title":"Install CMake","text":"<p>CMake can be downloaded from cmake.org or from a package manager:</p> apt-getHomebrew <pre><code>sudo apt-get -y install cmake\n</code></pre> <pre><code>brew install cmake\n</code></pre>"},{"location":"installing-cpp/cmake/#configuration-files","title":"Configuration files","text":"<p>There should be a file named <code>CMakeLists.txt</code> in the root directory of your project. A starting point is:</p> <pre><code>cmake_minimum_required(VERSION 3.10)\n\n# set the project name\nproject(my_project_name)\n\n# add the executable\nadd_executable(my_project_name main.cpp)\n</code></pre>"},{"location":"installing-cpp/cmake/#building-with-cmake","title":"Building with CMake","text":"<p>Create a build directory:</p> <pre><code>mkdir build\n</code></pre> <p>Navigate to the build directory and run CMake:</p> <pre><code>cd build\ncmake ..\n</code></pre> <p>This will configure the project and generate a native build system scripts.</p> <p>Then call that build system to actually compile/link the project:</p> <pre><code>cmake --build .\n</code></pre> <p>The executable file must have been generated. Note how CMake abstracts the differences between compilers and platforms.</p>"},{"location":"installing-cpp/cmake/#configure-compiler","title":"Configure compiler","text":"<p>Set the variable <code>CMAKE_CXX_COMPILER</code> from the command line to let CMake know what compiler to use: </p> <pre><code>cmake -D CMAKE_C_COMPILER=\"/path/to/your/c/compiler/executable\" -D CMAKE_CXX_COMPILER \"/path/to/your/cpp/compiler/executable\" /path/to/directory/containing/CMakeLists.txt\n</code></pre> <p>If you want this to be your default compiler, you can set the <code>CXX</code> environment variable:</p> <pre><code>export CXX=/path/to/your/cpp/compiler/executable\n</code></pre> <p>If you want to use this compiler in a single project, always run CMake with these options:</p> <pre><code>-DCMAKE_C_COMPILER=/path/to/your/c/compiler/executable -DCMAKE_CXX_COMPILER=/path/to/your/cpp/compiler/executable\n</code></pre> <p>Or tell your IDE to pass these options to CMake:</p> <p></p>"},{"location":"installing-cpp/compiler/","title":"Compiler","text":""},{"location":"installing-cpp/compiler/#windows-msvc","title":"Windows + MSVC","text":"<p>Update your Visual Studio Compiler. The most recent version of Visual Studio should include C++20.</p>"},{"location":"installing-cpp/compiler/#linux-gcc","title":"Linux + GCC","text":"<p>Update GCC:</p> <pre><code># Repository\nsudo apt install build-essential\nsudo add-apt-repository ppa:ubuntu-toolchain-r/test\nsudo apt-get update\n# Install\nsudo apt install gcc-11\nsudo apt install g++-11\n# Install as compiler alternative\nsudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-11 11\nsudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-11 11\n</code></pre> <p>Set your default compiler with:</p> <pre><code>update-alternatives --config g++\n</code></pre>"},{"location":"installing-cpp/compiler/#mac-os-clang","title":"Mac OS + Clang","text":"<p>Download a recent version of Clang:</p> <pre><code>curl --output clang.tar.xz -L https://github.com/llvm/llvm-project/releases/download/llvmorg-13.0.1/clang+llvm-13.0.1-x86_64-apple-darwin.tar.xz\nmkdir clang\ntar -xvJf clang.tar.xz -C clang\n</code></pre> <p>Copy these files to <code>usr/local/</code>:</p> <pre><code>cd clang/clang+llvm-13.0.1-x86_64-apple-darwin\nsudo cp -R * /usr/local/\n</code></pre>"},{"location":"installing-cpp/ides/","title":"IDEs","text":"<p>These are the most common IDEs and text editors most commonly used for C++ programming:</p> IDE or Text Editor Users Notes Visual Studio 28% Windows Vim 17% (Text Editor) Qt Creator 12% Best for Qt Users Visual Studio Code 10% CLion 9% Emacs 7% (Text Editor) Xcode 4% Mac OS Eclipse 4% Others 9% <p>Warning</p> <p>These numbers are constantly changing.</p>"},{"location":"installing-cpp/webassembly/","title":"WebAssembly / Emscripten","text":"<p>If you are programming for the web, a common option for C++ and WebAssembly is emscripten.</p> <p>You can install emscripten from most package managers for Windows, Linux, or Mac OS. You can also follow the instructions on their website to build from source.</p> <p>Then follow these instructions to compile your first \"Hello World!\" for the web. Your C++ program will become this beautiful webpage:</p> <p></p>"},{"location":"programming-paradigms/basic-paradigms/crtp/","title":"Curiously Recurring Template Pattern","text":"<p>Curiously Recurring Template Pattern</p> <p>The Curiously Recurring Template Pattern is an idiom in which a class <code>X</code> derives from a class template <code>Y</code>, taking a template parameter <code>Z</code>, where <code>Y</code> is instantiated with <code>Z=X</code>. </p> <p>CRTP may be used to implement \"compile-time polymorphism\", when a base class exposes an interface, and derived  classes implement such interface.</p> Declare shape class with derived type as template parameter <pre><code>template &lt;typename derived&gt; class shape {\n  public:\n    virtual derived clone() { return static_cast&lt;derived&gt;(*this); };\n};\n</code></pre> Inherits from base and base has derived as a template parameter <pre><code>class square : public shape&lt;square&gt; {\n  public:\n    square() = default;\n    explicit square(const shape &amp;){};\n    // CRTP: Clone can return a square even though it's derived from shape\n    square clone() override { return *this; }\n};\n</code></pre> Use a template dependant function <pre><code>square a;\nsquare b = a.clone();\n</code></pre> Print addresses <pre><code>std::cout &lt;&lt; \"The square has been cloned as a real square\" &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"&amp;a: \" &lt;&lt; &amp;a &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"&amp;b: \" &lt;&lt; &amp;b &lt;&lt; '\\n';\n</code></pre> <p>  Share Snippets </p>"},{"location":"programming-paradigms/basic-paradigms/polymorphism/","title":"Polymorphism","text":"<p>Polymorphism</p> <p>Object Oriented programming (OOP) is a programming paradigm that relies on the concept of classes and objects.  It is used to structure a software program into simple, reusable pieces of code blueprints (usually called classes),  which are used to create individual instances of objects. </p> <p>One of the key features of class inheritance is that a pointer to a derived class is type-compatible with a pointer to its base class. Polymorphism is the art of taking advantage of this simple but powerful and versatile feature.</p> Declare class <pre><code>class shape {\n  public:\n</code></pre> Default constructor <pre><code>shape() : _side1(0), _side2(0) {}\n</code></pre> Constructor from double <pre><code>explicit shape(double side) : _side1(side), _side2(side) {}\n</code></pre> Constructor from two doubles <pre><code>shape(double side1, double side2) : _side1(side1), _side2(side2) {}\n</code></pre> Default Destructor <pre><code>virtual ~shape() = default;\n</code></pre> Member function <pre><code>virtual double area() { return 0; }\n</code></pre> Equality operators to compare shapes <pre><code>bool operator==(const shape &amp;rhs) const {\n    return _side1 == rhs._side1 &amp;&amp; _side2 == rhs._side2;\n}\n\nbool operator!=(const shape &amp;rhs) const { return !(rhs == *this); }\n</code></pre> Protected members <pre><code>protected:\n  double _side1;\n  double _side2;\n</code></pre> Triangle Inheritance <pre><code>class triangle : public shape {\n  public:\n    // Reuse base class constructors\n    using shape::shape;\n\n    // Default destructor\n    ~triangle() override = default;\n\n    // Override area member function\n    double area() override { return this-&gt;_side1 * this-&gt;_side2 / 2; }\n};\n</code></pre> Square Inheritance <pre><code>class square : public shape {\n  public:\n    // Reuse base class constructors\n    using shape::shape;\n\n    // Default destructor\n    ~square() override = default;\n\n    // Override area member function\n    double area() override { return this-&gt;_side1 * this-&gt;_side2; }\n};\n</code></pre> Store a square as an abstract shape <pre><code>std::unique_ptr&lt;shape&gt; p = std::make_unique&lt;square&gt;(42);\n</code></pre> Store both triangles and squares as abstract shapes <pre><code>std::vector&lt;std::unique_ptr&lt;shape&gt;&gt; v(30);\nfor (size_t i = 0; i &lt; v.size(); ++i) {\n    if (i % 2) {\n        v[i] = std::make_unique&lt;triangle&gt;(i + 30);\n    } else {\n        v[i] = std::make_unique&lt;square&gt;(i + 30);\n    }\n}\n</code></pre> Iterate shape derived objects <pre><code>for (std::unique_ptr&lt;shape&gt; &amp;item : v) {\n    if (dynamic_cast&lt;triangle *&gt;(item.get())) {\n        std::cout &lt;&lt; \"This shape is a triangle\\n\";\n    } else if (dynamic_cast&lt;square *&gt;(item.get())) {\n        std::cout &lt;&lt; \"This shape is a square\\n\";\n    } else if (dynamic_cast&lt;shape *&gt;(item.get())) {\n        std::cout &lt;&lt; \"This is an abstract shape\\n\";\n    }\n    if (item &amp;&amp; *item == *p) {\n        std::cout &lt;&lt; \"It has the same area as p: \" &lt;&lt; item-&gt;area() &lt;&lt; '\\n';\n    }\n}\n</code></pre> <p>  Share Snippets </p>"},{"location":"programming-paradigms/basic-paradigms/shared-from-this/","title":"Shared from this","text":"<p>Shared from this</p> <p><code>std::enable_shared_from_this</code> allows an  object <code>t</code> that is currently managed by a <code>std::shared_ptr</code> named <code>pt</code> to safely generate additional  <code>std::shared_ptr</code> instances <code>pt1</code>, <code>pt2</code>, ... that all share ownership of <code>t</code> with <code>pt</code>.</p> <p>Publicly inheriting from <code>std::enable_shared_from_this&lt;T&gt;</code> provides the type <code>T</code> with a member function  <code>shared_from_this</code>. If an object <code>t</code> of type <code>T</code> is managed by a <code>std::shared_ptr&lt;T&gt;</code> named <code>pt</code>, then calling  <code>T::shared_from_this</code> will return a new <code>std::shared_ptr&lt;T&gt;</code> that shares ownership of <code>t</code> with <code>pt</code>.</p> A shared class that say hello <pre><code>class hello_printer : public std::enable_shared_from_this&lt;hello_printer&gt; {\n  public:\n    // Main class function\n    void say_hello() { std::cout &lt;&lt; \"Hello, World!\" &lt;&lt; '\\n'; }\n</code></pre> A factory function to create instances of hello_printer <pre><code>    static std::shared_ptr&lt;hello_printer&gt; create() {\n        return std::shared_ptr&lt;hello_printer&gt;(new hello_printer());\n    }\n\n  private:\n    // New objects need to be created with the factory\n    hello_printer() = default;\n};\n</code></pre> Create a hello printer <pre><code>auto y = hello_printer::create();\ny-&gt;say_hello();\nstd::cout &lt;&lt; \"y.get() = \" &lt;&lt; y.get() &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"&amp;y = \" &lt;&lt; &amp;y &lt;&lt; '\\n';\n</code></pre> Share the hello printer <pre><code>// y2 will also point to the same object as y\nstd::shared_ptr&lt;hello_printer&gt; y2 = y-&gt;shared_from_this();\ny2-&gt;say_hello();\nstd::cout &lt;&lt; \"y2.get() = \" &lt;&lt; y2.get() &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"&amp;y2 = \" &lt;&lt; &amp;y2 &lt;&lt; '\\n';\n</code></pre> Create an independent hello printer <pre><code>auto z = hello_printer::create();\nz-&gt;say_hello();\nstd::cout &lt;&lt; \"z.get() = \" &lt;&lt; z.get() &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"&amp;z = \" &lt;&lt; &amp;z &lt;&lt; '\\n';\n</code></pre> <p>  Share Snippets </p>"},{"location":"programming-paradigms/parallelism/async/","title":"Async++","text":"<p>Async++</p> <p>There have been many proposals to extend the C++ model of futures. Most proposals involve the capability of  continuations without polling. One of this proposals is N3428, inspired by the Microsoft PPL library. Async++ is a lightweight library that implements the concept.</p> CMakeLists.txt <pre><code>FetchContent_Declare(asyncplusplus GIT_REPOSITORY https://github.com/Amanieu/asyncplusplus.git GIT_TAG v1.1)\nFetchContent_MakeAvailable(asyncplusplus)\nadd_executable(async_pools async_pools.cpp)\ntarget_link_libraries(async_pools PUBLIC Async++)\ntarget_compile_features(async_pools PUBLIC cxx_std_17)\n</code></pre> Launch tasks <pre><code>auto task1 = async::spawn(\n    [] { std::cout &lt;&lt; \"Task 1 executes asynchronously\" &lt;&lt; '\\n'; });\n\nauto task2 = async::spawn([]() -&gt; int {\n    std::cout &lt;&lt; \"Task 2 executes in parallel with task 1\" &lt;&lt; '\\n';\n    return 42;\n});\n</code></pre> Task continuation <pre><code>auto task3 = task2.then([](int value) -&gt; int {\n    std::cout &lt;&lt; \"Task 3 executes after task 2, which returned \" &lt;&lt; value\n              &lt;&lt; '\\n';\n    return value * 3;\n});\n</code></pre> Task conjunctions <pre><code>auto task4 = async::when_all(task1, task3);\nauto task5 =\n    task4.then([](std::tuple&lt;async::task&lt;void&gt;, async::task&lt;int&gt;&gt; results) {\n        std::cout &lt;&lt; \"Task 5 executes after tasks 1 and 3. Task 3 returned \"\n                  &lt;&lt; std::get&lt;1&gt;(results).get() &lt;&lt; '\\n';\n    });\n</code></pre> Get task results <pre><code>task5.get();\nstd::cout &lt;&lt; \"Task 5 has completed\" &lt;&lt; '\\n';\n</code></pre> Parallel invoke <pre><code>async::parallel_invoke(\n    [] { std::cout &lt;&lt; \"This is executed in parallel...\" &lt;&lt; '\\n'; },\n    [] { std::cout &lt;&lt; \"with this\" &lt;&lt; '\\n'; });\n</code></pre> Parallel for <pre><code>async::parallel_for(async::irange(0, 5), [](int x) { std::cout &lt;&lt; x; });\nstd::cout &lt;&lt; '\\n';\n</code></pre> Parallel reduce <pre><code>int r = async::parallel_reduce({1, 2, 3, 4}, 0,\n                               [](int x, int y) { return x + y; });\nstd::cout &lt;&lt; \"The sum of {1, 2, 3, 4} is \" &lt;&lt; r &lt;&lt; '\\n';\n</code></pre> <p>  Share Snippets </p>"},{"location":"programming-paradigms/parallelism/build-script/","title":"Build script","text":"<pre><code># https://stackoverflow.com/questions/66881657/ubuntu-18-gcc-9-failed-to-link-tbb-library-for-execution-policy-in-standard-lib\n#[policies CMakeLists.txt\nfind_package(Threads)\nfind_package(Execution)\nfind_library(TBB_LIBRARY NAMES tbb)\nif (Execution_FOUND AND TBB_LIBRARY)\n    add_executable(policies policies.cpp)\n    target_link_libraries(policies PUBLIC std::execution Threads::Threads ${TBB_LIBRARIES})\nendif ()\n#]\n\n#[threads CMakeLists.txt\nfind_package(Threads)\nadd_executable(multithreading multithreading.cpp)\ntarget_link_libraries(multithreading PUBLIC Threads::Threads)\n#]\n\n#[find_asio Find ASIO\nfind_package(Asio 1.21.0 QUIET)\nif (NOT Asio_FOUND)\n    FetchContent_Declare(asio GIT_REPOSITORY https://github.com/chriskohlhoff/asio.git GIT_TAG asio-1-21-0)\n    FetchContent_GetProperties(asio)\n    if (NOT asio_POPULATED)\n        FetchContent_Populate(asio)\n        add_library(asio INTERFACE)\n        target_include_directories(asio INTERFACE ${asio_SOURCE_DIR}/asio/include)\n        target_compile_definitions(asio INTERFACE ASIO_STANDALONE ASIO_NO_DEPRECATED)\n        target_link_libraries(asio INTERFACE Threads::Threads)\n    endif ()\nendif()\n#]\n\n# The executor libraries in ASIO do not have lots of convenience functions\n# but they are a good reference for the executor proposal\n#[executors CMakeLists.txt\nadd_executable(executors executors.cpp)\ntarget_link_libraries(executors asio)\n#]\n\n#[timers CMakeLists.txt\nadd_executable(timers timers.cpp)\ntarget_link_libraries(timers asio)\n#]\n\n#[signals CMakeLists.txt\nadd_executable(signals signals.cpp)\ntarget_link_libraries(signals asio)\n#]\n\n# Async++ has good convenience functions/algorithms for parallel computing\n# But it's about to be completely replaced by the traditional executors in C++23\n# Replace this library as soon as we have an alternative based on executors\n# Async++\n# The build script has a few problems\n# - stdlib++ whenever the platform is APPLE. The user might not be using stdlib++\n# - it doesn't seem to be working on more recent MSVC compilers\n# - it doesn't seem to be working on more recent Clang compilers\nif (GCC)\n    #[asyncplusplus CMakeLists.txt\n    FetchContent_Declare(asyncplusplus GIT_REPOSITORY https://github.com/Amanieu/asyncplusplus.git GIT_TAG v1.1)\n    FetchContent_MakeAvailable(asyncplusplus)\n    add_executable(async_pools async_pools.cpp)\n    target_link_libraries(async_pools PUBLIC Async++)\n    target_compile_features(async_pools PUBLIC cxx_std_17)\n    #]\nendif ()\n</code></pre>"},{"location":"programming-paradigms/parallelism/execution-policies/","title":"Execution Policies","text":"<p>Execution Policies</p> <p>Most algorithms have overloads that accept execution policies. The  standard library algorithms support several execution policies, and the library provides corresponding execution policy types and objects. Users may select an execution policy statically by invoking a parallel algorithm with an execution policy object of the corresponding type.</p> CMakeLists.txt <pre><code>find_package(Threads)\nfind_package(Execution)\nfind_library(TBB_LIBRARY NAMES tbb)\nif (Execution_FOUND AND TBB_LIBRARY)\n    add_executable(policies policies.cpp)\n    target_link_libraries(policies PUBLIC std::execution Threads::Threads ${TBB_LIBRARIES})\nendif ()\n</code></pre> Execution may not be parallelized <pre><code>std::vector&lt;int&gt; x{5, 7, 6, 4, 8, 2};\nstd::sort(std::execution::seq, x.begin(), x.end());\nstd::copy(x.begin(), x.end(), std::ostream_iterator&lt;int&gt;{std::cout, \" \"});\nstd::cout &lt;&lt; '\\n';\n</code></pre> Execution may be parallelized <pre><code>std::vector&lt;int&gt; y{5, 7, 6, 4, 8, 2};\nstd::sort(std::execution::par, y.begin(), y.end());\nstd::copy(y.begin(), y.end(), std::ostream_iterator&lt;int&gt;{std::cout, \" \"});\nstd::cout &lt;&lt; '\\n';\n</code></pre> Execution may be parallelized, vectorized, or migrated across threads <pre><code>std::vector&lt;int&gt; z{5, 7, 6, 4, 8, 2};\nstd::sort(std::execution::par_unseq, z.begin(), z.end());\nstd::copy(z.begin(), z.end(), std::ostream_iterator&lt;int&gt;{std::cout, \" \"});\nstd::cout &lt;&lt; '\\n';\n</code></pre> Execution may be vectorized <pre><code>std::vector&lt;int&gt; w{5, 7, 6, 4, 8, 2};\nstd::sort(std::execution::unseq, w.begin(), w.end());\nstd::copy(w.begin(), w.end(), std::ostream_iterator&lt;int&gt;{std::cout, \" \"});\nstd::cout &lt;&lt; '\\n';\n</code></pre> <p>  Share Snippets </p>"},{"location":"programming-paradigms/parallelism/executors/","title":"Executors","text":"<p>Executors</p> <p>A standard executor represents a policy as to how, when, and where a piece of code should be executed. The standard library does not include executors for parallel algorihms.</p> <p>Boost.Asio provides a complete implementation of the proposed standard executors.</p> <p>Creating an execution context, such as a thread pool</p> <ul> <li>Execution context: place where we can execute functions</li> <li>A thread pool is an execution context.</li> </ul> <p>An execution context is:</p> <ul> <li>Usually long lived.</li> <li>Non-copyable.</li> <li>May contain additional state, such as timers, and threads</li> </ul> <p>Creating an executor from an executor context:</p> <ul> <li>Executor: set of rules governing where, when and how to run a function object</li> <li>A thread pool has executors that send tasks to it.</li> <li>Its executor rule is: Run function objects in the pool and nowhere else. </li> </ul> <p>An executor is:</p> <ul> <li>May be long or short lived.</li> <li>Lightweight and copyable.</li> <li>May be customized on a fine-grained basis, such as exception behavior, and order</li> </ul> <p>Some references:</p> <ul> <li>https://think-async.com/Asio/</li> <li>https://think-async.com/Asio/asio-1.18.1/doc/asio/std_executors.html</li> <li>https://github.com/chriskohlhoff/executors</li> <li>https://taskflow.github.io/taskflow/index.html</li> <li>Read the unit tests, such as asio/src/tests/unit/thread_pool.cpp</li> </ul> Find ASIO <pre><code>find_package(Asio 1.21.0 QUIET)\nif (NOT Asio_FOUND)\n    FetchContent_Declare(asio GIT_REPOSITORY https://github.com/chriskohlhoff/asio.git GIT_TAG asio-1-21-0)\n    FetchContent_GetProperties(asio)\n    if (NOT asio_POPULATED)\n        FetchContent_Populate(asio)\n        add_library(asio INTERFACE)\n        target_include_directories(asio INTERFACE ${asio_SOURCE_DIR}/asio/include)\n        target_compile_definitions(asio INTERFACE ASIO_STANDALONE ASIO_NO_DEPRECATED)\n        target_link_libraries(asio INTERFACE Threads::Threads)\n    endif ()\nendif()\n</code></pre> CMakeLists.txt <pre><code>add_executable(executors executors.cpp)\ntarget_link_libraries(executors asio)\n</code></pre> Create a thread pool execution context <pre><code>asio::thread_pool pool;\n</code></pre> Create an executor for the thread pool <pre><code>auto ex = pool.executor();\n</code></pre> Access executor context <pre><code>std::cout &lt;&lt; (&amp;pool == &amp;ex.context()) &lt;&lt; '\\n';\n</code></pre> Dispatch functions <pre><code>// Executing directly in the thread pool\n// Execution behaviour according to eagerness:\n// - https://github.com/chriskohlhoff/executors\n// - Dispatch: Run the function object immediately if possible.\n//             Most eager operation.\n//             Might run before dispatch returns.\n//             If inside pool, run immediately.\n//             If outside pool, add to queue.\nasio::dispatch(ex, [&amp;ex] {\n    // This runs before finishing the function\n    asio::dispatch(ex, [] { std::cout &lt;&lt; \"dispatch b\" &lt;&lt; '\\n'; });\n    std::cout &lt;&lt; \"dispatch a\" &lt;&lt; '\\n';\n});\n</code></pre> Post function <pre><code>// - Post: Submit the function for later execution.\n//         Never immediately in the same thread.\n//         Always adds to pool queue.\n//         Never blocking.\nasio::post(ex, [&amp;ex] {\n    // This will all run in parallel\n    asio::post(ex, [] { std::cout &lt;&lt; \"post b\" &lt;&lt; '\\n'; });\n    asio::post(ex, [] { std::cout &lt;&lt; \"post c\" &lt;&lt; '\\n'; });\n    std::cout &lt;&lt; \"post a\" &lt;&lt; '\\n';\n});\n</code></pre> Defer function <pre><code>// - Defer: Submit the function for later execution.\n//          Least eager.\n//          Implies relationship between calling thread and function.\n//          Used when function is a continuation to the calling function.\n//          The function is added to the queue after the current function\n//          ends. If inside pool, adds to a thread local queue. If outside\n//          pool, add to queue. Thread posting might immediately run it.\n//          Potentially blocking.\nasio::defer(ex, [&amp;ex] {\n    // This will all run only when this function is over\n    asio::defer(ex, [] { std::cout &lt;&lt; \"defer b\" &lt;&lt; '\\n'; });\n    std::cout &lt;&lt; \"defer a\" &lt;&lt; '\\n';\n});\n</code></pre> Returning value from task <pre><code>std::future&lt;int&gt; r1 = asio::post(ex, asio::use_future([]() { return 2; }));\nstd::cout &lt;&lt; \"Result = \" &lt;&lt; r1.get() &lt;&lt; '\\n';\n</code></pre> Waiting for task <pre><code>std::future&lt;void&gt; r2 = asio::post(\n    ex, asio::use_future([]() { std::cout &lt;&lt; \"Print message\"; }));\nr2.get();\nstd::cout &lt;&lt; \" -&gt; Message printed\" &lt;&lt; '\\n';\n</code></pre> Create an strand executor <pre><code>// A strand is an executor and an executor adapter.\n// Its rule is: Run function objects according to the underlying\n// executor\u2019s rules, but also run them in FIFO order and not\n// concurrently.\nasio::strand&lt;asio::thread_pool::executor_type&gt; st(ex);\n</code></pre> Execute function in strand <pre><code>st.execute([] { std::cout &lt;&lt; \"FIFO-1a\" &lt;&lt; '\\n'; });\n</code></pre> Post function to strand <pre><code>asio::post(st, [] { std::cout &lt;&lt; \"FIFO-1b\" &lt;&lt; '\\n'; });\n</code></pre> Wait for strand result <pre><code>auto fifo_r = asio::post(\n    st, asio::use_future([] { std::cout &lt;&lt; \"FIFO-1c\" &lt;&lt; '\\n'; }));\nfifo_r.wait();\nstd::cout &lt;&lt; \"FIFO tasks done\" &lt;&lt; '\\n';\n</code></pre> Creating a promise <pre><code>std::promise&lt;int&gt; p;\nstd::future&lt;int&gt; f = p.get_future();\nauto fn = [&amp;p]() {\n    std::cout &lt;&lt; \"Task 2 executes asynchronously\" &lt;&lt; '\\n';\n    // \"return\" 2 by setting the promise value\n    p.set_value(2);\n};\nasio::post(fn);\nstd::cout &lt;&lt; \"f.get(): \" &lt;&lt; f.get() &lt;&lt; '\\n';\n</code></pre> Creating a promise <pre><code>std::promise&lt;int&gt; p;\nstd::future&lt;int&gt; f = p.get_future();\nauto fn = [&amp;p]() {\n    std::cout &lt;&lt; \"Task 2 executes asynchronously\" &lt;&lt; '\\n';\n    // \"return\" 2 by setting the promise value\n    p.set_value(2);\n};\nasio::post(fn);\nstd::cout &lt;&lt; \"f.get(): \" &lt;&lt; f.get() &lt;&lt; '\\n';\n</code></pre> Polling task continuations <pre><code>auto task1 = asio::post(asio::use_future(\n    [] { std::cout &lt;&lt; \"Task 1 executes asynchronously\" &lt;&lt; '\\n'; }));\n\nauto task2 = asio::post(asio::use_future([]() {\n    std::cout &lt;&lt; \"Task 2 executes in parallel with task 1\" &lt;&lt; '\\n';\n    return 42;\n}));\n\n// something like task3 = task2.then([](int task2_output){...});\nauto task3 = asio::post(asio::use_future([&amp;]() {\n    // poll task2 for its results\n    int task2_output = task2.get();\n    std::cout &lt;&lt; \"Task 3 executes after task 2, which returned \"\n              &lt;&lt; task2_output &lt;&lt; '\\n';\n    return task2_output * 3;\n}));\n</code></pre> Polling task conjunctions <pre><code>// something like task4 = when_all(task1, task3);\nauto task4 = asio::post(asio::use_future([&amp;]() {\n    task1.wait();\n    auto task3_output = task3.get();\n    return task3_output;\n}));\n</code></pre> Polling conjunction continuations <pre><code>// something like task5 = task4.then([](std::tuple&lt;void, int&gt;))\nauto task5 = asio::post(asio::use_future([&amp;]() {\n    auto task4_output = task4.get();\n    std::cout &lt;&lt; \"Task 5 executes after tasks 1 and 3. Task 3 returned \"\n              &lt;&lt; task4_output &lt;&lt; \".\" &lt;&lt; '\\n';\n}));\ntask5.get();\nstd::cout &lt;&lt; \"Task 5 has completed\" &lt;&lt; '\\n';\n</code></pre> Making threads sleep <pre><code>for (int i = 0; i &lt; 20; ++i) {\n    asio::post(ex, [i] {\n        std::cout &lt;&lt; \"Thread \" &lt;&lt; i &lt;&lt; \" going to sleep\" &lt;&lt; '\\n';\n        std::this_thread::sleep_for(std::chrono::seconds(1));\n        std::cout &lt;&lt; \"Thread \" &lt;&lt; i &lt;&lt; \" awake\" &lt;&lt; '\\n';\n    });\n}\n</code></pre> Parallel invoke functions <pre><code>auto parallel_invoke = [](auto ex, auto fn1, auto fn2) {\n    asio::post(ex, fn1);\n    asio::post(ex, fn2);\n};\n</code></pre> Call parallel invoke functions <pre><code>parallel_invoke(\n    ex, [] { std::cout &lt;&lt; \"parallel_invoke a\" &lt;&lt; '\\n'; },\n    [] { std::cout &lt;&lt; \"parallel_invoke b\" &lt;&lt; '\\n'; });\n</code></pre> Parallel for with 1 task per element <pre><code>auto parallel_for = [](auto ex, auto begin, auto end, auto fn) {\n    while (begin != end) {\n        asio::post(ex, [begin, &amp;fn] { fn(*begin); });\n        ++begin;\n    }\n};\n</code></pre> Call parallel for with 1 task per element <pre><code>std::vector&lt;int&gt; v = {0, 1, 2, 3, 4, 5};\nparallel_for(ex, v.begin(), v.end(), [](int x) { std::cout &lt;&lt; x; });\nstd::cout &lt;&lt; '\\n';\n</code></pre> Function to make a ready future <pre><code>template &lt;class T&gt; auto make_ready_future(T &amp;&amp;value) {\n    std::promise&lt;std::decay_t&lt;T&gt;&gt; result_promise;\n    std::future&lt;std::decay_t&lt;T&gt;&gt; result_future = result_promise.get_future();\n    result_promise.set_value(value);\n    return result_future;\n}\n</code></pre> Parallel reduce function <pre><code>template &lt;class FN, class Iterator&gt;\nstd::future&lt;typename Iterator::value_type&gt;\nparallel_reduce(auto ex, Iterator begin, Iterator end, FN fn) {\n    auto second = std::next(begin);\n    const bool is_single_element = second == end;\n    const bool is_single_pair =\n        !is_single_element &amp;&amp; (std::next(second) == end);\n    if (is_single_element) {\n        return make_ready_future(*begin);\n    } else if (is_single_pair) {\n        return asio::post(ex, asio::use_future([begin, second, &amp;fn] {\n                              return fn(*begin, *second);\n                          }));\n    } else {\n        // we would probably add a heuristic here for small ranges\n        size_t n = std::distance(begin, end);\n        auto half = std::next(begin, n / 2);\n        auto lhs = parallel_reduce(ex, begin, half, fn);\n        auto rhs = parallel_reduce(ex, half, end, fn);\n        return make_ready_future(lhs.get() + rhs.get());\n    }\n}\n</code></pre> <p>  Share Snippets </p>"},{"location":"programming-paradigms/parallelism/signals/","title":"Signals","text":"<p>Signals</p> <p>Signals might be important to properly stop asynchronous operations, such as servers.</p> <p>Boost.Asio supports signal  handling using a class called <code>signal_set</code>. Programs may add one or more signals to the set, and then perform an <code>async_wait()</code> operation. </p> <p>The specified handler will be called when one of the signals occurs. The same signal number may be registered with multiple <code>signal_set</code> objects, however the signal number must be used only with <code>Boost.Asio</code>.</p> Find ASIO <pre><code>find_package(Asio 1.21.0 QUIET)\nif (NOT Asio_FOUND)\n    FetchContent_Declare(asio GIT_REPOSITORY https://github.com/chriskohlhoff/asio.git GIT_TAG asio-1-21-0)\n    FetchContent_GetProperties(asio)\n    if (NOT asio_POPULATED)\n        FetchContent_Populate(asio)\n        add_library(asio INTERFACE)\n        target_include_directories(asio INTERFACE ${asio_SOURCE_DIR}/asio/include)\n        target_compile_definitions(asio INTERFACE ASIO_STANDALONE ASIO_NO_DEPRECATED)\n        target_link_libraries(asio INTERFACE Threads::Threads)\n    endif ()\nendif()\n</code></pre> CMakeLists.txt <pre><code>add_executable(signals signals.cpp)\ntarget_link_libraries(signals asio)\n</code></pre> Create io_context executor <pre><code>asio::io_context io_context;\n</code></pre> Create signal_set responding to SIGINT and SIGTERM <pre><code>asio::signal_set signals(io_context, SIGINT, SIGTERM);\n</code></pre> Set the signal set callback <pre><code>// The signals will set stop_timer to true\nstd::atomic&lt;bool&gt; request_stop_timer = false;\nsignals.async_wait([&amp;](const asio::error_code &amp;ec, int signal_number) {\n    if (!ec) {\n        std::cout &lt;&lt; \"Signal number \" &lt;&lt; signal_number &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"Gracefully stopping the timer and exiting\"\n                  &lt;&lt; std::endl;\n        request_stop_timer.store(true);\n    } else {\n        std::cout &lt;&lt; \"Error \" &lt;&lt; ec.value() &lt;&lt; \" - \" &lt;&lt; ec.message()\n                  &lt;&lt; \" - Signal number - \" &lt;&lt; signal_number &lt;&lt; std::endl;\n    }\n});\n</code></pre> Create a timer that keeps counting until we have a signal <pre><code>asio::steady_timer t(io_context, asio::chrono::seconds(1));\n</code></pre> Set timer callback <pre><code>int count = 0;\nstd::function&lt;void(asio::error_code)&gt; timer_callback;\ntimer_callback = [&amp;](asio::error_code ec) {\n    if (!ec) {\n        if (count &lt; 30 &amp;&amp; !request_stop_timer.load()) {\n            // Increase counter\n            std::cout &lt;&lt; count &lt;&lt; std::endl;\n            ++count;\n            // Set the timer again\n            t.expires_at(t.expiry() + std::chrono::seconds(1));\n            t.async_wait(timer_callback);\n        } else {\n            std::cout &lt;&lt; \"Reached \" &lt;&lt; count &lt;&lt; std::endl;\n        }\n    } else {\n        std::cout &lt;&lt; \"Timer Error\" &lt;&lt; std::endl;\n    }\n};\n</code></pre> Push timer waiting task to io_context <pre><code>t.async_wait(timer_callback);\n</code></pre> Execute tasks from io_context <pre><code>asio::thread_pool pool;\nfor (size_t i = 0; i &lt; std::thread::hardware_concurrency(); ++i) {\n    asio::post(pool, [&amp;io_context] { io_context.run(); });\n}\n</code></pre> <p>  Share Snippets </p>"},{"location":"programming-paradigms/parallelism/threads/","title":"Threads","text":"<p>Threads</p> <p>The C++ thread support library includes built-in support for threads,  mutual exclusion, condition variables, and futures.</p> CMakeLists.txt <pre><code>find_package(Threads)\nadd_executable(multithreading multithreading.cpp)\ntarget_link_libraries(multithreading PUBLIC Threads::Threads)\n</code></pre> Launch thread <pre><code>std::thread t1([]() { std::cout &lt;&lt; \"function 1\\n\"; });\n</code></pre> Launch thread with function parameter <pre><code>std::thread t2(\n    [](int x) { std::cout &lt;&lt; \"function 2: number \" &lt;&lt; x &lt;&lt; '\\n'; }, 10);\n</code></pre> Launch lambda function <pre><code>auto fn = [](int x) { std::cout &lt;&lt; \"function 3: number \" &lt;&lt; x &lt;&lt; '\\n'; };\nstd::thread t3(fn, 2);\n</code></pre> Wait for threads <pre><code>t1.join();\nt2.join();\nt3.join();\n</code></pre> Thread vector <pre><code>// - A vector can store reusable threads\n// - The cost of creating threads might be higher than their work\nstd::vector&lt;std::thread&gt; workers;\nfor (int i = 0; i &lt; 5; i++) {\n    workers.emplace_back([i]() { std::cout &lt;&lt; \"Thread function \" &lt;&lt; i; });\n}\n</code></pre> Wait for thread vector <pre><code>std::for_each(workers.begin(), workers.end(),\n              [](std::thread &amp;t) { t.join(); });\n</code></pre> Future value <pre><code>// - Unfortunately, async does not necessarily go to a thread pool\n// - It's best to use a library if you need async(...) a lot\nstd::future&lt;int&gt; f2 = async(std::launch::async, [] { return 8; });\nwhile (f2.wait_for(std::chrono::milliseconds(100)) !=\n       std::future_status::ready) {\n    // do some other work\n    std::this_thread::sleep_for(std::chrono::milliseconds(1));\n}\n</code></pre> Wait until future is ready <pre><code>f2.wait();\n</code></pre> Wait and get value from the future <pre><code>std::cout &lt;&lt; f2.get() &lt;&lt; '\\n';\n</code></pre> Call parallel algorithm <pre><code>// - Same overhead applies here\nstd::vector&lt;int&gt; v(10000, 1);\nstd::cout &lt;&lt; \"The sum is \" &lt;&lt; parallel_sum(v.begin(), v.end()) &lt;&lt; '\\n';\n</code></pre> Parallel algorithm with one thread per subproblem <pre><code>template &lt;typename Iter&gt; int parallel_sum(Iter beg, Iter end) {\n    typename Iter::difference_type len = end - beg;\n\n    // Solve small problems in one thread\n    if (len &lt; 1000) {\n        return std::accumulate(beg, end, 0);\n    }\n\n    // Split large problems into two threads\n    Iter mid = beg + len / 2;\n    std::future&lt;int&gt; handle =\n        std::async(std::launch::async, parallel_sum&lt;Iter&gt;, mid, end);\n    int sum = parallel_sum(beg, mid);\n    return sum + handle.get();\n}\n</code></pre> <p>  Share Snippets </p>"},{"location":"programming-paradigms/parallelism/timers/","title":"Timers","text":"<p>Timers</p> <p>Timers are useful to applications that need to perform some operations once every x time units, including timeouts for servers</p> Find ASIO <pre><code>find_package(Asio 1.21.0 QUIET)\nif (NOT Asio_FOUND)\n    FetchContent_Declare(asio GIT_REPOSITORY https://github.com/chriskohlhoff/asio.git GIT_TAG asio-1-21-0)\n    FetchContent_GetProperties(asio)\n    if (NOT asio_POPULATED)\n        FetchContent_Populate(asio)\n        add_library(asio INTERFACE)\n        target_include_directories(asio INTERFACE ${asio_SOURCE_DIR}/asio/include)\n        target_compile_definitions(asio INTERFACE ASIO_STANDALONE ASIO_NO_DEPRECATED)\n        target_link_libraries(asio INTERFACE Threads::Threads)\n    endif ()\nendif()\n</code></pre> CMakeLists.txt <pre><code>add_executable(timers timers.cpp)\ntarget_link_libraries(timers asio)\n</code></pre> Create io_context executor <pre><code>asio::io_context io_context;\n</code></pre> Setting a synchronous timer <pre><code>asio::steady_timer t(io_context, std::chrono::seconds(3));\nt.wait();\nstd::cout &lt;&lt; \"Sync Timer expired\" &lt;&lt; '\\n';\n</code></pre> Create a steady timer <pre><code>asio::steady_timer t1(io_context, std::chrono::seconds(3));\n</code></pre> Setting steady timer asynchronous callback <pre><code>t1.async_wait([](std::error_code ec) {\n    if (!ec) {\n        std::cout &lt;&lt; \"Timer 1 expired\" &lt;&lt; '\\n';\n    } else {\n        std::cout &lt;&lt; \"Timer 1 error\" &lt;&lt; '\\n';\n    }\n});\n</code></pre> Creating a system timer <pre><code>asio::system_timer t2(io_context, std::chrono::seconds(3));\n</code></pre> Setting asynchronous steady timer callback <pre><code>t2.async_wait([](std::error_code ec) {\n    if (!ec) {\n        std::cout &lt;&lt; \"Timer 2 expired\" &lt;&lt; '\\n';\n    } else {\n        std::cout &lt;&lt; \"Timer 2 error\" &lt;&lt; '\\n';\n    }\n});\n</code></pre> Creating a high-resolution timer <pre><code>asio::high_resolution_timer t3(io_context, std::chrono::seconds(3));\n</code></pre> Setting asynchronous high-resolution timer callback <pre><code>t3.async_wait([](std::error_code ec) {\n    if (!ec) {\n        std::cout &lt;&lt; \"Timer 3 expired\" &lt;&lt; '\\n';\n    } else {\n        std::cout &lt;&lt; \"Timer 3 error\" &lt;&lt; '\\n';\n    }\n});\n</code></pre> Dequeue tasks from io_context executor <pre><code>asio::thread_pool pool;\nfor (size_t i = 0; i &lt; std::thread::hardware_concurrency(); ++i) {\n    asio::post(pool, [&amp;io_context] { io_context.run(); });\n}\n</code></pre> <p>  Share Snippets </p>"},{"location":"testing/boostut/","title":"boost.ut","text":"Fetch boost.ut <pre><code>FetchContent_Declare(boost.ut GIT_REPOSITORY https://github.com/boost-ext/ut GIT_TAG v1.1.8)\nFetchContent_MakeAvailable(boost.ut)\n</code></pre> Link boost.ut <pre><code>add_executable(unit_tests unit_tests_ut.cpp)\ntarget_link_libraries(unit_tests PRIVATE boost.ut)\n</code></pre> Headers <pre><code>#include &lt;boost/ut.hpp&gt;\n</code></pre> Requirements <pre><code>expect(true);\nexpect(1 == 2);\nexpect(1_i == 2);            // UDL syntax\nexpect(1 == 2_i);            // UDL syntax\nexpect(that % 1 == 2);       // Matcher syntax\nexpect(eq(1, 2));            // eq/neq/gt/ge/lt/le\nexpect((1 == 1_i) &gt;&gt; fatal); // fatal assertion\nexpect(1_i == 2);            // not executed\nexpect(42l == 42_l and 1 == 2_i) &lt;&lt; \"additional info\\n\";\n</code></pre> Test groups <pre><code>\"hello world\"_test = [] {\n    int i = 42;\n    expect(42_i == i);\n};\n</code></pre> Test groups <pre><code>\"[vector]\"_test = [] {\n    std::vector&lt;int&gt; v(5);\n\n    expect((5_ul == std::size(v)) &gt;&gt; fatal);\n\n    should(\"resize bigger\") = [v] { // or \"resize bigger\"_test\n        mut(v).resize(10);\n        expect(10_ul == std::size(v));\n    };\n\n    expect((5_ul == std::size(v)) &gt;&gt; fatal);\n\n    should(\"resize smaller\") = [=]() mutable { // or \"resize smaller\"_test\n        v.resize(0);\n        expect(0_ul == std::size(v));\n    };\n};\n</code></pre> Behaviour Driven development <pre><code>using namespace boost::ut::bdd;\n\"vector\"_test = [] {\n    given(\"I have a vector\") = [] {\n        std::vector&lt;int&gt; v(5);\n        expect((5_ul == std::size(v)) &gt;&gt; fatal);\n\n        when(\"I resize bigger\") = [=] {\n            mut(v).resize(10);\n\n            then(\"The size should increase\") = [=] {\n                expect(10_ul == std::size(v));\n            };\n        };\n    };\n};\n</code></pre> BBD: feature / scenario <pre><code>feature(\"vector\") = [] {\n    scenario(\"size\") = [] {\n        given(\"I have a vector\") = [] {\n            std::vector&lt;int&gt; v(5);\n            expect((5_ul == std::size(v)) &gt;&gt; fatal);\n\n            when(\"I resize bigger\") = [=] {\n                mut(v).resize(10);\n\n                then(\"The size should increase\") = [=] {\n                    expect(10_ul == std::size(v));\n                };\n            };\n        };\n    };\n};\n</code></pre> Test parameters <pre><code>for (auto i : std::vector{1, 2, 3}) {\n    test(\"parameterized \" + std::to_string(i)) = [i] { // 3 tests\n        expect(that % i &gt; 0);                          // 3 asserts\n    };\n}\n</code></pre> Test parameters <pre><code>\"args\"_test = [](const auto &amp;arg) {\n    expect(arg &gt; 0_i) &lt;&lt; \"all values greater than 0\";\n} | std::vector{1, 2, 3};\n</code></pre> Nested tests <pre><code>\"vector\"_test = [] {\n    std::vector&lt;int&gt; v(5);\n    expect((5_ul == std::size(v)) &gt;&gt; fatal);\n    \"samesize\"_test = [&amp;] {\n        std::vector&lt;int&gt; v2(5);\n        expect(eq(v.size(), v2.size()));\n    };\n};\n</code></pre> Logging <pre><code>\"logging\"_test = [] {\n    log &lt;&lt; \"pre\";\n    expect(42_i == 43) &lt;&lt; \"message on failure\";\n    log &lt;&lt; \"post\";\n};\n</code></pre> <p>  Share Snippets </p>"},{"location":"testing/catch2/","title":"Catch2","text":"<p>Snippet fetch_catch2 not found in snippets/tests/CMakeLists.txt</p> Link Catch2 <pre><code>add_executable(unit_tests_catch unit_tests_catch.cpp)\ntarget_link_libraries(unit_tests_catch PRIVATE Catch2::Catch2)\n</code></pre> Headers <pre><code>#define CATCH_CONFIG_MAIN\n#include &lt;catch2/catch.hpp&gt;\n</code></pre> Create test case <pre><code>TEST_CASE(\"Factorial of 0 is 1 (fail)\", \"[single-file]\") {\n    REQUIRE(Factorial(0) == 1);\n}\n</code></pre> Create test case <pre><code>TEST_CASE(\"Factorials of 1 and higher are computed (pass)\", \"[single-file]\") {\n    REQUIRE(Factorial(1) == 1);\n    REQUIRE(Factorial(2) == 2);\n    REQUIRE(Factorial(3) == 6);\n    REQUIRE(Factorial(10) == 3628800);\n}\n</code></pre> <p>  Share Snippets </p>"},{"location":"testing/plots/","title":"Plots","text":"Find Matplot++ <pre><code>find_package(Matplot++ QUIET)\n</code></pre> Link Matplot++ <pre><code>if (Matplot++_FOUND)\n    add_executable(plots plots.cpp)\n    target_link_libraries(plots PRIVATE Matplot++::matplot)\nendif ()\n</code></pre> Headers <pre><code>#include &lt;matplot/matplot.h&gt;\n</code></pre> Line plot <pre><code>matplot::plot(std::vector{1, 2, 3, 4, 5, 6});\nmatplot::show();\n</code></pre> <p>  Share Snippets </p>"},{"location":"testing/source-location/","title":"Source Location","text":"Headers <pre><code>#include &lt;source_location&gt;\n</code></pre> Function that requires source location <pre><code>void print_msg_with_line(\n    std::string_view message,\n    const std::source_location &amp;location = std::source_location::current()) {\n    std::cout &lt;&lt; \"info: \" &lt;&lt; location.file_name() &lt;&lt; ':' &lt;&lt; location.line()\n              &lt;&lt; ' ' &lt;&lt; message &lt;&lt; '\\n';\n}\n</code></pre> Call function with source location <pre><code>print_msg_with_line(\"Hello world!\");\n</code></pre> <p>  Share Snippets </p>"},{"location":"utilities/networking/async-network/","title":"Async Network","text":"Find ASIO <pre><code>find_package(Asio 1.21.0 QUIET)\nif (NOT Asio_FOUND)\n    FetchContent_Declare(asio GIT_REPOSITORY https://github.com/chriskohlhoff/asio.git GIT_TAG asio-1-21-0)\n    FetchContent_GetProperties(asio)\n    if (NOT asio_POPULATED)\n        FetchContent_Populate(asio)\n        add_library(asio INTERFACE)\n        target_include_directories(asio INTERFACE ${asio_SOURCE_DIR}/asio/include)\n        target_compile_definitions(asio INTERFACE ASIO_STANDALONE ASIO_NO_DEPRECATED)\n        target_link_libraries(asio INTERFACE Threads::Threads)\n    endif ()\nendif()\n</code></pre> CMakeLists.txt <pre><code>add_executable(network network.cpp)\ntarget_link_libraries(network asio)\n</code></pre> Declare class to represent client session <pre><code>class session : public std::enable_shared_from_this&lt;session&gt; {\n  public:\n    explicit session(asio::ip::tcp::socket socket)\n        : socket_(std::move(socket)) {\n        // Create a session to a client\n        // The session just wraps a socket to communicate with the client\n    }\n\n    void start() {\n        // Start the session by reading from the client\n        schedule_read();\n    }\n</code></pre> Read whatever the client sent us <pre><code>private:\n  void schedule_read() {\n      // Create another pointer to this session\n      // - These pointers are useful to make sure there is always\n      //   some shared pointer pointing to this session object\n      auto self(shared_from_this());\n\n      // Read some data from the client\n      // - We read little by little to make sure everything is OK\n      // - This is better than reading all at once\n      // - We read max_length bytes at a time\n      socket_.async_read_some(\n          asio::buffer(data_, max_length),\n          [this, self](std::error_code ec, std::size_t length) {\n              // If there was no error reading the message,\n              // write a response to the client\n              if (!ec) {\n                  std::cout &lt;&lt; \"Client sent: \" &lt;&lt; std::endl;\n                  std::cout &lt;&lt; data_ &lt;&lt; std::endl &lt;&lt; std::endl;\n                  schedule_write(length);\n              }\n          });\n  }\n</code></pre> Write a response to the client <pre><code>void schedule_write(std::size_t length) {\n    // Create another shared pointer to this to make sure it does die\n    auto self(shared_from_this());\n\n    // Write a response asynchronously\n    // - In this example, we write the same data back to the client\n    asio::async_write(\n        socket_, asio::buffer(data_, length),\n        [this, self](std::error_code ec, std::size_t /*length*/) {\n            // If there is no error\n            if (!ec) {\n                std::cout &lt;&lt; \"Server replied with: \" &lt;&lt; std::endl;\n                std::cout &lt;&lt; data_ &lt;&lt; std::endl &lt;&lt; std::endl;\n                // Starting reading from the client again\n                schedule_read();\n            }\n        });\n}\n</code></pre> Session data <pre><code>    // Socket representing connection to client\n    asio::ip::tcp::socket socket_;\n\n    // Max length of the messages\n    static constexpr size_t max_length = 1024;\n\n    // Array to keep messages\n    char data_[max_length]{};\n};\n</code></pre> Define class to manage the acceptor and the clients <pre><code>class server {\n  public:\n    // Construct server on a port\n    // - The server just wraps the acceptor and starts a session whenever\n    //   the client connects\n    server(asio::io_context &amp;io_context, short port)\n        : acceptor_(io_context,\n                    asio::ip::tcp::endpoint(asio::ip::tcp::v4(), port)) {\n        schedule_accept();\n    }\n</code></pre> Listen for connection <pre><code>private:\n  void schedule_accept() {\n      std::cout &lt;&lt; \"Listening on http://localhost:\"\n                &lt;&lt; acceptor_.local_endpoint().port() &lt;&lt; std::endl;\n      // Wait for connection\n      // - Wait for a connection\n      // - Open http://localhost:8080 in your browser\n      acceptor_.async_accept(\n          [this](std::error_code ec, asio::ip::tcp::socket socket) {\n              // If there is no error, create a socket and reply\n              // - The session object wraps the a socket to create response\n              // - The session will manage a single connection to a user\n              if (!ec) {\n                  // Start the session\n                  std::make_shared&lt;session&gt;(std::move(socket))-&gt;start();\n              }\n\n              // Accept another connection\n              // - The session will work asynchronously\n              // - While the session will start to read the message,\n              //   the server already starts listening no another connection.\n              schedule_accept();\n          });\n  }\n</code></pre> Server members <pre><code>  private /* members */:\n    // The only member we need is an acceptor for the server\n    asio::ip::tcp::acceptor acceptor_;\n};\n</code></pre> Create io_context for server <pre><code>int main() {\n    try {\n        // Create io_context as usual\n        asio::io_context io_context;\n</code></pre> Create server <pre><code>// We put all the logic inside a server object\n// - Nothing forbids us from organizing the server\n//   in any other way.\nserver s(io_context, 8080);\n</code></pre> Dequeue tasks from io_context <pre><code>// Run the io_context\n// - The server async functions will queue tasks in the io_context\n// - This function runs the io_context while there's work to do\n// - There is always going to be work to do because the server\n//   is always listening\nasio::thread_pool pool;\nfor (unsigned i = 0; i &lt; std::thread::hardware_concurrency(); ++i) {\n    asio::post(pool, [&amp;io_context] {\n        // We run the io_context from the threads\n        // - This allows us the io_context to send work to whatever\n        //   thread seems best\n        io_context.run();\n    });\n}\n</code></pre> Catch server exceptions <pre><code>} catch (std::exception &amp;e) {\n    // Report any exceptions\n    std::cerr &lt;&lt; \"Exception: \" &lt;&lt; e.what() &lt;&lt; \"\\n\";\n}\n</code></pre> <p>  Share Snippets </p>"},{"location":"utilities/networking/http-server/","title":"Http server","text":"Find ASIO <pre><code>find_package(Asio 1.21.0 QUIET)\nif (NOT Asio_FOUND)\n    FetchContent_Declare(asio GIT_REPOSITORY https://github.com/chriskohlhoff/asio.git GIT_TAG asio-1-21-0)\n    FetchContent_GetProperties(asio)\n    if (NOT asio_POPULATED)\n        FetchContent_Populate(asio)\n        add_library(asio INTERFACE)\n        target_include_directories(asio INTERFACE ${asio_SOURCE_DIR}/asio/include)\n        target_compile_definitions(asio INTERFACE ASIO_STANDALONE ASIO_NO_DEPRECATED)\n        target_link_libraries(asio INTERFACE Threads::Threads)\n    endif ()\nendif()\n</code></pre> http_server <pre><code>add_executable(http_server\n        connection.cpp\n        connection.hpp\n        connection_manager.cpp\n        connection_manager.hpp\n        header.hpp\n        main.cpp\n        mime_types.cpp\n        mime_types.hpp\n        reply.cpp\n        reply.hpp\n        request.hpp\n        request_handler.cpp\n        request_handler.hpp\n        request_parser.cpp\n        request_parser.hpp\n        server.cpp\n        server.hpp)\ntarget_link_libraries(http_server asio)\n</code></pre> Check command line arguments. <pre><code>int main(int argc, char *argv[]) {\n    try {\n        if (argc != 4) {\n            std::cout &lt;&lt; \"Usage: http_server &lt;address&gt; &lt;port&gt; &lt;doc_root&gt;\\n\";\n            std::cout &lt;&lt; \"  For IPv4, try: \";\n            std::cout &lt;&lt; \"    receiver 0.0.0.0 80 .\\n\";\n            std::cout &lt;&lt; \"  For IPv6, try: \";\n            std::cout &lt;&lt; \"    receiver 0::0 80 .\\n\";\n        }\n</code></pre> Initialise the server <pre><code>std::string address = argc &gt; 1 ? argv[1] : \"0.0.0.0\";\nstd::string port = argc &gt; 2 ? argv[2] : \"80\";\nstd::string doc_root = argc &gt; 3 ? argv[3] : \".\";\nstd::cout &lt;&lt; \"Server address: http://\" &lt;&lt; address &lt;&lt; \":\" &lt;&lt; port\n          &lt;&lt; '\\n';\nhttp::server::server s(address, port, doc_root);\n</code></pre> Run the server until stopped. <pre><code>s.run();\n</code></pre> Catch server exceptions <pre><code>} catch (std::exception &amp;e) {\n    std::cerr &lt;&lt; \"exception: \" &lt;&lt; e.what() &lt;&lt; \"\\n\";\n}\n</code></pre> <p>  Share Snippets </p> Define top-level class for the HTTP server. <pre><code>class server {\n  public:\n    server(const server &amp;) = delete;\n    server &amp;operator=(const server &amp;) = delete;\n\n    // Construct the server to listen on the specified TCP address and\n    // port, and serve up files from the given directory.\n    explicit server(const std::string &amp;address, const std::string &amp;port,\n                    const std::string &amp;doc_root);\n\n    // Run the server's io_context loop.\n    void run();\n\n  private:\n    // Perform an asynchronous accept operation.\n    void schedule_accept();\n\n    // Wait for a request to stop the server.\n    void schedule_await_stop();\n\n    // The io_context used to perform asynchronous operations.\n    asio::io_context io_context_;\n\n    // Executor for the io context\n    asio::thread_pool pool_;\n\n    // The signal_set is used to register for process termination\n    // notifications.\n    asio::signal_set signals_;\n\n    // Acceptor used to listen for incoming connections.\n    asio::ip::tcp::acceptor acceptor_;\n\n    // The connection manager which owns all live connections.\n    connection_manager connection_manager_;\n\n    // The handler for all incoming requests.\n    request_handler request_handler_;\n\n    // Helper class to setup signals\n    void setup_signals();\n\n    // Helper class to setup acceptor\n    void setup_acceptor(const std::string &amp;address,\n                        const std::string &amp;port);\n};\n</code></pre> <p>  Share Snippets </p> Server constructor <pre><code>server::server(const std::string &amp;address, const std::string &amp;port,\n               const std::string &amp;doc_root)\n    : io_context_(1), signals_(io_context_), acceptor_(io_context_),\n      connection_manager_(), request_handler_(doc_root) {\n    setup_signals();\n    setup_acceptor(address, port);\n}\n</code></pre> Setup server acceptor <pre><code>void server::setup_acceptor(\n    const std::string &amp;address,\n    const std::string &amp;port) {\n\n    // Open the acceptor with the option to\n    // reuse the address (i.e. SO_REUSEADDR).\n    asio::ip::tcp::resolver resolver(io_context_);\n    asio::ip::tcp::endpoint endpoint =\n        *resolver.resolve(address, port).begin();\n    acceptor_.open(endpoint.protocol());\n    acceptor_.set_option(asio::socket_base::reuse_address(true));\n    acceptor_.bind(endpoint);\n    acceptor_.listen();\n\n    schedule_accept();\n}\n</code></pre> Server setup_signals <pre><code>    void server::setup_signals() {\n        // Register to handle the signals that indicate when the server\n        // should exit. It is safe to register for the same signal multiple\n        // times in a program, provided all registration for the specified\n        // signal is made through Asio.\n        signals_.add(SIGINT);\n        signals_.add(SIGTERM);\n#if defined(SIGQUIT)\n        signals_.add(SIGQUIT);\n#endif // defined(SIGQUIT)\n        schedule_await_stop();\n    }\n</code></pre> Server run <pre><code>void server::run() {\n    // The io_context::run() call will block until all asynchronous\n    // operations have finished. While the server is running, there is\n    // always at least one asynchronous operation outstanding: the\n    // asynchronous accept call waiting for new incoming connections.\n    for (size_t i = 0; i &lt; std::thread::hardware_concurrency(); ++i) {\n        asio::post(pool_, [this] { io_context_.run(); });\n    }\n    pool_.join();\n}\n</code></pre> Server schedule_accept <pre><code>void server::schedule_accept() {\n    acceptor_.async_accept([this](std::error_code ec,\n                                  asio::ip::tcp::socket socket) {\n        // Check whether the server was stopped by a signal before\n        // this completion handler had a chance to run.\n        if (!acceptor_.is_open()) {\n            return;\n        }\n\n        if (!ec) {\n            connection_manager_.start(std::make_shared&lt;connection&gt;(\n                std::move(socket), connection_manager_, request_handler_));\n        }\n\n        schedule_accept();\n    });\n}\n</code></pre> Server schedule_await_stop <pre><code>void server::schedule_await_stop() {\n    signals_.async_wait([this](std::error_code /*ec*/, int /*signo*/) {\n        // The server is stopped by cancelling all outstanding\n        // asynchronous operations. Once all operations have finished\n        // the io_context::run() call will exit.\n        acceptor_.close();\n        connection_manager_.stop_all();\n    });\n}\n</code></pre> <p>  Share Snippets </p> Declare connection manager <pre><code>// Manages open connections so that they may be cleanly stopped when\n// the server needs to shut down.\nclass connection_manager {\n  public:\n    connection_manager(const connection_manager &amp;) = delete;\n    connection_manager &amp;operator=(const connection_manager &amp;) = delete;\n\n    // Construct a connection manager.\n    connection_manager();\n\n    // Add the specified connection to the manager and start it.\n    void start(connection_ptr c);\n\n    // Stop the specified connection.\n    void stop(connection_ptr c);\n\n    // Stop all connections.\n    void stop_all();\n\n  private:\n    // The managed connections.\n    std::set&lt;connection_ptr&gt; connections_;\n};\n</code></pre> <p>  Share Snippets </p> Default construct <pre><code>connection_manager::connection_manager() = default;\n</code></pre> Start a connection <pre><code>void connection_manager::start(connection_ptr c) {\n    connections_.insert(c);\n    c-&gt;start();\n}\n</code></pre> Stop a connection <pre><code>void connection_manager::stop(connection_ptr c) {\n    connections_.erase(c);\n    c-&gt;stop();\n}\n</code></pre> Stop all connections <pre><code>void connection_manager::stop_all() {\n    for (auto c : connections_) {\n        c-&gt;stop();\n    }\n    connections_.clear();\n}\n</code></pre> <p>  Share Snippets </p> Define class for a single connection from a client. <pre><code>class connection : public std::enable_shared_from_this&lt;connection&gt; {\n  public:\n    connection(const connection &amp;) = delete;\n    connection &amp;operator=(const connection &amp;) = delete;\n\n    // Construct a connection with the given socket.\n    explicit connection(asio::ip::tcp::socket socket,\n                        connection_manager &amp;manager,\n                        request_handler &amp;handler);\n\n    // Start the first asynchronous operation for the connection.\n    void start();\n\n    // Stop all asynchronous operations associated with the connection.\n    void stop();\n\n  private:\n    // Perform an asynchronous read operation.\n    void schedule_read();\n\n    // Perform an asynchronous write operation.\n    void schedule_write();\n\n    // Socket for the connection.\n    asio::ip::tcp::socket socket_;\n\n    // The manager for this connection.\n    connection_manager &amp;connection_manager_;\n\n    // The handler used to process the incoming request.\n    request_handler &amp;request_handler_;\n\n    // Buffer for incoming data.\n    std::array&lt;char, 8192&gt; buffer_;\n\n    // The incoming request.\n    request request_;\n\n    // The parser for the incoming request.\n    request_parser request_parser_;\n\n    // The reply to be sent back to the client.\n    reply reply_;\n};\n</code></pre> <p>  Share Snippets </p> Construct a connection <pre><code>connection::connection(asio::ip::tcp::socket socket,\n                       connection_manager &amp;manager,\n                       request_handler &amp;handler)\n    : socket_(std::move(socket)), connection_manager_(manager),\n      request_handler_(handler) {}\n</code></pre> Start connection by reading <pre><code>void connection::start() { schedule_read(); }\n</code></pre> Stop connection by closing socket <pre><code>void connection::stop() { socket_.close(); }\n</code></pre> Schedule read operation <pre><code>void connection::schedule_read() {\n    auto self(shared_from_this());\n    socket_.async_read_some(\n        asio::buffer(buffer_),\n        [this, self](std::error_code ec, std::size_t bytes_transferred) {\n            if (!ec) {\n                // Parse as an HTTP request\n                request_parser::result_type result;\n                std::tie(result, std::ignore) = request_parser_.parse(\n                    request_, buffer_.data(),\n                    buffer_.data() + bytes_transferred);\n\n                // Generate reply with the request handler and write it\n                if (result == request_parser::good) {\n                    request_handler_.handle_request(request_, reply_);\n                    schedule_write();\n                } else if (result == request_parser::bad) {\n                    reply_ = reply::stock_reply(reply::bad_request);\n                    schedule_write();\n                } else {\n                    schedule_read();\n                }\n            } else if (ec != asio::error::operation_aborted) {\n                connection_manager_.stop(shared_from_this());\n            }\n        });\n}\n</code></pre> schedule_write operation <pre><code>void connection::schedule_write() {\n    auto self(shared_from_this());\n    asio::async_write(socket_, reply_.to_buffers(),\n                      [this, self](std::error_code ec, std::size_t) {\n                          if (!ec) {\n                              // Initiate graceful connection closure.\n                              asio::error_code ignored_ec;\n                              socket_.shutdown(\n                                  asio::ip::tcp::socket::shutdown_both,\n                                  ignored_ec);\n                          }\n\n                          if (ec != asio::error::operation_aborted) {\n                              connection_manager_.stop(shared_from_this());\n                          }\n                      });\n}\n</code></pre> <p>  Share Snippets </p> A reply to be sent to a client. <pre><code>struct reply {\n    // The status of the reply.\n    enum status_type {\n        ok = 200,\n        created = 201,\n        accepted = 202,\n        no_content = 204,\n        multiple_choices = 300,\n        moved_permanently = 301,\n        moved_temporarily = 302,\n        not_modified = 304,\n        bad_request = 400,\n        unauthorized = 401,\n        forbidden = 403,\n        not_found = 404,\n        internal_server_error = 500,\n        not_implemented = 501,\n        bad_gateway = 502,\n        service_unavailable = 503\n    } status;\n\n    // The headers to be included in the reply.\n    std::vector&lt;header&gt; headers;\n\n    // The content to be sent in the reply.\n    std::string content;\n\n    // Convert the reply into a vector of buffers. The buffers do not\n    // own the underlying memory blocks, therefore the reply object\n    // must remain valid and not be changed until the write operation\n    // has completed.\n    std::vector&lt;asio::const_buffer&gt; to_buffers();\n\n    // Get a stock reply.\n    static reply stock_reply(status_type status);\n};\n</code></pre> <p>  Share Snippets </p> Status Strings <pre><code>namespace status_strings {\n\n    const std::string ok = \"HTTP/1.0 200 OK\\r\\n\";\n    const std::string created = \"HTTP/1.0 201 Created\\r\\n\";\n    const std::string accepted = \"HTTP/1.0 202 Accepted\\r\\n\";\n    const std::string no_content = \"HTTP/1.0 204 No Content\\r\\n\";\n    const std::string multiple_choices =\n        \"HTTP/1.0 300 Multiple Choices\\r\\n\";\n    const std::string moved_permanently =\n        \"HTTP/1.0 301 Moved Permanently\\r\\n\";\n    const std::string moved_temporarily =\n        \"HTTP/1.0 302 Moved Temporarily\\r\\n\";\n    const std::string not_modified = \"HTTP/1.0 304 Not Modified\\r\\n\";\n    const std::string bad_request = \"HTTP/1.0 400 Bad Request\\r\\n\";\n    const std::string unauthorized = \"HTTP/1.0 401 Unauthorized\\r\\n\";\n    const std::string forbidden = \"HTTP/1.0 403 Forbidden\\r\\n\";\n    const std::string not_found = \"HTTP/1.0 404 Not Found\\r\\n\";\n    const std::string internal_server_error =\n        \"HTTP/1.0 500 Internal Server Error\\r\\n\";\n    const std::string not_implemented = \"HTTP/1.0 501 Not Implemented\\r\\n\";\n    const std::string bad_gateway = \"HTTP/1.0 502 Bad Gateway\\r\\n\";\n    const std::string service_unavailable =\n        \"HTTP/1.0 503 Service Unavailable\\r\\n\";\n</code></pre> Store status string in buffer <pre><code>    asio::const_buffer to_buffer(reply::status_type status) {\n        switch (status) {\n        case reply::ok:\n            return asio::buffer(ok);\n        case reply::created:\n            return asio::buffer(created);\n        case reply::accepted:\n            return asio::buffer(accepted);\n        case reply::no_content:\n            return asio::buffer(no_content);\n        case reply::multiple_choices:\n            return asio::buffer(multiple_choices);\n        case reply::moved_permanently:\n            return asio::buffer(moved_permanently);\n        case reply::moved_temporarily:\n            return asio::buffer(moved_temporarily);\n        case reply::not_modified:\n            return asio::buffer(not_modified);\n        case reply::bad_request:\n            return asio::buffer(bad_request);\n        case reply::unauthorized:\n            return asio::buffer(unauthorized);\n        case reply::forbidden:\n            return asio::buffer(forbidden);\n        case reply::not_found:\n            return asio::buffer(not_found);\n        case reply::internal_server_error:\n            return asio::buffer(internal_server_error);\n        case reply::not_implemented:\n            return asio::buffer(not_implemented);\n        case reply::bad_gateway:\n            return asio::buffer(bad_gateway);\n        case reply::service_unavailable:\n            return asio::buffer(service_unavailable);\n        default:\n            return asio::buffer(internal_server_error);\n        }\n    }\n} // namespace status_strings\n</code></pre> Write reply to buffers <pre><code>namespace misc_strings {\n    const char name_value_separator[] = {':', ' '};\n    const char crlf[] = {'\\r', '\\n'};\n} // namespace misc_strings\n\nstd::vector&lt;asio::const_buffer&gt; reply::to_buffers() {\n    std::vector&lt;asio::const_buffer&gt; buffers;\n    buffers.push_back(status_strings::to_buffer(status));\n    for (std::size_t i = 0; i &lt; headers.size(); ++i) {\n        header &amp;h = headers[i];\n        buffers.push_back(asio::buffer(h.name));\n        buffers.push_back(asio::buffer(misc_strings::name_value_separator));\n        buffers.push_back(asio::buffer(h.value));\n        buffers.push_back(asio::buffer(misc_strings::crlf));\n    }\n    buffers.push_back(asio::buffer(misc_strings::crlf));\n    buffers.push_back(asio::buffer(content));\n    return buffers;\n}\n</code></pre> Stock replies for messages <pre><code>namespace stock_replies {\n\n    namespace as_string {\n        constexpr char ok[] = \"\";\n        constexpr char created[] = \"&lt;html&gt;\"\n                                   \"&lt;head&gt;&lt;title&gt;Created&lt;/title&gt;&lt;/head&gt;\"\n                                   \"&lt;body&gt;&lt;h1&gt;201 Created&lt;/h1&gt;&lt;/body&gt;\"\n                                   \"&lt;/html&gt;\";\n        constexpr char accepted[] = \"&lt;html&gt;\"\n                                    \"&lt;head&gt;&lt;title&gt;Accepted&lt;/title&gt;&lt;/head&gt;\"\n                                    \"&lt;body&gt;&lt;h1&gt;202 Accepted&lt;/h1&gt;&lt;/body&gt;\"\n                                    \"&lt;/html&gt;\";\n        constexpr char no_content[] =\n            \"&lt;html&gt;\"\n            \"&lt;head&gt;&lt;title&gt;No Content&lt;/title&gt;&lt;/head&gt;\"\n            \"&lt;body&gt;&lt;h1&gt;204 Content&lt;/h1&gt;&lt;/body&gt;\"\n            \"&lt;/html&gt;\";\n        constexpr char multiple_choices[] =\n            \"&lt;html&gt;\"\n            \"&lt;head&gt;&lt;title&gt;Multiple Choices&lt;/title&gt;&lt;/head&gt;\"\n            \"&lt;body&gt;&lt;h1&gt;300 Multiple Choices&lt;/h1&gt;&lt;/body&gt;\"\n            \"&lt;/html&gt;\";\n        constexpr char moved_permanently[] =\n            \"&lt;html&gt;\"\n            \"&lt;head&gt;&lt;title&gt;Moved Permanently&lt;/title&gt;&lt;/head&gt;\"\n            \"&lt;body&gt;&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;&lt;/body&gt;\"\n            \"&lt;/html&gt;\";\n        constexpr char moved_temporarily[] =\n            \"&lt;html&gt;\"\n            \"&lt;head&gt;&lt;title&gt;Moved Temporarily&lt;/title&gt;&lt;/head&gt;\"\n            \"&lt;body&gt;&lt;h1&gt;302 Moved Temporarily&lt;/h1&gt;&lt;/body&gt;\"\n            \"&lt;/html&gt;\";\n        constexpr char not_modified[] =\n            \"&lt;html&gt;\"\n            \"&lt;head&gt;&lt;title&gt;Not Modified&lt;/title&gt;&lt;/head&gt;\"\n            \"&lt;body&gt;&lt;h1&gt;304 Not Modified&lt;/h1&gt;&lt;/body&gt;\"\n            \"&lt;/html&gt;\";\n        constexpr char bad_request[] =\n            \"&lt;html&gt;\"\n            \"&lt;head&gt;&lt;title&gt;Bad Request&lt;/title&gt;&lt;/head&gt;\"\n            \"&lt;body&gt;&lt;h1&gt;400 Bad Request&lt;/h1&gt;&lt;/body&gt;\"\n            \"&lt;/html&gt;\";\n        constexpr char unauthorized[] =\n            \"&lt;html&gt;\"\n            \"&lt;head&gt;&lt;title&gt;Unauthorized&lt;/title&gt;&lt;/head&gt;\"\n            \"&lt;body&gt;&lt;h1&gt;401 Unauthorized&lt;/h1&gt;&lt;/body&gt;\"\n            \"&lt;/html&gt;\";\n        constexpr char forbidden[] = \"&lt;html&gt;\"\n                                     \"&lt;head&gt;&lt;title&gt;Forbidden&lt;/title&gt;&lt;/head&gt;\"\n                                     \"&lt;body&gt;&lt;h1&gt;403 Forbidden&lt;/h1&gt;&lt;/body&gt;\"\n                                     \"&lt;/html&gt;\";\n        constexpr char not_found[] = \"&lt;html&gt;\"\n                                     \"&lt;head&gt;&lt;title&gt;Not Found&lt;/title&gt;&lt;/head&gt;\"\n                                     \"&lt;body&gt;&lt;h1&gt;404 Not Found&lt;/h1&gt;&lt;/body&gt;\"\n                                     \"&lt;/html&gt;\";\n        constexpr char internal_server_error[] =\n            \"&lt;html&gt;\"\n            \"&lt;head&gt;&lt;title&gt;Internal Server Error&lt;/title&gt;&lt;/head&gt;\"\n            \"&lt;body&gt;&lt;h1&gt;500 Internal Server Error&lt;/h1&gt;&lt;/body&gt;\"\n            \"&lt;/html&gt;\";\n        constexpr char not_implemented[] =\n            \"&lt;html&gt;\"\n            \"&lt;head&gt;&lt;title&gt;Not Implemented&lt;/title&gt;&lt;/head&gt;\"\n            \"&lt;body&gt;&lt;h1&gt;501 Not Implemented&lt;/h1&gt;&lt;/body&gt;\"\n            \"&lt;/html&gt;\";\n        constexpr char bad_gateway[] =\n            \"&lt;html&gt;\"\n            \"&lt;head&gt;&lt;title&gt;Bad Gateway&lt;/title&gt;&lt;/head&gt;\"\n            \"&lt;body&gt;&lt;h1&gt;502 Bad Gateway&lt;/h1&gt;&lt;/body&gt;\"\n            \"&lt;/html&gt;\";\n        constexpr char service_unavailable[] =\n            \"&lt;html&gt;\"\n            \"&lt;head&gt;&lt;title&gt;Service Unavailable&lt;/title&gt;&lt;/head&gt;\"\n            \"&lt;body&gt;&lt;h1&gt;503 Service Unavailable&lt;/h1&gt;&lt;/body&gt;\"\n            \"&lt;/html&gt;\";\n    } // namespace as_string\n\n    std::string to_string(reply::status_type status) {\n        switch (status) {\n        case reply::ok: // NOLINT(bugprone-branch-clone)\n            return as_string::ok;\n        case reply::created:\n            return as_string::created;\n        case reply::accepted:\n            return as_string::accepted;\n        case reply::no_content:\n            return as_string::no_content;\n        case reply::multiple_choices:\n            return as_string::multiple_choices;\n        case reply::moved_permanently:\n            return as_string::moved_permanently;\n        case reply::moved_temporarily:\n            return as_string::moved_temporarily;\n        case reply::not_modified:\n            return as_string::not_modified;\n        case reply::bad_request:\n            return as_string::bad_request;\n        case reply::unauthorized:\n            return as_string::unauthorized;\n        case reply::forbidden:\n            return as_string::forbidden;\n        case reply::not_found:\n            return as_string::not_found;\n        case reply::internal_server_error:\n            return as_string::internal_server_error;\n        case reply::not_implemented:\n            return as_string::not_implemented;\n        case reply::bad_gateway:\n            return as_string::bad_gateway;\n        case reply::service_unavailable:\n            return as_string::service_unavailable;\n        default:\n            return as_string::internal_server_error;\n        }\n    }\n} // namespace stock_replies\n</code></pre> Create stock reply from status <pre><code>reply reply::stock_reply(reply::status_type status) {\n    reply rep;\n    rep.status = status;\n    rep.headers.resize(2);\n    rep.headers[0].name = \"Content-Length\";\n    rep.content = stock_replies::to_string(status);\n    rep.headers[0].value = std::to_string(rep.content.size());\n    rep.headers[1].name = \"Content-Type\";\n    rep.headers[1].value = \"text/html\";\n    return rep;\n}\n</code></pre> <p>  Share Snippets </p> Struct for request headers <pre><code>struct header {\n    std::string name;\n    std::string value;\n};\n</code></pre> <p>  Share Snippets </p> A request received from a client. <pre><code>struct request {\n    std::string method;\n    std::string uri;\n    int http_version_major;\n    int http_version_minor;\n    std::vector&lt;header&gt; headers;\n};\n</code></pre> <p>  Share Snippets </p> Parser for incoming requests. <pre><code>class request_parser {\n  public:\n    // Construct ready to parse the request method.\n    request_parser();\n\n    // Reset to initial parser state.\n    void reset();\n\n    // Result of parse.\n    enum result_type { good, bad, indeterminate };\n\n    // Parse some data. The enum return value is good when a complete\n    // request has been parsed, bad if the data is invalid,\n    // indeterminate when more data is required. The InputIterator\n    // return value indicates how much of the input has been consumed.\n    template &lt;typename InputIterator&gt;\n    std::tuple&lt;result_type, InputIterator&gt;\n    parse(request &amp;req, InputIterator begin, InputIterator end) {\n        while (begin != end) {\n            result_type result = consume(req, *begin++);\n            if (result == good || result == bad)\n                return std::make_tuple(result, begin);\n        }\n        return std::make_tuple(indeterminate, begin);\n    }\n\n  private:\n    // Handle the next character of input.\n    result_type consume(request &amp;req, char input);\n\n    // Check if a byte is an HTTP character.\n    static bool is_char(int c);\n\n    // Check if a byte is an HTTP control character.\n    static bool is_ctl(int c);\n\n    // Check if a byte is defined as an HTTP tspecial character.\n    static bool is_tspecial(int c);\n\n    // Check if a byte is a digit.\n    static bool is_digit(int c);\n\n    // The current state of the parser.\n    enum state {\n        method_start,\n        method,\n        uri,\n        http_version_h,\n        http_version_t_1,\n        http_version_t_2,\n        http_version_p,\n        http_version_slash,\n        http_version_major_start,\n        http_version_major,\n        http_version_minor_start,\n        http_version_minor,\n        expecting_newline_1,\n        header_line_start,\n        header_lws,\n        header_name,\n        space_before_header_value,\n        header_value,\n        expecting_newline_2,\n        expecting_newline_3\n    } state_;\n};\n</code></pre> <p>  Share Snippets </p> Construct parser <pre><code>request_parser::request_parser() : state_(method_start) {}\n</code></pre> Reset parser <pre><code>void request_parser::reset() { state_ = method_start; }\n</code></pre> Consume char input <pre><code>request_parser::result_type request_parser::consume(request &amp;req,\n                                                    char input) {\n    switch (state_) {\n    case method_start:\n        if (!is_char(input) || is_ctl(input) || is_tspecial(input)) {\n            return bad;\n        } else {\n            state_ = method;\n            req.method.push_back(input);\n            return indeterminate;\n        }\n    case method:\n        if (input == ' ') {\n            state_ = uri;\n            return indeterminate;\n        } else if (!is_char(input) || is_ctl(input) || is_tspecial(input)) {\n            return bad;\n        } else {\n            req.method.push_back(input);\n            return indeterminate;\n        }\n    case uri:\n        if (input == ' ') {\n            state_ = http_version_h;\n            return indeterminate;\n        } else if (is_ctl(input)) {\n            return bad;\n        } else {\n            req.uri.push_back(input);\n            return indeterminate;\n        }\n    case http_version_h:\n        if (input == 'H') {\n            state_ = http_version_t_1;\n            return indeterminate;\n        } else {\n            return bad;\n        }\n    case http_version_t_1:\n        if (input == 'T') {\n            state_ = http_version_t_2;\n            return indeterminate;\n        } else {\n            return bad;\n        }\n    case http_version_t_2:\n        if (input == 'T') {\n            state_ = http_version_p;\n            return indeterminate;\n        } else {\n            return bad;\n        }\n    case http_version_p:\n        if (input == 'P') {\n            state_ = http_version_slash;\n            return indeterminate;\n        } else {\n            return bad;\n        }\n    case http_version_slash:\n        if (input == '/') {\n            req.http_version_major = 0;\n            req.http_version_minor = 0;\n            state_ = http_version_major_start;\n            return indeterminate;\n        } else {\n            return bad;\n        }\n    case http_version_major_start:\n        if (is_digit(input)) {\n            req.http_version_major =\n                req.http_version_major * 10 + input - '0';\n            state_ = http_version_major;\n            return indeterminate;\n        } else {\n            return bad;\n        }\n    case http_version_major:\n        if (input == '.') {\n            state_ = http_version_minor_start;\n            return indeterminate;\n        } else if (is_digit(input)) {\n            req.http_version_major =\n                req.http_version_major * 10 + input - '0';\n            return indeterminate;\n        } else {\n            return bad;\n        }\n    case http_version_minor_start:\n        if (is_digit(input)) {\n            req.http_version_minor =\n                req.http_version_minor * 10 + input - '0';\n            state_ = http_version_minor;\n            return indeterminate;\n        } else {\n            return bad;\n        }\n    case http_version_minor:\n        if (input == '\\r') {\n            state_ = expecting_newline_1;\n            return indeterminate;\n        } else if (is_digit(input)) {\n            req.http_version_minor =\n                req.http_version_minor * 10 + input - '0';\n            return indeterminate;\n        } else {\n            return bad;\n        }\n    case expecting_newline_1:\n        if (input == '\\n') {\n            state_ = header_line_start;\n            return indeterminate;\n        } else {\n            return bad;\n        }\n    case header_line_start:\n        if (input == '\\r') {\n            state_ = expecting_newline_3;\n            return indeterminate;\n        } else if (!req.headers.empty() &amp;&amp;\n                   (input == ' ' || input == '\\t')) {\n            state_ = header_lws;\n            return indeterminate;\n        } else if (!is_char(input) || is_ctl(input) || is_tspecial(input)) {\n            return bad;\n        } else {\n            req.headers.push_back(header());\n            req.headers.back().name.push_back(input);\n            state_ = header_name;\n            return indeterminate;\n        }\n    case header_lws:\n        if (input == '\\r') {\n            state_ = expecting_newline_2;\n            return indeterminate;\n        } else if (input == ' ' || input == '\\t') {\n            return indeterminate;\n        } else if (is_ctl(input)) {\n            return bad;\n        } else {\n            state_ = header_value;\n            req.headers.back().value.push_back(input);\n            return indeterminate;\n        }\n    case header_name:\n        if (input == ':') {\n            state_ = space_before_header_value;\n            return indeterminate;\n        } else if (!is_char(input) || is_ctl(input) || is_tspecial(input)) {\n            return bad;\n        } else {\n            req.headers.back().name.push_back(input);\n            return indeterminate;\n        }\n    case space_before_header_value:\n        if (input == ' ') {\n            state_ = header_value;\n            return indeterminate;\n        } else {\n            return bad;\n        }\n    case header_value:\n        if (input == '\\r') {\n            state_ = expecting_newline_2;\n            return indeterminate;\n        } else if (is_ctl(input)) {\n            return bad;\n        } else {\n            req.headers.back().value.push_back(input);\n            return indeterminate;\n        }\n    case expecting_newline_2:\n        if (input == '\\n') {\n            state_ = header_line_start;\n            return indeterminate;\n        } else {\n            return bad;\n        }\n    case expecting_newline_3:\n        return (input == '\\n') ? good : bad;\n    default:\n        return bad;\n    }\n}\n</code></pre> Check if c is char <pre><code>bool request_parser::is_char(int c) { return c &gt;= 0 &amp;&amp; c &lt;= 127; }\n</code></pre> Check if c is ctl <pre><code>bool request_parser::is_ctl(int c) {\n    return (c &gt;= 0 &amp;&amp; c &lt;= 31) || (c == 127);\n}\n</code></pre> Check if c is special <pre><code>bool request_parser::is_tspecial(int c) {\n    switch (c) {\n    case '(':\n    case ')':\n    case '&lt;':\n    case '&gt;':\n    case '@':\n    case ',':\n    case ';':\n    case ':':\n    case '\\\\':\n    case '\"':\n    case '/':\n    case '[':\n    case ']':\n    case '?':\n    case '=':\n    case '{':\n    case '}':\n    case ' ':\n    case '\\t':\n        return true;\n    default:\n        return false;\n    }\n}\n</code></pre> Check if c is digit <pre><code>bool request_parser::is_digit(int c) { return c &gt;= '0' &amp;&amp; c &lt;= '9'; }\n</code></pre> <p>  Share Snippets </p> The common handler for all incoming requests. <pre><code>class request_handler {\n  public:\n    request_handler(const request_handler &amp;) = delete;\n    request_handler &amp;operator=(const request_handler &amp;) = delete;\n\n    // Construct with a directory containing files to be served.\n    explicit request_handler(const std::string &amp;doc_root);\n\n    // Handle a request and produce a reply.\n    void handle_request(const request &amp;req, reply &amp;rep);\n\n  private:\n    // The directory containing the files to be served.\n    std::string doc_root_;\n\n    // Perform URL-decoding on a string. Returns false if the encoding\n    // was invalid.\n    static bool url_decode(const std::string &amp;in, std::string &amp;out);\n};\n</code></pre> <p>  Share Snippets </p> Request handler constructor <pre><code>request_handler::request_handler(const std::string &amp;doc_root)\n    : doc_root_(doc_root) {}\n</code></pre> Handle a parsed request and generate reply <pre><code>void request_handler::handle_request(const request &amp;req, reply &amp;rep) {\n    // Decode url to path.\n    std::string request_path;\n    if (!url_decode(req.uri, request_path)) {\n        rep = reply::stock_reply(reply::bad_request);\n        return;\n    }\n\n    // Request path must be absolute and not contain \"..\".\n    if (request_path.empty() || request_path[0] != '/' ||\n        request_path.find(\"..\") != std::string::npos) {\n        rep = reply::stock_reply(reply::bad_request);\n        return;\n    }\n\n    // If path ends in slash (i.e. is a directory) then add\n    // \"index.html\".\n    if (request_path[request_path.size() - 1] == '/') {\n        request_path += \"index.html\";\n    }\n\n    // Determine the file extension.\n    std::size_t last_slash_pos = request_path.find_last_of(\"/\");\n    std::size_t last_dot_pos = request_path.find_last_of(\".\");\n    std::string extension;\n    if (last_dot_pos != std::string::npos &amp;&amp;\n        last_dot_pos &gt; last_slash_pos) {\n        extension = request_path.substr(last_dot_pos + 1);\n    }\n\n    // Open the file to send back.\n    std::string full_path = doc_root_ + request_path;\n    std::ifstream is(full_path.c_str(), std::ios::in | std::ios::binary);\n    if (!is) {\n        rep = reply::stock_reply(reply::not_found);\n        return;\n    }\n\n    // Fill out the reply to be sent to the client.\n    rep.status = reply::ok;\n    char buf[512];\n    while (is.read(buf, sizeof(buf)).gcount() &gt; 0)\n        rep.content.append(buf, is.gcount());\n    rep.headers.resize(2);\n    rep.headers[0].name = \"Content-Length\";\n    rep.headers[0].value = std::to_string(rep.content.size());\n    rep.headers[1].name = \"Content-Type\";\n    rep.headers[1].value = mime_types::extension_to_type(extension);\n}\n</code></pre> Decode url string <pre><code>bool request_handler::url_decode(const std::string &amp;in, std::string &amp;out) {\n    out.clear();\n    out.reserve(in.size());\n    for (std::size_t i = 0; i &lt; in.size(); ++i) {\n        if (in[i] == '%') {\n            if (i + 3 &lt;= in.size()) {\n                int value = 0;\n                std::istringstream is(in.substr(i + 1, 2));\n                if (is &gt;&gt; std::hex &gt;&gt; value) {\n                    out += static_cast&lt;char&gt;(value);\n                    i += 2;\n                } else {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        } else if (in[i] == '+') {\n            out += ' ';\n        } else {\n            out += in[i];\n        }\n    }\n    return true;\n}\n</code></pre> <p>  Share Snippets </p> Convert a file extension into a MIME type. <pre><code>std::string extension_to_type(const std::string &amp;extension);\n</code></pre> <p>  Share Snippets </p> Map MIME types <pre><code>constexpr struct mapping {\n    const char *extension;\n    const char *mime_type;\n} mappings[] = {{\"gif\", \"image/gif\"},\n                {\"htm\", \"text/html\"},\n                {\"html\", \"text/html\"},\n                {\"jpg\", \"image/jpeg\"},\n                {\"png\", \"image/png\"}};\n</code></pre> Convert file extension to type <pre><code>std::string extension_to_type(const std::string &amp;extension) {\n    for (mapping m : mappings) {\n        if (m.extension == extension) {\n            return m.mime_type;\n        }\n    }\n\n    return \"text/plain\";\n}\n</code></pre> <p>  Share Snippets </p>"},{"location":"utilities/networking/network/","title":"Network","text":"Find ASIO <pre><code>find_package(Asio 1.21.0 QUIET)\nif (NOT Asio_FOUND)\n    FetchContent_Declare(asio GIT_REPOSITORY https://github.com/chriskohlhoff/asio.git GIT_TAG asio-1-21-0)\n    FetchContent_GetProperties(asio)\n    if (NOT asio_POPULATED)\n        FetchContent_Populate(asio)\n        add_library(asio INTERFACE)\n        target_include_directories(asio INTERFACE ${asio_SOURCE_DIR}/asio/include)\n        target_compile_definitions(asio INTERFACE ASIO_STANDALONE ASIO_NO_DEPRECATED)\n        target_link_libraries(asio INTERFACE Threads::Threads)\n    endif ()\nendif()\n</code></pre> CMakeLists.txt <pre><code>add_executable(network network.cpp)\ntarget_link_libraries(network asio)\n</code></pre> Create io_context executor <pre><code>// Object for network input and output\n// - All networking programs at least one io_context\n// - I/O execution context represents your program's link to the\n//   operating system's I/O services\nasio::io_context io_context;\n</code></pre> Create acceptor <pre><code>// The acceptor listens for connections\n// - Create the simplest server possible\nasio::ip::tcp::endpoint ep(asio::ip::tcp::v4(), 8080);\nasio::ip::tcp::acceptor acceptor(io_context, ep);\n</code></pre> Create connection socket <pre><code>// For loop listening to connections from client\n// - It will handle one connection at a time\n// - See the async example for more than one connection at a time\nwhile (true) {\n    // Connection socket\n    // - Represents the connection to the client\n    asio::ip::tcp::socket socket(io_context);\n</code></pre> or Create acceptor <pre><code>// The acceptor listens for connections\n// - Create the simplest server possible\nasio::ip::tcp::endpoint ep(asio::ip::tcp::v4(), 8080);\nasio::ip::tcp::acceptor acceptor(io_context, ep);\n</code></pre> Write response to client <pre><code>// - Transfer this information to the client with the socket\nstd::error_code error;\nasio::write(socket, asio::buffer(message), error);\n</code></pre> Check for errors <pre><code>    if (error) {\n        std::cout &lt;&lt; \"Error \" &lt;&lt; error.value() &lt;&lt; \": \"\n                  &lt;&lt; error.message() &lt;&lt; std::endl;\n    }\n} // while (true)\n</code></pre> <p>  Share Snippets </p>"},{"location":"utilities/regular-expressions/regex/","title":"Regex","text":"<p>Regex</p> <p>The regular expressions library provides a class that represents  regular expressions, which are a kind of mini-language used to perform pattern matching within strings. </p> Headers <pre><code>#include &lt;regex&gt;\n</code></pre> Match single expression <pre><code>if (std::regex_match(\"subject\", std::regex(\"(sub)(.*)\"))) {\n    std::cout &lt;&lt; \"subject matches expression (sub)(.*)\" &lt;&lt; '\\n';\n}\n</code></pre> Match string <pre><code>const char cstr[] = \"subject\";\nstd::string s(\"subject\");\nstd::regex e(\"(sub)(.*)\");\nif (regex_match(s, e)) {\n    std::cout &lt;&lt; \"subject matches expression (sub)(.*)\" &lt;&lt; '\\n';\n}\n</code></pre> Match char range <pre><code>if (std::regex_match(s.begin(), s.end(), e)) {\n    std::cout &lt;&lt; \"subject matches expression (sub)(.*)\" &lt;&lt; '\\n';\n}\n</code></pre> Store match results <pre><code>std::cmatch cm; // same as `match_results&lt;const char*&gt;`\nstd::regex_match(cstr, cm, e);\n</code></pre> Access match results <pre><code>std::cout &lt;&lt; \"literal string with \" &lt;&lt; cm.size() &lt;&lt; \" matches\" &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"The literal string matches were: \";\nfor (const auto &amp;i : cm) {\n    std::cout &lt;&lt; \"[\" &lt;&lt; i &lt;&lt; \"] \";\n}\nstd::cout &lt;&lt; '\\n';\n</code></pre> Store string match results <pre><code>std::smatch sm; // match_results&lt;string::const_iterator&gt;\nstd::regex_match(s, sm, e);\n</code></pre> Access string match results <pre><code>std::cout &lt;&lt; \"string object with \" &lt;&lt; sm.size() &lt;&lt; \" matches\" &lt;&lt; '\\n';\nstd::cout &lt;&lt; \"The string matches were: \";\nfor (const auto &amp;i : sm) {\n    std::cout &lt;&lt; \"[\" &lt;&lt; i &lt;&lt; \"] \";\n}\nstd::cout &lt;&lt; '\\n';\n</code></pre> Store string match results <pre><code>std::smatch sm; // match_results&lt;string::const_iterator&gt;\nstd::regex_match(s, sm, e);\n</code></pre> Using flags to determine behavior <pre><code>std::regex_match(cstr, cm, e, std::regex_constants::match_default);\n</code></pre> Iterate substrings with matches <pre><code>std::string ss = \"foo bar 123\";\nstd::regex r(\"([a-zA-Z]+)|(d+)\");\nstd::sregex_iterator match_it(ss.begin(), ss.end(), r);\nfor (; match_it != std::sregex_iterator(); ++match_it) {\n    std::smatch m = *match_it;\n    // Match\n    std::cout &lt;&lt; \"Match value: \" &lt;&lt; m.str() &lt;&lt; \" at position \"\n              &lt;&lt; m.position() &lt;&lt; '\\n';\n    // Groups\n    for (size_t index = 1; index &lt; m.size(); ++index) {\n        if (!m[index].str().empty()) {\n            std::cout &lt;&lt; \"Capture group ID: \" &lt;&lt; index - 1 &lt;&lt; '\\n';\n            break;\n        }\n    }\n}\n</code></pre> Regex expression conjunction <pre><code>std::string var = \"first second third forth\";\nif (regex_match(var, sm, std::regex(\"(.*) (.*) (.*) (.*)\"))) {\n    for (size_t i = 1; i &lt; sm.size(); i++) {\n        std::cout &lt;&lt; \"Match \" &lt;&lt; i &lt;&lt; \": \" &lt;&lt; sm[i] &lt;&lt; \" at position \"\n                  &lt;&lt; sm.position(i) &lt;&lt; '\\n';\n    }\n}\n</code></pre> Helper function to implode strings <pre><code>auto implode = [](const std::vector&lt;std::string&gt; &amp;strs,\n                  const std::string &amp;delim) {\n    std::stringstream s;\n    copy(strs.begin(), strs.end(),\n         std::ostream_iterator&lt;std::string&gt;(s, delim.c_str()));\n    return s.str();\n};\n</code></pre> Regex expression string disjunction <pre><code>var = \"user/32\";\nstd::smatch sm2;\nstd::vector&lt;std::string&gt; routes = {\"welcome\", \"user/\\\\d+\", \"post/[a-zA-Z]+\",\n                                   \"about\"};\nstd::regex disjunction(\"(\" + implode(routes, \")|(\") + \")\");\n</code></pre> Match disjunction <pre><code>if (std::regex_match(var, sm2, disjunction,\n                     std::regex_constants::match_not_null)) {\n    for (size_t index = 1; index &lt; sm2.size(); ++index) {\n        if (sm2[index].length() &gt; 0) {\n            std::cout &lt;&lt; \"Capture group index: \" &lt;&lt; index - 1 &lt;&lt; '\\n';\n            std::cout &lt;&lt; var &lt;&lt; \" matched route \" &lt;&lt; routes[index - 1]\n                      &lt;&lt; '\\n';\n            break;\n        }\n    }\n}\n</code></pre> <p>  Share Snippets </p>"}]}